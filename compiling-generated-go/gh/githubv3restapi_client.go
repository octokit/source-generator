//go:build go1.18
// +build go1.18

// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.9.4, generator: @autorest/go@4.0.0-preview.45)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package gh

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/streaming"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

type GitHubV3RESTAPIClient struct {
	endpoint string
	perPage *int32
	cursor *string
	deliveryID int32
	page *int32
	since *time.Time
	installationID int32
	clientID string
	appSlug string
	enterprise string
	state *string
	severity *string
	ecosystem *string
	packageParam *string
	scope *Enum44
	sortParam *Enum45
	direction *Enum46
	before *string
	after *string
	first *int32
	last *int32
	secretType *string
	resolution *string
	gistID string
	commentID int32
	labels *string
	accountID int32
	planID int32
	owner string
	repo string
	all *bool
	participating *bool
	threadID int32
	org string
	repositoryID int32
	requiredWorkflowID int32
	runnerID int32
	name string
	secretName string
	username string
	toolName *string
	toolGUID *string
	hookID int32
	invitationID int32
	codespaceName string
	migrationID int32
	repoName string
	visibility *Enum118
	packageType Enum121
	packageName string
	packageVersionID int32
	teamSlug string
	discussionNumber int32
	commentNumber int32
	reactionID int32
	projectID int32
	securityProduct Enum157
	enablement Enum158
	cardID int32
	columnID int32
	requiredWorkflowIDForRepo int32
	artifactID int32
	ref *string
	key *string
	cacheID int32
	jobID int32
	actor *string
	branch *string
	event *string
	status *Enum177
	created *time.Time
	excludePullRequests *bool
	checkSuiteID *int32
	headSHA *string
	runID int32
	attemptNumber int32
	workflowID string
	autolinkID int32
	checkRunID int32
	checkName *string
	alertNumber int32
	commitSHA string
	manifest *string
	deploymentID int32
	environmentName string
	branchPolicyID int32
	issueNumber int32
	keyID int32
	milestoneNumber int32
	pullNumber int32
	reviewID int32
	assetID int32
	releaseID int32
	tagProtectionID int32
	per *Enum293
	order *Enum295
	teamID int32
	exportID string
	gpgKeyID int32
	sshSigningKeyID int32
	pl runtime.Pipeline
}

// NewGitHubV3RESTAPIClient creates a new instance of GitHubV3RESTAPIClient with the specified values.
//   - apiGithubCom - server parameter
//   - installationID - The unique identifier of the installation.
//   - clientID - The client ID of the GitHub app.
//   - enterprise - The slug version of the enterprise name. You can also substitute this value with the enterprise id.
//   - gistID - The unique identifier of the gist.
//   - commentID - The unique identifier of the comment.
//   - accountID - account_id parameter
//   - planID - The unique identifier of the plan.
//   - owner - The account owner of the repository. The name is not case sensitive.
//   - repo - The name of the repository. The name is not case sensitive.
//   - threadID - The unique identifier of the notification thread. This corresponds to the value returned in the id field when
//     you retrieve notifications (for example with the GET /notifications operation
//     [https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user]).
//   - org - The organization name. The name is not case sensitive.
//   - repositoryID - The unique identifier of the repository.
//   - requiredWorkflowID - The unique identifier of the required workflow.
//   - runnerID - Unique identifier of the self-hosted runner.
//   - name - The name of a self-hosted runner's custom label.
//   - secretName - The name of the secret.
//   - username - The handle for the GitHub user account.
//   - hookID - The unique identifier of the hook.
//   - invitationID - The unique identifier of the invitation.
//   - codespaceName - The name of the codespace.
//   - migrationID - The unique identifier of the migration.
//   - repoName - repo_name parameter
//   - packageType - The type of supported package. Packages in GitHub's Gradle registry have the type maven. Docker images pushed
//     to GitHub's Container registry (ghcr.io) have the type container. You can use the type
//     docker to find images that were pushed to GitHub's Docker registry (docker.pkg.github.com), even if these have now been
//     migrated to the Container registry.
//   - packageName - The name of the package.
//   - packageVersionID - Unique identifier of the package version.
//   - teamSlug - The slug of the team name.
//   - discussionNumber - The number that identifies the discussion.
//   - commentNumber - The number that identifies the comment.
//   - reactionID - The unique identifier of the reaction.
//   - projectID - The unique identifier of the project.
//   - securityProduct - The security feature to enable or disable.
//   - enablement - The action to take.
//     enable_all means to enable the specified security feature for all repositories in the organization.disable_all means to
//     disable the specified security feature for all repositories in the organization.
//   - cardID - The unique identifier of the card.
//   - columnID - The unique identifier of the column.
//   - requiredWorkflowIDForRepo - The ID of the required workflow that has run at least once in a repository.
//   - artifactID - The unique identifier of the artifact.
//   - cacheID - The unique identifier of the GitHub Actions cache.
//   - jobID - The unique identifier of the job.
//   - runID - The unique identifier of the workflow run.
//   - attemptNumber - The attempt number of the workflow run.
//   - workflowID - The ID of the workflow. You can also pass the workflow file name as a string.
//   - autolinkID - The unique identifier of the autolink.
//   - checkRunID - The unique identifier of the check run.
//   - alertNumber - The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within
//     GitHub, and in the number field in the response from the GET
//     /repos/{owner}/{repo}/code-scanning/alerts operation.
//   - commitSHA - The SHA of the commit.
//   - deploymentID - deployment_id parameter
//   - environmentName - The name of the environment.
//   - branchPolicyID - The unique identifier of the branch policy.
//   - issueNumber - The number that identifies the issue.
//   - keyID - The unique identifier of the key.
//   - milestoneNumber - The number that identifies the milestone.
//   - pullNumber - The number that identifies the pull request.
//   - reviewID - The unique identifier of the review.
//   - assetID - The unique identifier of the asset.
//   - releaseID - The unique identifier of the release.
//   - tagProtectionID - The unique identifier of the tag protection.
//   - teamID - The unique identifier of the team.
//   - exportID - The ID of the export operation, or latest. Currently only latest is currently supported.
//   - gpgKeyID - The unique identifier of the GPG key.
//   - sshSigningKeyID - The unique identifier of the SSH signing key.
//   - perPage - The number of results per page (max 100).
//   - cursor - Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the link header
//     for the next and previous page cursors.
//   - page - Page number of the results to fetch.
//   - since - Only show notifications updated after the given time. This is a timestamp in ISO 8601 [https://en.wikipedia.org/wiki/ISO_8601]
//     format: YYYY-MM-DDTHH:MM:SSZ.
//   - state - A comma-separated list of states. If specified, only alerts with these states will be returned.
//     Can be: dismissed, fixed, open
//   - severity - A comma-separated list of severities. If specified, only alerts with these severities will be returned.
//     Can be: low, medium, high, critical
//   - ecosystem - A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.
//     Can be: composer, go, maven, npm, nuget, pip, pub, rubygems, rust
//   - packageParam - A comma-separated list of package names. If specified, only alerts for these packages will be returned.
//   - scope - The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
//   - sortParam - The property by which to sort the results.created means when the alert was created.updated means when the alert's
//     state last changed.
//   - direction - The direction to sort the results by.
//   - before - A cursor, as given in the Link header [https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header].
//     If specified, the query only searches for results before this cursor.
//   - after - A cursor, as given in the Link header [https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header].
//     If specified, the query only searches for results after this cursor.
//   - first - Deprecated. The number of results per page (max 100), starting from the first matching result. This parameter must
//     not be used in combination with last. Instead, use per_page in combination with after
//     to fetch the first page of results.
//   - last - Deprecated. The number of results per page (max 100), starting from the last matching result. This parameter must
//     not be used in combination with first. Instead, use per_page in combination with
//     before to fetch the last page of results.
//   - secretType - A comma-separated list of secret types to return. By default all secret types are returned. See "Secret scanning
//     patterns
//     [https://docs.github.com/code-security/secret-scanning/secret-scanning-patterns#supported-secrets-for-advanced-security]"
//     for a complete list of secret types.
//   - resolution - A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed.
//     Valid resolutions are falsepositive, wontfix, revoked, patternedited, patterndeleted or
//     usedintests.
//   - labels - A list of comma separated label names. Example: bug,ui,@high
//   - all - If true, show notifications marked as read.
//   - participating - If true, only shows notifications in which the user is directly participating or mentioned.
//   - toolName - The name of a code scanning tool. Only results by this tool will be listed. You can specify the tool by using
//     either toolname or toolguid, but not both.
//   - toolGUID - The GUID of a code scanning tool. Only results by this tool will be listed. Note that some code scanning tools
//     may not include a GUID in their analysis data. You can specify the tool by using either
//     toolguid or toolname, but not both.
//   - visibility - The selected visibility of the packages. This parameter is optional and only filters an existing result set.
//     The internal visibility is only supported for GitHub Packages registries that allow for granular permissions. For other
//     ecosystems internal is synonymous with private. For the list of GitHub Packages
//     registries that support granular permissions, see "About permissions for GitHub Packages
//     [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages]."
//   - ref - The Git reference for the results you want to list. The ref for a branch can be formatted either as refs/heads/ or
//     simply . To reference a pull request use refs/pull//merge.
//   - key - An explicit key or prefix for identifying the cache
//   - actor - Returns someone's workflow runs. Use the login for the user who created the push associated with the check suite
//     or workflow run.
//   - branch - Returns workflow runs associated with a branch. Use the name of the branch of the push.
//   - event - Returns workflow run triggered by the event you specify. For example, push, pull_request or issue. For more information,
//     see "Events that trigger workflows
//     [https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows]."
//   - status - Returns workflow runs with the check run status or conclusion that you specify. For example, a conclusion can
//     be success or a status can be in_progress. Only GitHub can set a status of waiting or
//     requested.
//   - created - Returns workflow runs created within the given date-time range. For more information on the syntax, see "Understanding
//     the search syntax
//     [https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates]."
//   - excludePullRequests - If true pull requests are omitted from the response (empty array).
//   - checkSuiteID - Returns workflow runs with the checksuiteid that you specify.
//   - headSHA - Only returns workflow runs that are associated with the specified head_sha.
//   - checkName - Returns check runs with the specified name.
//   - manifest - A comma-separated list of full manifest paths. If specified, only alerts for these manifests will be returned.
//   - per - The time frame to display results for.
//   - order - Determines whether the first search result returned is the highest number of matches (desc) or lowest number of
//     matches (asc). This parameter is ignored unless you provide sort.
//   - pl - the pipeline used for sending requests and handling responses.
func NewGitHubV3RESTAPIClient(apiGithubCom *string, deliveryID int32, installationID int32, clientID string, appSlug string, enterprise string, gistID string, commentID int32, accountID int32, planID int32, owner string, repo string, threadID int32, org string, repositoryID int32, requiredWorkflowID int32, runnerID int32, name string, secretName string, username string, hookID int32, invitationID int32, codespaceName string, migrationID int32, repoName string, packageType Enum121, packageName string, packageVersionID int32, teamSlug string, discussionNumber int32, commentNumber int32, reactionID int32, projectID int32, securityProduct Enum157, enablement Enum158, cardID int32, columnID int32, requiredWorkflowIDForRepo int32, artifactID int32, cacheID int32, jobID int32, runID int32, attemptNumber int32, workflowID string, autolinkID int32, checkRunID int32, alertNumber int32, commitSHA string, deploymentID int32, environmentName string, branchPolicyID int32, issueNumber int32, keyID int32, milestoneNumber int32, pullNumber int32, reviewID int32, assetID int32, releaseID int32, tagProtectionID int32, teamID int32, exportID string, gpgKeyID int32, sshSigningKeyID int32, perPage *int32, cursor *string, page *int32, since *time.Time, state *string, severity *string, ecosystem *string, packageParam *string, scope *Enum44, sortParam *Enum45, direction *Enum46, before *string, after *string, first *int32, last *int32, secretType *string, resolution *string, labels *string, all *bool, participating *bool, toolName *string, toolGUID *string, visibility *Enum118, ref *string, key *string, actor *string, branch *string, event *string, status *Enum177, created *time.Time, excludePullRequests *bool, checkSuiteID *int32, headSHA *string, checkName *string, manifest *string, per *Enum293, order *Enum295, pl runtime.Pipeline) *GitHubV3RESTAPIClient {
	hostURL := "{$host}"
	if apiGithubCom == nil {
		defaultValue := "https://api.github.com"
		apiGithubCom = &defaultValue
	}
	hostURL = strings.ReplaceAll(hostURL, "{$host}", *apiGithubCom)
	client := &GitHubV3RESTAPIClient{
		endpoint: hostURL,
		perPage: perPage,
		cursor: cursor,
		deliveryID: deliveryID,
		page: page,
		since: since,
		installationID: installationID,
		clientID: clientID,
		appSlug: appSlug,
		enterprise: enterprise,
		state: state,
		severity: severity,
		ecosystem: ecosystem,
		packageParam: packageParam,
		scope: scope,
		sortParam: sortParam,
		direction: direction,
		before: before,
		after: after,
		first: first,
		last: last,
		secretType: secretType,
		resolution: resolution,
		gistID: gistID,
		commentID: commentID,
		labels: labels,
		accountID: accountID,
		planID: planID,
		owner: owner,
		repo: repo,
		all: all,
		participating: participating,
		threadID: threadID,
		org: org,
		repositoryID: repositoryID,
		requiredWorkflowID: requiredWorkflowID,
		runnerID: runnerID,
		name: name,
		secretName: secretName,
		username: username,
		toolName: toolName,
		toolGUID: toolGUID,
		hookID: hookID,
		invitationID: invitationID,
		codespaceName: codespaceName,
		migrationID: migrationID,
		repoName: repoName,
		visibility: visibility,
		packageType: packageType,
		packageName: packageName,
		packageVersionID: packageVersionID,
		teamSlug: teamSlug,
		discussionNumber: discussionNumber,
		commentNumber: commentNumber,
		reactionID: reactionID,
		projectID: projectID,
		securityProduct: securityProduct,
		enablement: enablement,
		cardID: cardID,
		columnID: columnID,
		requiredWorkflowIDForRepo: requiredWorkflowIDForRepo,
		artifactID: artifactID,
		ref: ref,
		key: key,
		cacheID: cacheID,
		jobID: jobID,
		actor: actor,
		branch: branch,
		event: event,
		status: status,
		created: created,
		excludePullRequests: excludePullRequests,
		checkSuiteID: checkSuiteID,
		headSHA: headSHA,
		runID: runID,
		attemptNumber: attemptNumber,
		workflowID: workflowID,
		autolinkID: autolinkID,
		checkRunID: checkRunID,
		checkName: checkName,
		alertNumber: alertNumber,
		commitSHA: commitSHA,
		manifest: manifest,
		deploymentID: deploymentID,
		environmentName: environmentName,
		branchPolicyID: branchPolicyID,
		issueNumber: issueNumber,
		keyID: keyID,
		milestoneNumber: milestoneNumber,
		pullNumber: pullNumber,
		reviewID: reviewID,
		assetID: assetID,
		releaseID: releaseID,
		tagProtectionID: tagProtectionID,
		per: per,
		order: order,
		teamID: teamID,
		exportID: exportID,
		gpgKeyID: gpgKeyID,
		sshSigningKeyID: sshSigningKeyID,
		pl: pl,
	}
	return client
}

// ActionsAddCustomLabelsToSelfHostedRunnerForOrg - Add custom labels to a self-hosted runner configured in an organization.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForOrgOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.ActionsAddCustomLabelsToSelfHostedRunnerForOrg method.
func (client *GitHubV3RESTAPIClient) ActionsAddCustomLabelsToSelfHostedRunnerForOrg(ctx context.Context, body Paths1W217FrOrgsOrgActionsRunnersRunnerIDLabelsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForOrgOptions) (GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse, error) {
	req, err := client.actionsAddCustomLabelsToSelfHostedRunnerForOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsAddCustomLabelsToSelfHostedRunnerForOrgHandleResponse(resp)
}

// actionsAddCustomLabelsToSelfHostedRunnerForOrgCreateRequest creates the ActionsAddCustomLabelsToSelfHostedRunnerForOrg request.
func (client *GitHubV3RESTAPIClient) actionsAddCustomLabelsToSelfHostedRunnerForOrgCreateRequest(ctx context.Context, body Paths1W217FrOrgsOrgActionsRunnersRunnerIDLabelsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/runners/{runner_id}/labels"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{runner_id}", url.PathEscape(strconv.FormatInt(int64(client.runnerID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// actionsAddCustomLabelsToSelfHostedRunnerForOrgHandleResponse handles the ActionsAddCustomLabelsToSelfHostedRunnerForOrg response.
func (client *GitHubV3RESTAPIClient) actionsAddCustomLabelsToSelfHostedRunnerForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse, error) {
	result := GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ComponentsDhs7QhResponsesActionsRunnerLabelsContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsAddCustomLabelsToSelfHostedRunnerForRepo - Add custom labels to a self-hosted runner configured in a repository.
// You must authenticate using an access token with the repo scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForRepoOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.ActionsAddCustomLabelsToSelfHostedRunnerForRepo method.
func (client *GitHubV3RESTAPIClient) ActionsAddCustomLabelsToSelfHostedRunnerForRepo(ctx context.Context, body PathsFmuj89ReposOwnerRepoActionsRunnersRunnerIDLabelsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForRepoOptions) (GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse, error) {
	req, err := client.actionsAddCustomLabelsToSelfHostedRunnerForRepoCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsAddCustomLabelsToSelfHostedRunnerForRepoHandleResponse(resp)
}

// actionsAddCustomLabelsToSelfHostedRunnerForRepoCreateRequest creates the ActionsAddCustomLabelsToSelfHostedRunnerForRepo request.
func (client *GitHubV3RESTAPIClient) actionsAddCustomLabelsToSelfHostedRunnerForRepoCreateRequest(ctx context.Context, body PathsFmuj89ReposOwnerRepoActionsRunnersRunnerIDLabelsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{runner_id}", url.PathEscape(strconv.FormatInt(int64(client.runnerID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// actionsAddCustomLabelsToSelfHostedRunnerForRepoHandleResponse handles the ActionsAddCustomLabelsToSelfHostedRunnerForRepo response.
func (client *GitHubV3RESTAPIClient) actionsAddCustomLabelsToSelfHostedRunnerForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse, error) {
	result := GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ComponentsDhs7QhResponsesActionsRunnerLabelsContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsAddSelectedRepoToOrgSecret - Adds a repository to an organization secret when the visibility for repository access
// is set to selected. The visibility is set when you Create or update an organization secret
// [https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret]. You must authenticate using an
// access token with the admin:org scope to use this endpoint. GitHub Apps must
// have the secrets organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsAddSelectedRepoToOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsAddSelectedRepoToOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) ActionsAddSelectedRepoToOrgSecret(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientActionsAddSelectedRepoToOrgSecretOptions) (GitHubV3RESTAPIClientActionsAddSelectedRepoToOrgSecretResponse, error) {
	req, err := client.actionsAddSelectedRepoToOrgSecretCreateRequest(ctx, repositoryID, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsAddSelectedRepoToOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsAddSelectedRepoToOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusConflict) {
		return GitHubV3RESTAPIClientActionsAddSelectedRepoToOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsAddSelectedRepoToOrgSecretResponse{}, nil
}

// actionsAddSelectedRepoToOrgSecretCreateRequest creates the ActionsAddSelectedRepoToOrgSecret request.
func (client *GitHubV3RESTAPIClient) actionsAddSelectedRepoToOrgSecretCreateRequest(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientActionsAddSelectedRepoToOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsAddSelectedRepoToOrgVariable - Adds a repository to an organization variable that is available to selected repositories.
// Organization variables that are available to selected repositories have their visibility field set to selected
// . You must authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must have the
// organizationactionsvariables:write organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsAddSelectedRepoToOrgVariableOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsAddSelectedRepoToOrgVariable
//     method.
func (client *GitHubV3RESTAPIClient) ActionsAddSelectedRepoToOrgVariable(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientActionsAddSelectedRepoToOrgVariableOptions) (GitHubV3RESTAPIClientActionsAddSelectedRepoToOrgVariableResponse, error) {
	req, err := client.actionsAddSelectedRepoToOrgVariableCreateRequest(ctx, repositoryID, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsAddSelectedRepoToOrgVariableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsAddSelectedRepoToOrgVariableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusConflict) {
		return GitHubV3RESTAPIClientActionsAddSelectedRepoToOrgVariableResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsAddSelectedRepoToOrgVariableResponse{}, nil
}

// actionsAddSelectedRepoToOrgVariableCreateRequest creates the ActionsAddSelectedRepoToOrgVariable request.
func (client *GitHubV3RESTAPIClient) actionsAddSelectedRepoToOrgVariableCreateRequest(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientActionsAddSelectedRepoToOrgVariableOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.name == "" {
		return nil, errors.New("parameter client.name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(client.name))
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsAddSelectedRepoToRequiredWorkflow - Adds a repository to a required workflow. To use this endpoint, the required
// workflow must be configured to run on selected repositories.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// For more information, see "Required Workflows [https://docs.github.com/actions/using-workflows/required-workflows]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsAddSelectedRepoToRequiredWorkflowOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ActionsAddSelectedRepoToRequiredWorkflow method.
func (client *GitHubV3RESTAPIClient) ActionsAddSelectedRepoToRequiredWorkflow(ctx context.Context, options *GitHubV3RESTAPIClientActionsAddSelectedRepoToRequiredWorkflowOptions) (GitHubV3RESTAPIClientActionsAddSelectedRepoToRequiredWorkflowResponse, error) {
	req, err := client.actionsAddSelectedRepoToRequiredWorkflowCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsAddSelectedRepoToRequiredWorkflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsAddSelectedRepoToRequiredWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientActionsAddSelectedRepoToRequiredWorkflowResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsAddSelectedRepoToRequiredWorkflowResponse{}, nil
}

// actionsAddSelectedRepoToRequiredWorkflowCreateRequest creates the ActionsAddSelectedRepoToRequiredWorkflow request.
func (client *GitHubV3RESTAPIClient) actionsAddSelectedRepoToRequiredWorkflowCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsAddSelectedRepoToRequiredWorkflowOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories/{repository_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{required_workflow_id}", url.PathEscape(strconv.FormatInt(int64(client.requiredWorkflowID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsApproveWorkflowRun - Approves a workflow run for a pull request from a public fork of a first time contributor.
// For more information, see "Approving workflow runs from public forks
// [https://docs.github.com/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks]."
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the actions:write
// permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsApproveWorkflowRunOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsApproveWorkflowRun
//     method.
func (client *GitHubV3RESTAPIClient) ActionsApproveWorkflowRun(ctx context.Context, options *GitHubV3RESTAPIClientActionsApproveWorkflowRunOptions) (GitHubV3RESTAPIClientActionsApproveWorkflowRunResponse, error) {
	req, err := client.actionsApproveWorkflowRunCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsApproveWorkflowRunResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsApproveWorkflowRunResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientActionsApproveWorkflowRunResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsApproveWorkflowRunHandleResponse(resp)
}

// actionsApproveWorkflowRunCreateRequest creates the ActionsApproveWorkflowRun request.
func (client *GitHubV3RESTAPIClient) actionsApproveWorkflowRunCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsApproveWorkflowRunOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}/approve"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsApproveWorkflowRunHandleResponse handles the ActionsApproveWorkflowRun response.
func (client *GitHubV3RESTAPIClient) actionsApproveWorkflowRunHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsApproveWorkflowRunResponse, error) {
	result := GitHubV3RESTAPIClientActionsApproveWorkflowRunResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsApproveWorkflowRunResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsApproveWorkflowRunResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsApproveWorkflowRunResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsApproveWorkflowRunResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsCancelWorkflowRun - Cancels a workflow run using its id. You must authenticate using an access token with the repo
// scope to use this endpoint. GitHub Apps must have the actions:write permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsCancelWorkflowRunOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsCancelWorkflowRun
//     method.
func (client *GitHubV3RESTAPIClient) ActionsCancelWorkflowRun(ctx context.Context, options *GitHubV3RESTAPIClientActionsCancelWorkflowRunOptions) (GitHubV3RESTAPIClientActionsCancelWorkflowRunResponse, error) {
	req, err := client.actionsCancelWorkflowRunCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCancelWorkflowRunResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCancelWorkflowRunResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusConflict) {
		return GitHubV3RESTAPIClientActionsCancelWorkflowRunResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsCancelWorkflowRunHandleResponse(resp)
}

// actionsCancelWorkflowRunCreateRequest creates the ActionsCancelWorkflowRun request.
func (client *GitHubV3RESTAPIClient) actionsCancelWorkflowRunCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsCancelWorkflowRunOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsCancelWorkflowRunHandleResponse handles the ActionsCancelWorkflowRun response.
func (client *GitHubV3RESTAPIClient) actionsCancelWorkflowRunHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsCancelWorkflowRunResponse, error) {
	result := GitHubV3RESTAPIClientActionsCancelWorkflowRunResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsCancelWorkflowRunResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsCancelWorkflowRunResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsCancelWorkflowRunResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsCreateEnvironmentVariable - Create an environment variable that you can reference in a GitHub Actions workflow.
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the
// environment:write repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsCreateEnvironmentVariableOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsCreateEnvironmentVariable
//     method.
func (client *GitHubV3RESTAPIClient) ActionsCreateEnvironmentVariable(ctx context.Context, body Paths1Nhe8S5RepositoriesRepositoryIDEnvironmentsEnvironmentNameVariablesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsCreateEnvironmentVariableOptions) (GitHubV3RESTAPIClientActionsCreateEnvironmentVariableResponse, error) {
	req, err := client.actionsCreateEnvironmentVariableCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateEnvironmentVariableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateEnvironmentVariableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientActionsCreateEnvironmentVariableResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsCreateEnvironmentVariableHandleResponse(resp)
}

// actionsCreateEnvironmentVariableCreateRequest creates the ActionsCreateEnvironmentVariable request.
func (client *GitHubV3RESTAPIClient) actionsCreateEnvironmentVariableCreateRequest(ctx context.Context, body Paths1Nhe8S5RepositoriesRepositoryIDEnvironmentsEnvironmentNameVariablesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsCreateEnvironmentVariableOptions) (*policy.Request, error) {
	urlPath := "/repositories/{repository_id}/environments/{environment_name}/variables"
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// actionsCreateEnvironmentVariableHandleResponse handles the ActionsCreateEnvironmentVariable response.
func (client *GitHubV3RESTAPIClient) actionsCreateEnvironmentVariableHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsCreateEnvironmentVariableResponse, error) {
	result := GitHubV3RESTAPIClientActionsCreateEnvironmentVariableResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return GitHubV3RESTAPIClientActionsCreateEnvironmentVariableResponse{}, err
	}
	return result, nil
}

// ActionsCreateOrUpdateEnvironmentSecret - Creates or updates an environment secret with an encrypted value. Encrypt your
// secret usingLibSodium [https://libsodium.gitbook.io/doc/bindingsforother_languages]. You must authenticate using an
// access token with the repo scope to use this endpoint. GitHub Apps must have the secrets repository permission to use this
// endpoint.
// EXAMPLE ENCRYPTING A SECRET USING NODE.JS Encrypt your secret using the libsodium-wrappers [https://www.npmjs.com/package/libsodium-wrappers]
// library.
// const sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the secret you want to
// encrypt const key = 'base64-encoded-public-key' // replace with the Base64
// encoded public key
// //Check if libsodium is ready and then proceed. sodium.ready.then(() => { // Convert Secret & Base64 key to Uint8Array.
// let binkey = sodium.frombase64(key, sodium.base64variants.ORIGINAL) let binsec =
// sodium.from_string(secret)
// //Encrypt the secret using LibSodium let encBytes = sodium.cryptoboxseal(binsec, binkey)
// // Convert encrypted Uint8Array to Base64 let output = sodium.tobase64(encBytes, sodium.base64variants.ORIGINAL)
// console.log(output) });
// EXAMPLE ENCRYPTING A SECRET USING PYTHON Encrypt your secret using pynacl [https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox]
// with Python 3.
// from base64 import b64encode from nacl import encoding, public
// def encrypt(publickey: str, secretvalue: str) -> str: """Encrypt a Unicode string using the public key.""" publickey =
// public.PublicKey(publickey.encode("utf-8"), encoding.Base64Encoder()) sealedbox =
// public.SealedBox(publickey) encrypted = sealedbox.encrypt(secretvalue.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
// EXAMPLE ENCRYPTING A SECRET USING C Encrypt your secret using the Sodium.Core [https://www.nuget.org/packages/Sodium.Core/]
// package.
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// EXAMPLE ENCRYPTING A SECRET USING RUBY Encrypt your secret using the rbnacl [https://github.com/RubyCrypto/rbnacl] gem.
// require "rbnacl" require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.frompublickey(publickey) encryptedsecret = box.encrypt("my_secret")
// PRINT THE BASE64 ENCODED SECRET
// puts Base64.strictencode64(encryptedsecret)
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsCreateOrUpdateEnvironmentSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsCreateOrUpdateEnvironmentSecret
//     method.
func (client *GitHubV3RESTAPIClient) ActionsCreateOrUpdateEnvironmentSecret(ctx context.Context, body PathsQg8Uu8RepositoriesRepositoryIDEnvironmentsEnvironmentNameSecretsSecretNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsCreateOrUpdateEnvironmentSecretOptions) (GitHubV3RESTAPIClientActionsCreateOrUpdateEnvironmentSecretResponse, error) {
	req, err := client.actionsCreateOrUpdateEnvironmentSecretCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateOrUpdateEnvironmentSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateOrUpdateEnvironmentSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsCreateOrUpdateEnvironmentSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsCreateOrUpdateEnvironmentSecretHandleResponse(resp)
}

// actionsCreateOrUpdateEnvironmentSecretCreateRequest creates the ActionsCreateOrUpdateEnvironmentSecret request.
func (client *GitHubV3RESTAPIClient) actionsCreateOrUpdateEnvironmentSecretCreateRequest(ctx context.Context, body PathsQg8Uu8RepositoriesRepositoryIDEnvironmentsEnvironmentNameSecretsSecretNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsCreateOrUpdateEnvironmentSecretOptions) (*policy.Request, error) {
	urlPath := "/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// actionsCreateOrUpdateEnvironmentSecretHandleResponse handles the ActionsCreateOrUpdateEnvironmentSecret response.
func (client *GitHubV3RESTAPIClient) actionsCreateOrUpdateEnvironmentSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsCreateOrUpdateEnvironmentSecretResponse, error) {
	result := GitHubV3RESTAPIClientActionsCreateOrUpdateEnvironmentSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return GitHubV3RESTAPIClientActionsCreateOrUpdateEnvironmentSecretResponse{}, err
	}
	return result, nil
}

// ActionsCreateOrUpdateOrgSecret - Creates or updates an organization secret with an encrypted value. Encrypt your secret
// usingLibSodium [https://libsodium.gitbook.io/doc/bindingsforother_languages]. You must authenticate using an
// access token with the admin:org scope to use this endpoint. GitHub Apps must have the secrets organization permission to
// use this endpoint.
// EXAMPLE ENCRYPTING A SECRET USING NODE.JS Encrypt your secret using the libsodium-wrappers [https://www.npmjs.com/package/libsodium-wrappers]
// library.
// const sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the secret you want to
// encrypt const key = 'base64-encoded-public-key' // replace with the Base64
// encoded public key
// //Check if libsodium is ready and then proceed. sodium.ready.then(() => { // Convert Secret & Base64 key to Uint8Array.
// let binkey = sodium.frombase64(key, sodium.base64variants.ORIGINAL) let binsec =
// sodium.from_string(secret)
// //Encrypt the secret using LibSodium let encBytes = sodium.cryptoboxseal(binsec, binkey)
// // Convert encrypted Uint8Array to Base64 let output = sodium.tobase64(encBytes, sodium.base64variants.ORIGINAL)
// console.log(output) });
// EXAMPLE ENCRYPTING A SECRET USING PYTHON Encrypt your secret using pynacl [https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox]
// with Python 3.
// from base64 import b64encode from nacl import encoding, public
// def encrypt(publickey: str, secretvalue: str) -> str: """Encrypt a Unicode string using the public key.""" publickey =
// public.PublicKey(publickey.encode("utf-8"), encoding.Base64Encoder()) sealedbox =
// public.SealedBox(publickey) encrypted = sealedbox.encrypt(secretvalue.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
// EXAMPLE ENCRYPTING A SECRET USING C Encrypt your secret using the Sodium.Core [https://www.nuget.org/packages/Sodium.Core/]
// package.
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// EXAMPLE ENCRYPTING A SECRET USING RUBY Encrypt your secret using the rbnacl [https://github.com/RubyCrypto/rbnacl] gem.
// require "rbnacl" require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.frompublickey(publickey) encryptedsecret = box.encrypt("my_secret")
// PRINT THE BASE64 ENCODED SECRET
// puts Base64.strictencode64(encryptedsecret)
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsCreateOrUpdateOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsCreateOrUpdateOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) ActionsCreateOrUpdateOrgSecret(ctx context.Context, body PathsQyj9RzOrgsOrgActionsSecretsSecretNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsCreateOrUpdateOrgSecretOptions) (GitHubV3RESTAPIClientActionsCreateOrUpdateOrgSecretResponse, error) {
	req, err := client.actionsCreateOrUpdateOrgSecretCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateOrUpdateOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateOrUpdateOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsCreateOrUpdateOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsCreateOrUpdateOrgSecretHandleResponse(resp)
}

// actionsCreateOrUpdateOrgSecretCreateRequest creates the ActionsCreateOrUpdateOrgSecret request.
func (client *GitHubV3RESTAPIClient) actionsCreateOrUpdateOrgSecretCreateRequest(ctx context.Context, body PathsQyj9RzOrgsOrgActionsSecretsSecretNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsCreateOrUpdateOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/secrets/{secret_name}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// actionsCreateOrUpdateOrgSecretHandleResponse handles the ActionsCreateOrUpdateOrgSecret response.
func (client *GitHubV3RESTAPIClient) actionsCreateOrUpdateOrgSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsCreateOrUpdateOrgSecretResponse, error) {
	result := GitHubV3RESTAPIClientActionsCreateOrUpdateOrgSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return GitHubV3RESTAPIClientActionsCreateOrUpdateOrgSecretResponse{}, err
	}
	return result, nil
}

// ActionsCreateOrUpdateRepoSecret - Creates or updates a repository secret with an encrypted value. Encrypt your secret usingLibSodium
// [https://libsodium.gitbook.io/doc/bindingsforother_languages]. You must authenticate using an access
// token with the repo scope to use this endpoint. GitHub Apps must have the secrets repository permission to use this endpoint.
// EXAMPLE ENCRYPTING A SECRET USING NODE.JS Encrypt your secret using the libsodium-wrappers [https://www.npmjs.com/package/libsodium-wrappers]
// library.
// const sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the secret you want to
// encrypt const key = 'base64-encoded-public-key' // replace with the Base64
// encoded public key
// //Check if libsodium is ready and then proceed. sodium.ready.then(() => { // Convert Secret & Base64 key to Uint8Array.
// let binkey = sodium.frombase64(key, sodium.base64variants.ORIGINAL) let binsec =
// sodium.from_string(secret)
// //Encrypt the secret using LibSodium let encBytes = sodium.cryptoboxseal(binsec, binkey)
// // Convert encrypted Uint8Array to Base64 let output = sodium.tobase64(encBytes, sodium.base64variants.ORIGINAL)
// console.log(output) });
// EXAMPLE ENCRYPTING A SECRET USING PYTHON Encrypt your secret using pynacl [https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox]
// with Python 3.
// from base64 import b64encode from nacl import encoding, public
// def encrypt(publickey: str, secretvalue: str) -> str: """Encrypt a Unicode string using the public key.""" publickey =
// public.PublicKey(publickey.encode("utf-8"), encoding.Base64Encoder()) sealedbox =
// public.SealedBox(publickey) encrypted = sealedbox.encrypt(secretvalue.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
// EXAMPLE ENCRYPTING A SECRET USING C Encrypt your secret using the Sodium.Core [https://www.nuget.org/packages/Sodium.Core/]
// package.
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// EXAMPLE ENCRYPTING A SECRET USING RUBY Encrypt your secret using the rbnacl [https://github.com/RubyCrypto/rbnacl] gem.
// require "rbnacl" require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.frompublickey(publickey) encryptedsecret = box.encrypt("my_secret")
// PRINT THE BASE64 ENCODED SECRET
// puts Base64.strictencode64(encryptedsecret)
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsCreateOrUpdateRepoSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsCreateOrUpdateRepoSecret
//     method.
func (client *GitHubV3RESTAPIClient) ActionsCreateOrUpdateRepoSecret(ctx context.Context, body Paths502FjbReposOwnerRepoActionsSecretsSecretNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsCreateOrUpdateRepoSecretOptions) (GitHubV3RESTAPIClientActionsCreateOrUpdateRepoSecretResponse, error) {
	req, err := client.actionsCreateOrUpdateRepoSecretCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateOrUpdateRepoSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateOrUpdateRepoSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsCreateOrUpdateRepoSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsCreateOrUpdateRepoSecretHandleResponse(resp)
}

// actionsCreateOrUpdateRepoSecretCreateRequest creates the ActionsCreateOrUpdateRepoSecret request.
func (client *GitHubV3RESTAPIClient) actionsCreateOrUpdateRepoSecretCreateRequest(ctx context.Context, body Paths502FjbReposOwnerRepoActionsSecretsSecretNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsCreateOrUpdateRepoSecretOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/secrets/{secret_name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// actionsCreateOrUpdateRepoSecretHandleResponse handles the ActionsCreateOrUpdateRepoSecret response.
func (client *GitHubV3RESTAPIClient) actionsCreateOrUpdateRepoSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsCreateOrUpdateRepoSecretResponse, error) {
	result := GitHubV3RESTAPIClientActionsCreateOrUpdateRepoSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return GitHubV3RESTAPIClientActionsCreateOrUpdateRepoSecretResponse{}, err
	}
	return result, nil
}

// ActionsCreateOrgVariable - Creates an organization variable that you can reference in a GitHub Actions workflow. You must
// authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must have
// the organizationactionsvariables:write organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsCreateOrgVariableOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsCreateOrgVariable
//     method.
func (client *GitHubV3RESTAPIClient) ActionsCreateOrgVariable(ctx context.Context, body Paths15IodaaOrgsOrgActionsVariablesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsCreateOrgVariableOptions) (GitHubV3RESTAPIClientActionsCreateOrgVariableResponse, error) {
	req, err := client.actionsCreateOrgVariableCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateOrgVariableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateOrgVariableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientActionsCreateOrgVariableResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsCreateOrgVariableHandleResponse(resp)
}

// actionsCreateOrgVariableCreateRequest creates the ActionsCreateOrgVariable request.
func (client *GitHubV3RESTAPIClient) actionsCreateOrgVariableCreateRequest(ctx context.Context, body Paths15IodaaOrgsOrgActionsVariablesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsCreateOrgVariableOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/variables"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// actionsCreateOrgVariableHandleResponse handles the ActionsCreateOrgVariable response.
func (client *GitHubV3RESTAPIClient) actionsCreateOrgVariableHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsCreateOrgVariableResponse, error) {
	result := GitHubV3RESTAPIClientActionsCreateOrgVariableResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return GitHubV3RESTAPIClientActionsCreateOrgVariableResponse{}, err
	}
	return result, nil
}

// ActionsCreateRegistrationTokenForOrg - Returns a token that you can pass to the config script. The token expires after
// one hour.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// EXAMPLE USING REGISTRATION TOKEN Configure your self-hosted runner, replacing TOKEN with the registration token provided
// by this endpoint.
// ./config.sh --url https://github.com/octo-org --token TOKEN
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsCreateRegistrationTokenForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsCreateRegistrationTokenForOrg
//     method.
func (client *GitHubV3RESTAPIClient) ActionsCreateRegistrationTokenForOrg(ctx context.Context, options *GitHubV3RESTAPIClientActionsCreateRegistrationTokenForOrgOptions) (GitHubV3RESTAPIClientActionsCreateRegistrationTokenForOrgResponse, error) {
	req, err := client.actionsCreateRegistrationTokenForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateRegistrationTokenForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateRegistrationTokenForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientActionsCreateRegistrationTokenForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsCreateRegistrationTokenForOrgHandleResponse(resp)
}

// actionsCreateRegistrationTokenForOrgCreateRequest creates the ActionsCreateRegistrationTokenForOrg request.
func (client *GitHubV3RESTAPIClient) actionsCreateRegistrationTokenForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsCreateRegistrationTokenForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/runners/registration-token"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsCreateRegistrationTokenForOrgHandleResponse handles the ActionsCreateRegistrationTokenForOrg response.
func (client *GitHubV3RESTAPIClient) actionsCreateRegistrationTokenForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsCreateRegistrationTokenForOrgResponse, error) {
	result := GitHubV3RESTAPIClientActionsCreateRegistrationTokenForOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AuthenticationToken); err != nil {
		return GitHubV3RESTAPIClientActionsCreateRegistrationTokenForOrgResponse{}, err
	}
	return result, nil
}

// ActionsCreateRegistrationTokenForRepo - Returns a token that you can pass to the config script. The token expires after
// one hour. You must authenticate using an access token with the repo scope to use this endpoint.
// EXAMPLE USING REGISTRATION TOKEN Configure your self-hosted runner, replacing TOKEN with the registration token provided
// by this endpoint.
// ./config.sh --url https://github.com/octo-org/octo-repo-artifacts --token TOKEN
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsCreateRegistrationTokenForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsCreateRegistrationTokenForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ActionsCreateRegistrationTokenForRepo(ctx context.Context, options *GitHubV3RESTAPIClientActionsCreateRegistrationTokenForRepoOptions) (GitHubV3RESTAPIClientActionsCreateRegistrationTokenForRepoResponse, error) {
	req, err := client.actionsCreateRegistrationTokenForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateRegistrationTokenForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateRegistrationTokenForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientActionsCreateRegistrationTokenForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsCreateRegistrationTokenForRepoHandleResponse(resp)
}

// actionsCreateRegistrationTokenForRepoCreateRequest creates the ActionsCreateRegistrationTokenForRepo request.
func (client *GitHubV3RESTAPIClient) actionsCreateRegistrationTokenForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsCreateRegistrationTokenForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runners/registration-token"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsCreateRegistrationTokenForRepoHandleResponse handles the ActionsCreateRegistrationTokenForRepo response.
func (client *GitHubV3RESTAPIClient) actionsCreateRegistrationTokenForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsCreateRegistrationTokenForRepoResponse, error) {
	result := GitHubV3RESTAPIClientActionsCreateRegistrationTokenForRepoResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AuthenticationToken); err != nil {
		return GitHubV3RESTAPIClientActionsCreateRegistrationTokenForRepoResponse{}, err
	}
	return result, nil
}

// ActionsCreateRemoveTokenForOrg - Returns a token that you can pass to the config script to remove a self-hosted runner
// from an organization. The token expires after one hour.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// EXAMPLE USING REMOVE TOKEN To remove your self-hosted runner from an organization, replace TOKEN with the remove token
// provided by this endpoint.
// ./config.sh remove --token TOKEN
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsCreateRemoveTokenForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsCreateRemoveTokenForOrg
//     method.
func (client *GitHubV3RESTAPIClient) ActionsCreateRemoveTokenForOrg(ctx context.Context, options *GitHubV3RESTAPIClientActionsCreateRemoveTokenForOrgOptions) (GitHubV3RESTAPIClientActionsCreateRemoveTokenForOrgResponse, error) {
	req, err := client.actionsCreateRemoveTokenForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateRemoveTokenForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateRemoveTokenForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientActionsCreateRemoveTokenForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsCreateRemoveTokenForOrgHandleResponse(resp)
}

// actionsCreateRemoveTokenForOrgCreateRequest creates the ActionsCreateRemoveTokenForOrg request.
func (client *GitHubV3RESTAPIClient) actionsCreateRemoveTokenForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsCreateRemoveTokenForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/runners/remove-token"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsCreateRemoveTokenForOrgHandleResponse handles the ActionsCreateRemoveTokenForOrg response.
func (client *GitHubV3RESTAPIClient) actionsCreateRemoveTokenForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsCreateRemoveTokenForOrgResponse, error) {
	result := GitHubV3RESTAPIClientActionsCreateRemoveTokenForOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AuthenticationToken); err != nil {
		return GitHubV3RESTAPIClientActionsCreateRemoveTokenForOrgResponse{}, err
	}
	return result, nil
}

// ActionsCreateRemoveTokenForRepo - Returns a token that you can pass to remove a self-hosted runner from a repository. The
// token expires after one hour. You must authenticate using an access token with the repo scope to use this
// endpoint.
// EXAMPLE USING REMOVE TOKEN To remove your self-hosted runner from a repository, replace TOKEN with the remove token provided
// by this endpoint.
// ./config.sh remove --token TOKEN
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsCreateRemoveTokenForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsCreateRemoveTokenForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ActionsCreateRemoveTokenForRepo(ctx context.Context, options *GitHubV3RESTAPIClientActionsCreateRemoveTokenForRepoOptions) (GitHubV3RESTAPIClientActionsCreateRemoveTokenForRepoResponse, error) {
	req, err := client.actionsCreateRemoveTokenForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateRemoveTokenForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateRemoveTokenForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientActionsCreateRemoveTokenForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsCreateRemoveTokenForRepoHandleResponse(resp)
}

// actionsCreateRemoveTokenForRepoCreateRequest creates the ActionsCreateRemoveTokenForRepo request.
func (client *GitHubV3RESTAPIClient) actionsCreateRemoveTokenForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsCreateRemoveTokenForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runners/remove-token"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsCreateRemoveTokenForRepoHandleResponse handles the ActionsCreateRemoveTokenForRepo response.
func (client *GitHubV3RESTAPIClient) actionsCreateRemoveTokenForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsCreateRemoveTokenForRepoResponse, error) {
	result := GitHubV3RESTAPIClientActionsCreateRemoveTokenForRepoResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AuthenticationToken); err != nil {
		return GitHubV3RESTAPIClientActionsCreateRemoveTokenForRepoResponse{}, err
	}
	return result, nil
}

// ActionsCreateRepoVariable - Creates a repository variable that you can reference in a GitHub Actions workflow. You must
// authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the
// actions_variables:write repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsCreateRepoVariableOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsCreateRepoVariable
//     method.
func (client *GitHubV3RESTAPIClient) ActionsCreateRepoVariable(ctx context.Context, body Paths10Z314YReposOwnerRepoActionsVariablesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsCreateRepoVariableOptions) (GitHubV3RESTAPIClientActionsCreateRepoVariableResponse, error) {
	req, err := client.actionsCreateRepoVariableCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateRepoVariableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateRepoVariableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientActionsCreateRepoVariableResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsCreateRepoVariableHandleResponse(resp)
}

// actionsCreateRepoVariableCreateRequest creates the ActionsCreateRepoVariable request.
func (client *GitHubV3RESTAPIClient) actionsCreateRepoVariableCreateRequest(ctx context.Context, body Paths10Z314YReposOwnerRepoActionsVariablesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsCreateRepoVariableOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/variables"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// actionsCreateRepoVariableHandleResponse handles the ActionsCreateRepoVariable response.
func (client *GitHubV3RESTAPIClient) actionsCreateRepoVariableHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsCreateRepoVariableResponse, error) {
	result := GitHubV3RESTAPIClientActionsCreateRepoVariableResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return GitHubV3RESTAPIClientActionsCreateRepoVariableResponse{}, err
	}
	return result, nil
}

// ActionsCreateRequiredWorkflow - Create a required workflow in an organization.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// For more information, see "Required Workflows [https://docs.github.com/actions/using-workflows/required-workflows]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsCreateRequiredWorkflowOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsCreateRequiredWorkflow
//     method.
func (client *GitHubV3RESTAPIClient) ActionsCreateRequiredWorkflow(ctx context.Context, body Paths115Dv7COrgsOrgActionsRequiredWorkflowsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsCreateRequiredWorkflowOptions) (GitHubV3RESTAPIClientActionsCreateRequiredWorkflowResponse, error) {
	req, err := client.actionsCreateRequiredWorkflowCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateRequiredWorkflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateRequiredWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientActionsCreateRequiredWorkflowResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsCreateRequiredWorkflowHandleResponse(resp)
}

// actionsCreateRequiredWorkflowCreateRequest creates the ActionsCreateRequiredWorkflow request.
func (client *GitHubV3RESTAPIClient) actionsCreateRequiredWorkflowCreateRequest(ctx context.Context, body Paths115Dv7COrgsOrgActionsRequiredWorkflowsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsCreateRequiredWorkflowOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/required_workflows"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// actionsCreateRequiredWorkflowHandleResponse handles the ActionsCreateRequiredWorkflow response.
func (client *GitHubV3RESTAPIClient) actionsCreateRequiredWorkflowHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsCreateRequiredWorkflowResponse, error) {
	result := GitHubV3RESTAPIClientActionsCreateRequiredWorkflowResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val RequiredWorkflow
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsCreateRequiredWorkflowResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsCreateRequiredWorkflowResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsCreateRequiredWorkflowResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsCreateWorkflowDispatch - You can use this endpoint to manually trigger a GitHub Actions workflow run. You can replace
// workflow_id with the workflow file name. For example, you could use main.yaml.
// You must configure your GitHub Actions workflow to run when the workflowdispatch webhook [/developers/webhooks-and-events/webhook-events-and-payloads#workflowdispatch]
// event occurs. The inputs are
// configured in the workflow file. For more information about how to configure the workflowdispatch event in the workflow
// file, see "Events that trigger workflows
// [/actions/reference/events-that-trigger-workflows#workflowdispatch]."
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the actions:write
// permission to use this endpoint. For more information, see "Creating a
// personal access token for the command line [https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsCreateWorkflowDispatchOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsCreateWorkflowDispatch
//     method.
func (client *GitHubV3RESTAPIClient) ActionsCreateWorkflowDispatch(ctx context.Context, body Paths16Q8335ReposOwnerRepoActionsWorkflowsWorkflowIDDispatchesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsCreateWorkflowDispatchOptions) (GitHubV3RESTAPIClientActionsCreateWorkflowDispatchResponse, error) {
	req, err := client.actionsCreateWorkflowDispatchCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateWorkflowDispatchResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsCreateWorkflowDispatchResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsCreateWorkflowDispatchResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsCreateWorkflowDispatchResponse{}, nil
}

// actionsCreateWorkflowDispatchCreateRequest creates the ActionsCreateWorkflowDispatch request.
func (client *GitHubV3RESTAPIClient) actionsCreateWorkflowDispatchCreateRequest(ctx context.Context, body Paths16Q8335ReposOwnerRepoActionsWorkflowsWorkflowIDDispatchesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsCreateWorkflowDispatchOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{workflow_id}", url.PathEscape(client.workflowID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// ActionsDeleteActionsCacheByID - Deletes a GitHub Actions cache for a repository, using a cache ID.
// You must authenticate using an access token with the repo scope to use this endpoint.
// GitHub Apps must have the actions:write permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDeleteActionsCacheByIDOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDeleteActionsCacheByID
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDeleteActionsCacheByID(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteActionsCacheByIDOptions) (GitHubV3RESTAPIClientActionsDeleteActionsCacheByIDResponse, error) {
	req, err := client.actionsDeleteActionsCacheByIDCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteActionsCacheByIDResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteActionsCacheByIDResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDeleteActionsCacheByIDResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDeleteActionsCacheByIDResponse{}, nil
}

// actionsDeleteActionsCacheByIDCreateRequest creates the ActionsDeleteActionsCacheByID request.
func (client *GitHubV3RESTAPIClient) actionsDeleteActionsCacheByIDCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteActionsCacheByIDOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/caches/{cache_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{cache_id}", url.PathEscape(strconv.FormatInt(int64(client.cacheID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsDeleteActionsCacheByKey - Deletes one or more GitHub Actions caches for a repository, using a complete cache key.
// By default, all caches that match the provided key are deleted, but you can optionally provide a Git ref to
// restrict deletions to caches that match both the provided key and the Git ref.
// You must authenticate using an access token with the repo scope to use this endpoint.
// GitHub Apps must have the actions:write permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDeleteActionsCacheByKeyOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDeleteActionsCacheByKey
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDeleteActionsCacheByKey(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteActionsCacheByKeyOptions) (GitHubV3RESTAPIClientActionsDeleteActionsCacheByKeyResponse, error) {
	req, err := client.actionsDeleteActionsCacheByKeyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteActionsCacheByKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteActionsCacheByKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsDeleteActionsCacheByKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsDeleteActionsCacheByKeyHandleResponse(resp)
}

// actionsDeleteActionsCacheByKeyCreateRequest creates the ActionsDeleteActionsCacheByKey request.
func (client *GitHubV3RESTAPIClient) actionsDeleteActionsCacheByKeyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteActionsCacheByKeyOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/caches"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.key != nil {
		reqQP.Set("key", *client.key)
	}
	if client.ref != nil {
		reqQP.Set("ref", *client.ref)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsDeleteActionsCacheByKeyHandleResponse handles the ActionsDeleteActionsCacheByKey response.
func (client *GitHubV3RESTAPIClient) actionsDeleteActionsCacheByKeyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsDeleteActionsCacheByKeyResponse, error) {
	result := GitHubV3RESTAPIClientActionsDeleteActionsCacheByKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsCacheList); err != nil {
		return GitHubV3RESTAPIClientActionsDeleteActionsCacheByKeyResponse{}, err
	}
	return result, nil
}

// ActionsDeleteArtifact - Deletes an artifact for a workflow run. You must authenticate using an access token with the repo
// scope to use this endpoint. GitHub Apps must have the actions:write permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDeleteArtifactOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDeleteArtifact
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDeleteArtifact(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteArtifactOptions) (GitHubV3RESTAPIClientActionsDeleteArtifactResponse, error) {
	req, err := client.actionsDeleteArtifactCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteArtifactResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteArtifactResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDeleteArtifactResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDeleteArtifactResponse{}, nil
}

// actionsDeleteArtifactCreateRequest creates the ActionsDeleteArtifact request.
func (client *GitHubV3RESTAPIClient) actionsDeleteArtifactCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteArtifactOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{artifact_id}", url.PathEscape(strconv.FormatInt(int64(client.artifactID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsDeleteEnvironmentSecret - Deletes a secret in an environment using the secret name. You must authenticate using
// an access token with the repo scope to use this endpoint. GitHub Apps must have the secrets repository permission
// to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDeleteEnvironmentSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDeleteEnvironmentSecret
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDeleteEnvironmentSecret(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteEnvironmentSecretOptions) (GitHubV3RESTAPIClientActionsDeleteEnvironmentSecretResponse, error) {
	req, err := client.actionsDeleteEnvironmentSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteEnvironmentSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteEnvironmentSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDeleteEnvironmentSecretResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDeleteEnvironmentSecretResponse{}, nil
}

// actionsDeleteEnvironmentSecretCreateRequest creates the ActionsDeleteEnvironmentSecret request.
func (client *GitHubV3RESTAPIClient) actionsDeleteEnvironmentSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteEnvironmentSecretOptions) (*policy.Request, error) {
	urlPath := "/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsDeleteEnvironmentVariable - Deletes an environment variable using the variable name. You must authenticate using
// an access token with the repo scope to use this endpoint. GitHub Apps must have the environment:write repository
// permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDeleteEnvironmentVariableOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDeleteEnvironmentVariable
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDeleteEnvironmentVariable(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteEnvironmentVariableOptions) (GitHubV3RESTAPIClientActionsDeleteEnvironmentVariableResponse, error) {
	req, err := client.actionsDeleteEnvironmentVariableCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteEnvironmentVariableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteEnvironmentVariableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDeleteEnvironmentVariableResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDeleteEnvironmentVariableResponse{}, nil
}

// actionsDeleteEnvironmentVariableCreateRequest creates the ActionsDeleteEnvironmentVariable request.
func (client *GitHubV3RESTAPIClient) actionsDeleteEnvironmentVariableCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteEnvironmentVariableOptions) (*policy.Request, error) {
	urlPath := "/repositories/{repository_id}/environments/{environment_name}/variables/{name}"
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	if client.name == "" {
		return nil, errors.New("parameter client.name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(client.name))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsDeleteOrgSecret - Deletes a secret in an organization using the secret name. You must authenticate using an access
// token with the admin:org scope to use this endpoint. GitHub Apps must have the secrets organization
// permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDeleteOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDeleteOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDeleteOrgSecret(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteOrgSecretOptions) (GitHubV3RESTAPIClientActionsDeleteOrgSecretResponse, error) {
	req, err := client.actionsDeleteOrgSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDeleteOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDeleteOrgSecretResponse{}, nil
}

// actionsDeleteOrgSecretCreateRequest creates the ActionsDeleteOrgSecret request.
func (client *GitHubV3RESTAPIClient) actionsDeleteOrgSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/secrets/{secret_name}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsDeleteOrgVariable - Deletes an organization variable using the variable name. You must authenticate using an access
// token with the admin:org scope to use this endpoint. GitHub Apps must have the organizationactions
// variables:write organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDeleteOrgVariableOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDeleteOrgVariable
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDeleteOrgVariable(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteOrgVariableOptions) (GitHubV3RESTAPIClientActionsDeleteOrgVariableResponse, error) {
	req, err := client.actionsDeleteOrgVariableCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteOrgVariableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteOrgVariableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDeleteOrgVariableResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDeleteOrgVariableResponse{}, nil
}

// actionsDeleteOrgVariableCreateRequest creates the ActionsDeleteOrgVariable request.
func (client *GitHubV3RESTAPIClient) actionsDeleteOrgVariableCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteOrgVariableOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/variables/{name}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.name == "" {
		return nil, errors.New("parameter client.name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(client.name))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsDeleteRepoSecret - Deletes a secret in a repository using the secret name. You must authenticate using an access
// token with the repo scope to use this endpoint. GitHub Apps must have the secrets repository permission to
// use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDeleteRepoSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDeleteRepoSecret
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDeleteRepoSecret(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteRepoSecretOptions) (GitHubV3RESTAPIClientActionsDeleteRepoSecretResponse, error) {
	req, err := client.actionsDeleteRepoSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteRepoSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteRepoSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDeleteRepoSecretResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDeleteRepoSecretResponse{}, nil
}

// actionsDeleteRepoSecretCreateRequest creates the ActionsDeleteRepoSecret request.
func (client *GitHubV3RESTAPIClient) actionsDeleteRepoSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteRepoSecretOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/secrets/{secret_name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsDeleteRepoVariable - Deletes a repository variable using the variable name. You must authenticate using an access
// token with the repo scope to use this endpoint. GitHub Apps must have the actions_variables:write
// repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDeleteRepoVariableOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDeleteRepoVariable
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDeleteRepoVariable(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteRepoVariableOptions) (GitHubV3RESTAPIClientActionsDeleteRepoVariableResponse, error) {
	req, err := client.actionsDeleteRepoVariableCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteRepoVariableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteRepoVariableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDeleteRepoVariableResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDeleteRepoVariableResponse{}, nil
}

// actionsDeleteRepoVariableCreateRequest creates the ActionsDeleteRepoVariable request.
func (client *GitHubV3RESTAPIClient) actionsDeleteRepoVariableCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteRepoVariableOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/variables/{name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.name == "" {
		return nil, errors.New("parameter client.name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(client.name))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsDeleteRequiredWorkflow - Deletes a required workflow configured in an organization.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// For more information, see "Required Workflows [https://docs.github.com/actions/using-workflows/required-workflows]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDeleteRequiredWorkflowOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDeleteRequiredWorkflow
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDeleteRequiredWorkflow(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteRequiredWorkflowOptions) (GitHubV3RESTAPIClientActionsDeleteRequiredWorkflowResponse, error) {
	req, err := client.actionsDeleteRequiredWorkflowCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteRequiredWorkflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteRequiredWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDeleteRequiredWorkflowResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDeleteRequiredWorkflowResponse{}, nil
}

// actionsDeleteRequiredWorkflowCreateRequest creates the ActionsDeleteRequiredWorkflow request.
func (client *GitHubV3RESTAPIClient) actionsDeleteRequiredWorkflowCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteRequiredWorkflowOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/required_workflows/{required_workflow_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{required_workflow_id}", url.PathEscape(strconv.FormatInt(int64(client.requiredWorkflowID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsDeleteSelfHostedRunnerFromOrg - Forces the removal of a self-hosted runner from an organization. You can use this
// endpoint to completely remove the runner when the machine you were using no longer exists.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDeleteSelfHostedRunnerFromOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDeleteSelfHostedRunnerFromOrg
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDeleteSelfHostedRunnerFromOrg(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteSelfHostedRunnerFromOrgOptions) (GitHubV3RESTAPIClientActionsDeleteSelfHostedRunnerFromOrgResponse, error) {
	req, err := client.actionsDeleteSelfHostedRunnerFromOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteSelfHostedRunnerFromOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteSelfHostedRunnerFromOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDeleteSelfHostedRunnerFromOrgResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDeleteSelfHostedRunnerFromOrgResponse{}, nil
}

// actionsDeleteSelfHostedRunnerFromOrgCreateRequest creates the ActionsDeleteSelfHostedRunnerFromOrg request.
func (client *GitHubV3RESTAPIClient) actionsDeleteSelfHostedRunnerFromOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteSelfHostedRunnerFromOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/runners/{runner_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{runner_id}", url.PathEscape(strconv.FormatInt(int64(client.runnerID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsDeleteSelfHostedRunnerFromRepo - Forces the removal of a self-hosted runner from a repository. You can use this
// endpoint to completely remove the runner when the machine you were using no longer exists.
// You must authenticate using an access token with the reposcope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDeleteSelfHostedRunnerFromRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDeleteSelfHostedRunnerFromRepo
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDeleteSelfHostedRunnerFromRepo(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteSelfHostedRunnerFromRepoOptions) (GitHubV3RESTAPIClientActionsDeleteSelfHostedRunnerFromRepoResponse, error) {
	req, err := client.actionsDeleteSelfHostedRunnerFromRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteSelfHostedRunnerFromRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteSelfHostedRunnerFromRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDeleteSelfHostedRunnerFromRepoResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDeleteSelfHostedRunnerFromRepoResponse{}, nil
}

// actionsDeleteSelfHostedRunnerFromRepoCreateRequest creates the ActionsDeleteSelfHostedRunnerFromRepo request.
func (client *GitHubV3RESTAPIClient) actionsDeleteSelfHostedRunnerFromRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteSelfHostedRunnerFromRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runners/{runner_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{runner_id}", url.PathEscape(strconv.FormatInt(int64(client.runnerID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsDeleteWorkflowRun - Delete a specific workflow run. Anyone with write access to the repository can use this endpoint.
// If the repository is private you must use an access token with the repo scope. GitHub Apps must have
// the actions:write permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDeleteWorkflowRunOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDeleteWorkflowRun
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDeleteWorkflowRun(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteWorkflowRunOptions) (GitHubV3RESTAPIClientActionsDeleteWorkflowRunResponse, error) {
	req, err := client.actionsDeleteWorkflowRunCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteWorkflowRunResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteWorkflowRunResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDeleteWorkflowRunResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDeleteWorkflowRunResponse{}, nil
}

// actionsDeleteWorkflowRunCreateRequest creates the ActionsDeleteWorkflowRun request.
func (client *GitHubV3RESTAPIClient) actionsDeleteWorkflowRunCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteWorkflowRunOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsDeleteWorkflowRunLogs - Deletes all logs for a workflow run. You must authenticate using an access token with the
// repo scope to use this endpoint. GitHub Apps must have the actions:write permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDeleteWorkflowRunLogsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDeleteWorkflowRunLogs
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDeleteWorkflowRunLogs(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteWorkflowRunLogsOptions) (GitHubV3RESTAPIClientActionsDeleteWorkflowRunLogsResponse, error) {
	req, err := client.actionsDeleteWorkflowRunLogsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteWorkflowRunLogsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDeleteWorkflowRunLogsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusForbidden, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientActionsDeleteWorkflowRunLogsResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsDeleteWorkflowRunLogsHandleResponse(resp)
}

// actionsDeleteWorkflowRunLogsCreateRequest creates the ActionsDeleteWorkflowRunLogs request.
func (client *GitHubV3RESTAPIClient) actionsDeleteWorkflowRunLogsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDeleteWorkflowRunLogsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}/logs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsDeleteWorkflowRunLogsHandleResponse handles the ActionsDeleteWorkflowRunLogs response.
func (client *GitHubV3RESTAPIClient) actionsDeleteWorkflowRunLogsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsDeleteWorkflowRunLogsResponse, error) {
	result := GitHubV3RESTAPIClientActionsDeleteWorkflowRunLogsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientActionsDeleteWorkflowRunLogsResponse{}, err
	}
	return result, nil
}

// ActionsDisableSelectedRepositoryGithubActionsOrganization - Removes a repository from the list of selected repositories
// that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for enabled_repositories
// must be configured to selected. For more information, see "Set GitHub Actions permissions for an organization."
// You must authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must have the administration
// organization permission to use this API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDisableSelectedRepositoryGithubActionsOrganizationOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.ActionsDisableSelectedRepositoryGithubActionsOrganization method.
func (client *GitHubV3RESTAPIClient) ActionsDisableSelectedRepositoryGithubActionsOrganization(ctx context.Context, options *GitHubV3RESTAPIClientActionsDisableSelectedRepositoryGithubActionsOrganizationOptions) (GitHubV3RESTAPIClientActionsDisableSelectedRepositoryGithubActionsOrganizationResponse, error) {
	req, err := client.actionsDisableSelectedRepositoryGithubActionsOrganizationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDisableSelectedRepositoryGithubActionsOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDisableSelectedRepositoryGithubActionsOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDisableSelectedRepositoryGithubActionsOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDisableSelectedRepositoryGithubActionsOrganizationResponse{}, nil
}

// actionsDisableSelectedRepositoryGithubActionsOrganizationCreateRequest creates the ActionsDisableSelectedRepositoryGithubActionsOrganization request.
func (client *GitHubV3RESTAPIClient) actionsDisableSelectedRepositoryGithubActionsOrganizationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDisableSelectedRepositoryGithubActionsOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/permissions/repositories/{repository_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsDisableWorkflow - Disables a workflow and sets the state of the workflow to disabledmanually. You can replace workflowid
// with the workflow file name. For example, you could use main.yaml.
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the actions:write
// permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDisableWorkflowOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDisableWorkflow
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDisableWorkflow(ctx context.Context, options *GitHubV3RESTAPIClientActionsDisableWorkflowOptions) (GitHubV3RESTAPIClientActionsDisableWorkflowResponse, error) {
	req, err := client.actionsDisableWorkflowCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDisableWorkflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDisableWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDisableWorkflowResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDisableWorkflowResponse{}, nil
}

// actionsDisableWorkflowCreateRequest creates the ActionsDisableWorkflow request.
func (client *GitHubV3RESTAPIClient) actionsDisableWorkflowCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDisableWorkflowOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{workflow_id}", url.PathEscape(client.workflowID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsDownloadArtifact - Gets a redirect URL to download an archive for a repository. This URL expires after 1 minute.
// Look for Location: in the response header to find the URL for the download. The :archive_format must be
// zip. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access
// token with the repo scope. GitHub Apps must have the actions:read permission
// to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDownloadArtifactOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDownloadArtifact
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDownloadArtifact(ctx context.Context, archiveFormat string, options *GitHubV3RESTAPIClientActionsDownloadArtifactOptions) (GitHubV3RESTAPIClientActionsDownloadArtifactResponse, error) {
	req, err := client.actionsDownloadArtifactCreateRequest(ctx, archiveFormat, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDownloadArtifactResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDownloadArtifactResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusGone) {
		return GitHubV3RESTAPIClientActionsDownloadArtifactResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsDownloadArtifactHandleResponse(resp)
}

// actionsDownloadArtifactCreateRequest creates the ActionsDownloadArtifact request.
func (client *GitHubV3RESTAPIClient) actionsDownloadArtifactCreateRequest(ctx context.Context, archiveFormat string, options *GitHubV3RESTAPIClientActionsDownloadArtifactOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{artifact_id}", url.PathEscape(strconv.FormatInt(int64(client.artifactID), 10)))
	if archiveFormat == "" {
		return nil, errors.New("parameter archiveFormat cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{archive_format}", url.PathEscape(archiveFormat))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsDownloadArtifactHandleResponse handles the ActionsDownloadArtifact response.
func (client *GitHubV3RESTAPIClient) actionsDownloadArtifactHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsDownloadArtifactResponse, error) {
	result := GitHubV3RESTAPIClientActionsDownloadArtifactResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientActionsDownloadArtifactResponse{}, err
	}
	return result, nil
}

// ActionsDownloadJobLogsForWorkflowRun - Gets a redirect URL to download a plain text file of logs for a workflow job. This
// link expires after 1 minute. Look for Location: in the response header to find the URL for the download. Anyone with
// read access to the repository can use this endpoint. If the repository is private you must use an access token with the
// repo scope. GitHub Apps must have the actions:read permission to use this
// endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDownloadJobLogsForWorkflowRunOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDownloadJobLogsForWorkflowRun
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDownloadJobLogsForWorkflowRun(ctx context.Context, options *GitHubV3RESTAPIClientActionsDownloadJobLogsForWorkflowRunOptions) (GitHubV3RESTAPIClientActionsDownloadJobLogsForWorkflowRunResponse, error) {
	req, err := client.actionsDownloadJobLogsForWorkflowRunCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDownloadJobLogsForWorkflowRunResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDownloadJobLogsForWorkflowRunResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDownloadJobLogsForWorkflowRunResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDownloadJobLogsForWorkflowRunResponse{}, nil
}

// actionsDownloadJobLogsForWorkflowRunCreateRequest creates the ActionsDownloadJobLogsForWorkflowRun request.
func (client *GitHubV3RESTAPIClient) actionsDownloadJobLogsForWorkflowRunCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDownloadJobLogsForWorkflowRunOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{job_id}", url.PathEscape(strconv.FormatInt(int64(client.jobID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsDownloadWorkflowRunAttemptLogs - Gets a redirect URL to download an archive of log files for a specific workflow
// run attempt. This link expires after 1 minute. Look for Location: in the response header to find the URL for the
// download. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an
// access token with the repo scope. GitHub Apps must have the actions:read
// permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDownloadWorkflowRunAttemptLogsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDownloadWorkflowRunAttemptLogs
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDownloadWorkflowRunAttemptLogs(ctx context.Context, options *GitHubV3RESTAPIClientActionsDownloadWorkflowRunAttemptLogsOptions) (GitHubV3RESTAPIClientActionsDownloadWorkflowRunAttemptLogsResponse, error) {
	req, err := client.actionsDownloadWorkflowRunAttemptLogsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDownloadWorkflowRunAttemptLogsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDownloadWorkflowRunAttemptLogsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDownloadWorkflowRunAttemptLogsResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDownloadWorkflowRunAttemptLogsResponse{}, nil
}

// actionsDownloadWorkflowRunAttemptLogsCreateRequest creates the ActionsDownloadWorkflowRunAttemptLogs request.
func (client *GitHubV3RESTAPIClient) actionsDownloadWorkflowRunAttemptLogsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDownloadWorkflowRunAttemptLogsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{attempt_number}", url.PathEscape(strconv.FormatInt(int64(client.attemptNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsDownloadWorkflowRunLogs - Gets a redirect URL to download an archive of log files for a workflow run. This link
// expires after 1 minute. Look forLocation: in the response header to find the URL for the download. Anyone with
// read access to the repository can use this endpoint. If the repository is private you must use an access token with the
// repo scope. GitHub Apps must have the actions:read permission to use this
// endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsDownloadWorkflowRunLogsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsDownloadWorkflowRunLogs
//     method.
func (client *GitHubV3RESTAPIClient) ActionsDownloadWorkflowRunLogs(ctx context.Context, options *GitHubV3RESTAPIClientActionsDownloadWorkflowRunLogsOptions) (GitHubV3RESTAPIClientActionsDownloadWorkflowRunLogsResponse, error) {
	req, err := client.actionsDownloadWorkflowRunLogsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDownloadWorkflowRunLogsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsDownloadWorkflowRunLogsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsDownloadWorkflowRunLogsResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsDownloadWorkflowRunLogsResponse{}, nil
}

// actionsDownloadWorkflowRunLogsCreateRequest creates the ActionsDownloadWorkflowRunLogs request.
func (client *GitHubV3RESTAPIClient) actionsDownloadWorkflowRunLogsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsDownloadWorkflowRunLogsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}/logs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsEnableSelectedRepositoryGithubActionsOrganization - Adds a repository to the list of selected repositories that
// are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for enabled_repositories
// must be
// must be configured to selected. For more information, see "Set GitHub Actions permissions for an organization."
// You must authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must have the administration
// organization permission to use this API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsEnableSelectedRepositoryGithubActionsOrganizationOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.ActionsEnableSelectedRepositoryGithubActionsOrganization method.
func (client *GitHubV3RESTAPIClient) ActionsEnableSelectedRepositoryGithubActionsOrganization(ctx context.Context, options *GitHubV3RESTAPIClientActionsEnableSelectedRepositoryGithubActionsOrganizationOptions) (GitHubV3RESTAPIClientActionsEnableSelectedRepositoryGithubActionsOrganizationResponse, error) {
	req, err := client.actionsEnableSelectedRepositoryGithubActionsOrganizationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsEnableSelectedRepositoryGithubActionsOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsEnableSelectedRepositoryGithubActionsOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsEnableSelectedRepositoryGithubActionsOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsEnableSelectedRepositoryGithubActionsOrganizationResponse{}, nil
}

// actionsEnableSelectedRepositoryGithubActionsOrganizationCreateRequest creates the ActionsEnableSelectedRepositoryGithubActionsOrganization request.
func (client *GitHubV3RESTAPIClient) actionsEnableSelectedRepositoryGithubActionsOrganizationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsEnableSelectedRepositoryGithubActionsOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/permissions/repositories/{repository_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsEnableWorkflow - Enables a workflow and sets the state of the workflow to active. You can replace workflow_id with
// the workflow file name. For example, you could use main.yaml.
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the actions:write
// permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsEnableWorkflowOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsEnableWorkflow
//     method.
func (client *GitHubV3RESTAPIClient) ActionsEnableWorkflow(ctx context.Context, options *GitHubV3RESTAPIClientActionsEnableWorkflowOptions) (GitHubV3RESTAPIClientActionsEnableWorkflowResponse, error) {
	req, err := client.actionsEnableWorkflowCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsEnableWorkflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsEnableWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsEnableWorkflowResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsEnableWorkflowResponse{}, nil
}

// actionsEnableWorkflowCreateRequest creates the ActionsEnableWorkflow request.
func (client *GitHubV3RESTAPIClient) actionsEnableWorkflowCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsEnableWorkflowOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{workflow_id}", url.PathEscape(client.workflowID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsGetActionsCacheList - Lists the GitHub Actions caches for a repository. You must authenticate using an access token
// with the repo scope to use this endpoint. GitHub Apps must have the actions:read permission to use this
// endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetActionsCacheListOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetActionsCacheList
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetActionsCacheList(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetActionsCacheListOptions) (GitHubV3RESTAPIClientActionsGetActionsCacheListResponse, error) {
	req, err := client.actionsGetActionsCacheListCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetActionsCacheListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetActionsCacheListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetActionsCacheListResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetActionsCacheListHandleResponse(resp)
}

// actionsGetActionsCacheListCreateRequest creates the ActionsGetActionsCacheList request.
func (client *GitHubV3RESTAPIClient) actionsGetActionsCacheListCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetActionsCacheListOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/caches"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.ref != nil {
		reqQP.Set("ref", *client.ref)
	}
	if client.key != nil {
		reqQP.Set("key", *client.key)
	}
	if client.sortParam != nil {
		reqQP.Set("sort", string(*client.sortParam))
	}
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetActionsCacheListHandleResponse handles the ActionsGetActionsCacheList response.
func (client *GitHubV3RESTAPIClient) actionsGetActionsCacheListHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetActionsCacheListResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetActionsCacheListResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsCacheList); err != nil {
		return GitHubV3RESTAPIClientActionsGetActionsCacheListResponse{}, err
	}
	return result, nil
}

// ActionsGetActionsCacheUsage - Gets GitHub Actions cache usage for a repository. The data fetched using this API is refreshed
// approximately every 5 minutes, so values returned from this endpoint may take at least 5 minutes to get
// updated. Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an
// access token with the repo scope. GitHub Apps must have the actions:read
// permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetActionsCacheUsageOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetActionsCacheUsage
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetActionsCacheUsage(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetActionsCacheUsageOptions) (GitHubV3RESTAPIClientActionsGetActionsCacheUsageResponse, error) {
	req, err := client.actionsGetActionsCacheUsageCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetActionsCacheUsageResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetActionsCacheUsageResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetActionsCacheUsageResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetActionsCacheUsageHandleResponse(resp)
}

// actionsGetActionsCacheUsageCreateRequest creates the ActionsGetActionsCacheUsage request.
func (client *GitHubV3RESTAPIClient) actionsGetActionsCacheUsageCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetActionsCacheUsageOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/cache/usage"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetActionsCacheUsageHandleResponse handles the ActionsGetActionsCacheUsage response.
func (client *GitHubV3RESTAPIClient) actionsGetActionsCacheUsageHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetActionsCacheUsageResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetActionsCacheUsageResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsCacheUsageByRepository); err != nil {
		return GitHubV3RESTAPIClientActionsGetActionsCacheUsageResponse{}, err
	}
	return result, nil
}

// ActionsGetActionsCacheUsageByRepoForOrg - Lists repositories and their GitHub Actions cache usage for an organization.
// The data fetched using this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take
// at least 5 minutes to get updated. You must authenticate using an access token with the read:org scope to use this endpoint.
// GitHub Apps must have the organization_admistration:read permission to use
// this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetActionsCacheUsageByRepoForOrgOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ActionsGetActionsCacheUsageByRepoForOrg method.
func (client *GitHubV3RESTAPIClient) ActionsGetActionsCacheUsageByRepoForOrg(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetActionsCacheUsageByRepoForOrgOptions) (GitHubV3RESTAPIClientActionsGetActionsCacheUsageByRepoForOrgResponse, error) {
	req, err := client.actionsGetActionsCacheUsageByRepoForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetActionsCacheUsageByRepoForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetActionsCacheUsageByRepoForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetActionsCacheUsageByRepoForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetActionsCacheUsageByRepoForOrgHandleResponse(resp)
}

// actionsGetActionsCacheUsageByRepoForOrgCreateRequest creates the ActionsGetActionsCacheUsageByRepoForOrg request.
func (client *GitHubV3RESTAPIClient) actionsGetActionsCacheUsageByRepoForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetActionsCacheUsageByRepoForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/cache/usage-by-repository"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetActionsCacheUsageByRepoForOrgHandleResponse handles the ActionsGetActionsCacheUsageByRepoForOrg response.
func (client *GitHubV3RESTAPIClient) actionsGetActionsCacheUsageByRepoForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetActionsCacheUsageByRepoForOrgResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetActionsCacheUsageByRepoForOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsEydhcgOrgsOrgActionsCacheUsageByRepositoryGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsGetActionsCacheUsageByRepoForOrgResponse{}, err
	}
	return result, nil
}

// ActionsGetActionsCacheUsageForOrg - Gets the total GitHub Actions cache usage for an organization. The data fetched using
// this API is refreshed approximately every 5 minutes, so values returned from this endpoint may take at least 5
// minutes to get updated. You must authenticate using an access token with the read:org scope to use this endpoint. GitHub
// Apps must have the organization_admistration:read permission to use this
// endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetActionsCacheUsageForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetActionsCacheUsageForOrg
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetActionsCacheUsageForOrg(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetActionsCacheUsageForOrgOptions) (GitHubV3RESTAPIClientActionsGetActionsCacheUsageForOrgResponse, error) {
	req, err := client.actionsGetActionsCacheUsageForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetActionsCacheUsageForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetActionsCacheUsageForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetActionsCacheUsageForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetActionsCacheUsageForOrgHandleResponse(resp)
}

// actionsGetActionsCacheUsageForOrgCreateRequest creates the ActionsGetActionsCacheUsageForOrg request.
func (client *GitHubV3RESTAPIClient) actionsGetActionsCacheUsageForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetActionsCacheUsageForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/cache/usage"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetActionsCacheUsageForOrgHandleResponse handles the ActionsGetActionsCacheUsageForOrg response.
func (client *GitHubV3RESTAPIClient) actionsGetActionsCacheUsageForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetActionsCacheUsageForOrgResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetActionsCacheUsageForOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsCacheUsageOrgEnterprise); err != nil {
		return GitHubV3RESTAPIClientActionsGetActionsCacheUsageForOrgResponse{}, err
	}
	return result, nil
}

// ActionsGetAllowedActionsOrganization - Gets the selected actions and reusable workflows that are allowed in an organization.
// To use this endpoint, the organization permission policy for allowed_actions must be configured to selected. For
// more information, see "Set GitHub Actions permissions for an organization.""
// You must authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must have the administration
// organization permission to use this API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetAllowedActionsOrganizationOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetAllowedActionsOrganization
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetAllowedActionsOrganization(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetAllowedActionsOrganizationOptions) (GitHubV3RESTAPIClientActionsGetAllowedActionsOrganizationResponse, error) {
	req, err := client.actionsGetAllowedActionsOrganizationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetAllowedActionsOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetAllowedActionsOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetAllowedActionsOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetAllowedActionsOrganizationHandleResponse(resp)
}

// actionsGetAllowedActionsOrganizationCreateRequest creates the ActionsGetAllowedActionsOrganization request.
func (client *GitHubV3RESTAPIClient) actionsGetAllowedActionsOrganizationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetAllowedActionsOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/permissions/selected-actions"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetAllowedActionsOrganizationHandleResponse handles the ActionsGetAllowedActionsOrganization response.
func (client *GitHubV3RESTAPIClient) actionsGetAllowedActionsOrganizationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetAllowedActionsOrganizationResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetAllowedActionsOrganizationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SelectedActions); err != nil {
		return GitHubV3RESTAPIClientActionsGetAllowedActionsOrganizationResponse{}, err
	}
	return result, nil
}

// ActionsGetAllowedActionsRepository - Gets the settings for selected actions and reusable workflows that are allowed in
// a repository. To use this endpoint, the repository policy for allowed_actions must be configured to selected. For more
// information, see "Set GitHub Actions permissions for a repository."
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the administration
// repository permission to use this API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetAllowedActionsRepositoryOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetAllowedActionsRepository
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetAllowedActionsRepository(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetAllowedActionsRepositoryOptions) (GitHubV3RESTAPIClientActionsGetAllowedActionsRepositoryResponse, error) {
	req, err := client.actionsGetAllowedActionsRepositoryCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetAllowedActionsRepositoryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetAllowedActionsRepositoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetAllowedActionsRepositoryResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetAllowedActionsRepositoryHandleResponse(resp)
}

// actionsGetAllowedActionsRepositoryCreateRequest creates the ActionsGetAllowedActionsRepository request.
func (client *GitHubV3RESTAPIClient) actionsGetAllowedActionsRepositoryCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetAllowedActionsRepositoryOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/permissions/selected-actions"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetAllowedActionsRepositoryHandleResponse handles the ActionsGetAllowedActionsRepository response.
func (client *GitHubV3RESTAPIClient) actionsGetAllowedActionsRepositoryHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetAllowedActionsRepositoryResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetAllowedActionsRepositoryResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SelectedActions); err != nil {
		return GitHubV3RESTAPIClientActionsGetAllowedActionsRepositoryResponse{}, err
	}
	return result, nil
}

// ActionsGetArtifact - Gets a specific artifact for a workflow run. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the repo scope. GitHub Apps
// must have the actions:read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetArtifactOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetArtifact
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetArtifact(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetArtifactOptions) (GitHubV3RESTAPIClientActionsGetArtifactResponse, error) {
	req, err := client.actionsGetArtifactCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetArtifactResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetArtifactResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetArtifactResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetArtifactHandleResponse(resp)
}

// actionsGetArtifactCreateRequest creates the ActionsGetArtifact request.
func (client *GitHubV3RESTAPIClient) actionsGetArtifactCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetArtifactOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{artifact_id}", url.PathEscape(strconv.FormatInt(int64(client.artifactID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetArtifactHandleResponse handles the ActionsGetArtifact response.
func (client *GitHubV3RESTAPIClient) actionsGetArtifactHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetArtifactResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetArtifactResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Artifact); err != nil {
		return GitHubV3RESTAPIClientActionsGetArtifactResponse{}, err
	}
	return result, nil
}

// ActionsGetCustomOidcSubClaimForRepo - Gets the customization template for an OpenID Connect (OIDC) subject claim. You must
// authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the
// organization_administration:read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetCustomOidcSubClaimForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetCustomOidcSubClaimForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetCustomOidcSubClaimForRepo(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetCustomOidcSubClaimForRepoOptions) (GitHubV3RESTAPIClientActionsGetCustomOidcSubClaimForRepoResponse, error) {
	req, err := client.actionsGetCustomOidcSubClaimForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetCustomOidcSubClaimForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetCustomOidcSubClaimForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusNotFound) {
		return GitHubV3RESTAPIClientActionsGetCustomOidcSubClaimForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetCustomOidcSubClaimForRepoHandleResponse(resp)
}

// actionsGetCustomOidcSubClaimForRepoCreateRequest creates the ActionsGetCustomOidcSubClaimForRepo request.
func (client *GitHubV3RESTAPIClient) actionsGetCustomOidcSubClaimForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetCustomOidcSubClaimForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/oidc/customization/sub"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// actionsGetCustomOidcSubClaimForRepoHandleResponse handles the ActionsGetCustomOidcSubClaimForRepo response.
func (client *GitHubV3RESTAPIClient) actionsGetCustomOidcSubClaimForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetCustomOidcSubClaimForRepoResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetCustomOidcSubClaimForRepoResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val OidcCustomSubRepo
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsGetCustomOidcSubClaimForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsGetCustomOidcSubClaimForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsGetCustomOidcSubClaimForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsGetCustomOidcSubClaimForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsGetEnvironmentPublicKey - Get the public key for an environment, which you need to encrypt environment secrets.
// You need to encrypt a secret before you can create or update secrets. Anyone with read access to the repository
// can use this endpoint. If the repository is private you must use an access token with the repo scope. GitHub Apps must
// have the secrets repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetEnvironmentPublicKeyOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetEnvironmentPublicKey
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetEnvironmentPublicKey(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetEnvironmentPublicKeyOptions) (GitHubV3RESTAPIClientActionsGetEnvironmentPublicKeyResponse, error) {
	req, err := client.actionsGetEnvironmentPublicKeyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetEnvironmentPublicKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetEnvironmentPublicKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetEnvironmentPublicKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetEnvironmentPublicKeyHandleResponse(resp)
}

// actionsGetEnvironmentPublicKeyCreateRequest creates the ActionsGetEnvironmentPublicKey request.
func (client *GitHubV3RESTAPIClient) actionsGetEnvironmentPublicKeyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetEnvironmentPublicKeyOptions) (*policy.Request, error) {
	urlPath := "/repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetEnvironmentPublicKeyHandleResponse handles the ActionsGetEnvironmentPublicKey response.
func (client *GitHubV3RESTAPIClient) actionsGetEnvironmentPublicKeyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetEnvironmentPublicKeyResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetEnvironmentPublicKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsPublicKey); err != nil {
		return GitHubV3RESTAPIClientActionsGetEnvironmentPublicKeyResponse{}, err
	}
	return result, nil
}

// ActionsGetEnvironmentSecret - Gets a single environment secret without revealing its encrypted value. You must authenticate
// using an access token with the repo scope to use this endpoint. GitHub Apps must have the secrets
// repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetEnvironmentSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetEnvironmentSecret
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetEnvironmentSecret(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetEnvironmentSecretOptions) (GitHubV3RESTAPIClientActionsGetEnvironmentSecretResponse, error) {
	req, err := client.actionsGetEnvironmentSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetEnvironmentSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetEnvironmentSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetEnvironmentSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetEnvironmentSecretHandleResponse(resp)
}

// actionsGetEnvironmentSecretCreateRequest creates the ActionsGetEnvironmentSecret request.
func (client *GitHubV3RESTAPIClient) actionsGetEnvironmentSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetEnvironmentSecretOptions) (*policy.Request, error) {
	urlPath := "/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetEnvironmentSecretHandleResponse handles the ActionsGetEnvironmentSecret response.
func (client *GitHubV3RESTAPIClient) actionsGetEnvironmentSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetEnvironmentSecretResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetEnvironmentSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsSecret); err != nil {
		return GitHubV3RESTAPIClientActionsGetEnvironmentSecretResponse{}, err
	}
	return result, nil
}

// ActionsGetEnvironmentVariable - Gets a specific variable in an environment. You must authenticate using an access token
// with the repo scope to use this endpoint. GitHub Apps must have the environments:read repository permission to
// use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetEnvironmentVariableOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetEnvironmentVariable
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetEnvironmentVariable(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetEnvironmentVariableOptions) (GitHubV3RESTAPIClientActionsGetEnvironmentVariableResponse, error) {
	req, err := client.actionsGetEnvironmentVariableCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetEnvironmentVariableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetEnvironmentVariableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetEnvironmentVariableResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetEnvironmentVariableHandleResponse(resp)
}

// actionsGetEnvironmentVariableCreateRequest creates the ActionsGetEnvironmentVariable request.
func (client *GitHubV3RESTAPIClient) actionsGetEnvironmentVariableCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetEnvironmentVariableOptions) (*policy.Request, error) {
	urlPath := "/repositories/{repository_id}/environments/{environment_name}/variables/{name}"
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	if client.name == "" {
		return nil, errors.New("parameter client.name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(client.name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetEnvironmentVariableHandleResponse handles the ActionsGetEnvironmentVariable response.
func (client *GitHubV3RESTAPIClient) actionsGetEnvironmentVariableHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetEnvironmentVariableResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetEnvironmentVariableResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsVariable); err != nil {
		return GitHubV3RESTAPIClientActionsGetEnvironmentVariableResponse{}, err
	}
	return result, nil
}

// ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization - Gets the default workflow permissions granted to the GITHUBTOKEN
// when running workflows in an organization, as well as whether GitHub Actions can submit approving pull request reviews.
// For more
// information, see "Setting the permissions of the GITHUBTOKEN for your organization
// [https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization]."
// You must authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must have the administration
// organization permission to use this API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationOptions contains the optional
//     parameters for the GitHubV3RESTAPIClient.ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization method.
func (client *GitHubV3RESTAPIClient) ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationOptions) (GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse, error) {
	req, err := client.actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationHandleResponse(resp)
}

// actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationCreateRequest creates the ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization request.
func (client *GitHubV3RESTAPIClient) actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/permissions/workflow"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationHandleResponse handles the ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization response.
func (client *GitHubV3RESTAPIClient) actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsGetDefaultWorkflowPermissions); err != nil {
		return GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse{}, err
	}
	return result, nil
}

// ActionsGetGithubActionsDefaultWorkflowPermissionsRepository - Gets the default workflow permissions granted to the GITHUBTOKEN
// when running workflows in a repository, as well as if GitHub Actions can submit approving pull request reviews. For more
// information,
// see "Setting the permissions of the GITHUBTOKEN for your repository
// [https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository]
// ."
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the repository
// administration permission to use this API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryOptions contains the optional
//     parameters for the GitHubV3RESTAPIClient.ActionsGetGithubActionsDefaultWorkflowPermissionsRepository method.
func (client *GitHubV3RESTAPIClient) ActionsGetGithubActionsDefaultWorkflowPermissionsRepository(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryOptions) (GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse, error) {
	req, err := client.actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryHandleResponse(resp)
}

// actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryCreateRequest creates the ActionsGetGithubActionsDefaultWorkflowPermissionsRepository request.
func (client *GitHubV3RESTAPIClient) actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/permissions/workflow"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryHandleResponse handles the ActionsGetGithubActionsDefaultWorkflowPermissionsRepository response.
func (client *GitHubV3RESTAPIClient) actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsGetDefaultWorkflowPermissions); err != nil {
		return GitHubV3RESTAPIClientActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse{}, err
	}
	return result, nil
}

// ActionsGetGithubActionsPermissionsOrganization - Gets the GitHub Actions permissions policy for repositories and allowed
// actions and reusable workflows in an organization.
// You must authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must have the administration
// organization permission to use this API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsOrganizationOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.ActionsGetGithubActionsPermissionsOrganization method.
func (client *GitHubV3RESTAPIClient) ActionsGetGithubActionsPermissionsOrganization(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsOrganizationOptions) (GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsOrganizationResponse, error) {
	req, err := client.actionsGetGithubActionsPermissionsOrganizationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetGithubActionsPermissionsOrganizationHandleResponse(resp)
}

// actionsGetGithubActionsPermissionsOrganizationCreateRequest creates the ActionsGetGithubActionsPermissionsOrganization request.
func (client *GitHubV3RESTAPIClient) actionsGetGithubActionsPermissionsOrganizationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/permissions"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetGithubActionsPermissionsOrganizationHandleResponse handles the ActionsGetGithubActionsPermissionsOrganization response.
func (client *GitHubV3RESTAPIClient) actionsGetGithubActionsPermissionsOrganizationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsOrganizationResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsOrganizationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsOrganizationPermissions); err != nil {
		return GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsOrganizationResponse{}, err
	}
	return result, nil
}

// ActionsGetGithubActionsPermissionsRepository - Gets the GitHub Actions permissions policy for a repository, including whether
// GitHub Actions is enabled and the actions and reusable workflows allowed to run in the repository.
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the administration
// repository permission to use this API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsRepositoryOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.ActionsGetGithubActionsPermissionsRepository method.
func (client *GitHubV3RESTAPIClient) ActionsGetGithubActionsPermissionsRepository(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsRepositoryOptions) (GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsRepositoryResponse, error) {
	req, err := client.actionsGetGithubActionsPermissionsRepositoryCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsRepositoryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsRepositoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsRepositoryResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetGithubActionsPermissionsRepositoryHandleResponse(resp)
}

// actionsGetGithubActionsPermissionsRepositoryCreateRequest creates the ActionsGetGithubActionsPermissionsRepository request.
func (client *GitHubV3RESTAPIClient) actionsGetGithubActionsPermissionsRepositoryCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsRepositoryOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/permissions"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetGithubActionsPermissionsRepositoryHandleResponse handles the ActionsGetGithubActionsPermissionsRepository response.
func (client *GitHubV3RESTAPIClient) actionsGetGithubActionsPermissionsRepositoryHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsRepositoryResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsRepositoryResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsRepositoryPermissions); err != nil {
		return GitHubV3RESTAPIClientActionsGetGithubActionsPermissionsRepositoryResponse{}, err
	}
	return result, nil
}

// ActionsGetJobForWorkflowRun - Gets a specific job in a workflow run. Anyone with read access to the repository can use
// this endpoint. If the repository is private you must use an access token with the repo scope. GitHub Apps must
// have the actions:read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetJobForWorkflowRunOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetJobForWorkflowRun
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetJobForWorkflowRun(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetJobForWorkflowRunOptions) (GitHubV3RESTAPIClientActionsGetJobForWorkflowRunResponse, error) {
	req, err := client.actionsGetJobForWorkflowRunCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetJobForWorkflowRunResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetJobForWorkflowRunResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetJobForWorkflowRunResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetJobForWorkflowRunHandleResponse(resp)
}

// actionsGetJobForWorkflowRunCreateRequest creates the ActionsGetJobForWorkflowRun request.
func (client *GitHubV3RESTAPIClient) actionsGetJobForWorkflowRunCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetJobForWorkflowRunOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/jobs/{job_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{job_id}", url.PathEscape(strconv.FormatInt(int64(client.jobID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetJobForWorkflowRunHandleResponse handles the ActionsGetJobForWorkflowRun response.
func (client *GitHubV3RESTAPIClient) actionsGetJobForWorkflowRunHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetJobForWorkflowRunResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetJobForWorkflowRunResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Job); err != nil {
		return GitHubV3RESTAPIClientActionsGetJobForWorkflowRunResponse{}, err
	}
	return result, nil
}

// ActionsGetOrgPublicKey - Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you
// can create or update secrets. You must authenticate using an access token with the admin:org scope to
// use this endpoint. GitHub Apps must have the secrets organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetOrgPublicKeyOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetOrgPublicKey
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetOrgPublicKey(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetOrgPublicKeyOptions) (GitHubV3RESTAPIClientActionsGetOrgPublicKeyResponse, error) {
	req, err := client.actionsGetOrgPublicKeyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetOrgPublicKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetOrgPublicKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetOrgPublicKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetOrgPublicKeyHandleResponse(resp)
}

// actionsGetOrgPublicKeyCreateRequest creates the ActionsGetOrgPublicKey request.
func (client *GitHubV3RESTAPIClient) actionsGetOrgPublicKeyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetOrgPublicKeyOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/secrets/public-key"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetOrgPublicKeyHandleResponse handles the ActionsGetOrgPublicKey response.
func (client *GitHubV3RESTAPIClient) actionsGetOrgPublicKeyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetOrgPublicKeyResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetOrgPublicKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsPublicKey); err != nil {
		return GitHubV3RESTAPIClientActionsGetOrgPublicKeyResponse{}, err
	}
	return result, nil
}

// ActionsGetOrgSecret - Gets a single organization secret without revealing its encrypted value. You must authenticate using
// an access token with the admin:org scope to use this endpoint. GitHub Apps must have the secrets
// organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetOrgSecret(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetOrgSecretOptions) (GitHubV3RESTAPIClientActionsGetOrgSecretResponse, error) {
	req, err := client.actionsGetOrgSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetOrgSecretHandleResponse(resp)
}

// actionsGetOrgSecretCreateRequest creates the ActionsGetOrgSecret request.
func (client *GitHubV3RESTAPIClient) actionsGetOrgSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/secrets/{secret_name}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetOrgSecretHandleResponse handles the ActionsGetOrgSecret response.
func (client *GitHubV3RESTAPIClient) actionsGetOrgSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetOrgSecretResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetOrgSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.OrganizationActionsSecret); err != nil {
		return GitHubV3RESTAPIClientActionsGetOrgSecretResponse{}, err
	}
	return result, nil
}

// ActionsGetOrgVariable - Gets a specific variable in an organization. You must authenticate using an access token with the
// admin:org scope to use this endpoint. GitHub Apps must have the organizationactionsvariables:read
// organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetOrgVariableOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetOrgVariable
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetOrgVariable(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetOrgVariableOptions) (GitHubV3RESTAPIClientActionsGetOrgVariableResponse, error) {
	req, err := client.actionsGetOrgVariableCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetOrgVariableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetOrgVariableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetOrgVariableResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetOrgVariableHandleResponse(resp)
}

// actionsGetOrgVariableCreateRequest creates the ActionsGetOrgVariable request.
func (client *GitHubV3RESTAPIClient) actionsGetOrgVariableCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetOrgVariableOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/variables/{name}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.name == "" {
		return nil, errors.New("parameter client.name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(client.name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetOrgVariableHandleResponse handles the ActionsGetOrgVariable response.
func (client *GitHubV3RESTAPIClient) actionsGetOrgVariableHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetOrgVariableResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetOrgVariableResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.OrganizationActionsVariable); err != nil {
		return GitHubV3RESTAPIClientActionsGetOrgVariableResponse{}, err
	}
	return result, nil
}

// ActionsGetPendingDeploymentsForRun - Get all deployment environments for a workflow run that are waiting for protection
// rules to pass.
// Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token
// with the repo scope. GitHub Apps must have the actions:read permission to
// use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetPendingDeploymentsForRunOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetPendingDeploymentsForRun
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetPendingDeploymentsForRun(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetPendingDeploymentsForRunOptions) (GitHubV3RESTAPIClientActionsGetPendingDeploymentsForRunResponse, error) {
	req, err := client.actionsGetPendingDeploymentsForRunCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetPendingDeploymentsForRunResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetPendingDeploymentsForRunResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetPendingDeploymentsForRunResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetPendingDeploymentsForRunHandleResponse(resp)
}

// actionsGetPendingDeploymentsForRunCreateRequest creates the ActionsGetPendingDeploymentsForRun request.
func (client *GitHubV3RESTAPIClient) actionsGetPendingDeploymentsForRunCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetPendingDeploymentsForRunOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetPendingDeploymentsForRunHandleResponse handles the ActionsGetPendingDeploymentsForRun response.
func (client *GitHubV3RESTAPIClient) actionsGetPendingDeploymentsForRunHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetPendingDeploymentsForRunResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetPendingDeploymentsForRunResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PendingDeploymentArray); err != nil {
		return GitHubV3RESTAPIClientActionsGetPendingDeploymentsForRunResponse{}, err
	}
	return result, nil
}

// ActionsGetRepoPublicKey - Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before
// you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the
// repository is private you must use an access token with the repo scope. GitHub Apps must have the secrets repository permission
// to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetRepoPublicKeyOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetRepoPublicKey
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetRepoPublicKey(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetRepoPublicKeyOptions) (GitHubV3RESTAPIClientActionsGetRepoPublicKeyResponse, error) {
	req, err := client.actionsGetRepoPublicKeyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoPublicKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoPublicKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetRepoPublicKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetRepoPublicKeyHandleResponse(resp)
}

// actionsGetRepoPublicKeyCreateRequest creates the ActionsGetRepoPublicKey request.
func (client *GitHubV3RESTAPIClient) actionsGetRepoPublicKeyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetRepoPublicKeyOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/secrets/public-key"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetRepoPublicKeyHandleResponse handles the ActionsGetRepoPublicKey response.
func (client *GitHubV3RESTAPIClient) actionsGetRepoPublicKeyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetRepoPublicKeyResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetRepoPublicKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsPublicKey); err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoPublicKeyResponse{}, err
	}
	return result, nil
}

// ActionsGetRepoRequiredWorkflow - Gets a specific required workflow present in a repository. Anyone with read access to
// the repository can use this endpoint. If the repository is private you must use an access token with the repo
// scope. GitHub Apps must have the actions:read permission to use this endpoint. For more information, see "Required Workflows
// [https://docs.github.com/actions/using-workflows/required-workflows]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetRepoRequiredWorkflow
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetRepoRequiredWorkflow(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowOptions) (GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowResponse, error) {
	req, err := client.actionsGetRepoRequiredWorkflowCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetRepoRequiredWorkflowHandleResponse(resp)
}

// actionsGetRepoRequiredWorkflowCreateRequest creates the ActionsGetRepoRequiredWorkflow request.
func (client *GitHubV3RESTAPIClient) actionsGetRepoRequiredWorkflowCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowOptions) (*policy.Request, error) {
	urlPath := "/repos/{org}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{required_workflow_id_for_repo}", url.PathEscape(strconv.FormatInt(int64(client.requiredWorkflowIDForRepo), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetRepoRequiredWorkflowHandleResponse handles the ActionsGetRepoRequiredWorkflow response.
func (client *GitHubV3RESTAPIClient) actionsGetRepoRequiredWorkflowHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val RepoRequiredWorkflow
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsGetRepoRequiredWorkflowUsage - Gets the number of billable minutes used by a specific required workflow during the
// current billing cycle.
// Billable minutes only apply to required workflows running in private repositories that use GitHub-hosted runners. Usage
// is listed for each GitHub-hosted runner operating system in milliseconds. Any
// job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and
// is not rounded up to the nearest whole minute. For more information, see "
// Managing billing for GitHub Actions [https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions]."
// Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token
// with the repo scope. GitHub Apps must have the actions:read permission to use
// this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowUsageOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetRepoRequiredWorkflowUsage
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetRepoRequiredWorkflowUsage(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowUsageOptions) (GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowUsageResponse, error) {
	req, err := client.actionsGetRepoRequiredWorkflowUsageCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowUsageResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowUsageResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowUsageResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetRepoRequiredWorkflowUsageHandleResponse(resp)
}

// actionsGetRepoRequiredWorkflowUsageCreateRequest creates the ActionsGetRepoRequiredWorkflowUsage request.
func (client *GitHubV3RESTAPIClient) actionsGetRepoRequiredWorkflowUsageCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowUsageOptions) (*policy.Request, error) {
	urlPath := "/repos/{org}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}/timing"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{required_workflow_id_for_repo}", url.PathEscape(strconv.FormatInt(int64(client.requiredWorkflowIDForRepo), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetRepoRequiredWorkflowUsageHandleResponse handles the ActionsGetRepoRequiredWorkflowUsage response.
func (client *GitHubV3RESTAPIClient) actionsGetRepoRequiredWorkflowUsageHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowUsageResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowUsageResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val WorkflowUsage
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowUsageResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowUsageResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsGetRepoRequiredWorkflowUsageResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsGetRepoSecret - Gets a single repository secret without revealing its encrypted value. You must authenticate using
// an access token with the repo scope to use this endpoint. GitHub Apps must have the secrets
// repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetRepoSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetRepoSecret
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetRepoSecret(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetRepoSecretOptions) (GitHubV3RESTAPIClientActionsGetRepoSecretResponse, error) {
	req, err := client.actionsGetRepoSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetRepoSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetRepoSecretHandleResponse(resp)
}

// actionsGetRepoSecretCreateRequest creates the ActionsGetRepoSecret request.
func (client *GitHubV3RESTAPIClient) actionsGetRepoSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetRepoSecretOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/secrets/{secret_name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetRepoSecretHandleResponse handles the ActionsGetRepoSecret response.
func (client *GitHubV3RESTAPIClient) actionsGetRepoSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetRepoSecretResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetRepoSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsSecret); err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoSecretResponse{}, err
	}
	return result, nil
}

// ActionsGetRepoVariable - Gets a specific variable in a repository. You must authenticate using an access token with the
// repo scope to use this endpoint. GitHub Apps must have the actions_variables:read repository permission
// to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetRepoVariableOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetRepoVariable
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetRepoVariable(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetRepoVariableOptions) (GitHubV3RESTAPIClientActionsGetRepoVariableResponse, error) {
	req, err := client.actionsGetRepoVariableCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoVariableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoVariableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetRepoVariableResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetRepoVariableHandleResponse(resp)
}

// actionsGetRepoVariableCreateRequest creates the ActionsGetRepoVariable request.
func (client *GitHubV3RESTAPIClient) actionsGetRepoVariableCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetRepoVariableOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/variables/{name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.name == "" {
		return nil, errors.New("parameter client.name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(client.name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetRepoVariableHandleResponse handles the ActionsGetRepoVariable response.
func (client *GitHubV3RESTAPIClient) actionsGetRepoVariableHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetRepoVariableResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetRepoVariableResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsVariable); err != nil {
		return GitHubV3RESTAPIClientActionsGetRepoVariableResponse{}, err
	}
	return result, nil
}

// ActionsGetRequiredWorkflow - Get a required workflow configured in an organization.
// You must authenticate using an access token with the read:org scope to use this endpoint.
// For more information, see "Required Workflows [https://docs.github.com/actions/using-workflows/required-workflows]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetRequiredWorkflowOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetRequiredWorkflow
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetRequiredWorkflow(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetRequiredWorkflowOptions) (GitHubV3RESTAPIClientActionsGetRequiredWorkflowResponse, error) {
	req, err := client.actionsGetRequiredWorkflowCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetRequiredWorkflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetRequiredWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetRequiredWorkflowResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetRequiredWorkflowHandleResponse(resp)
}

// actionsGetRequiredWorkflowCreateRequest creates the ActionsGetRequiredWorkflow request.
func (client *GitHubV3RESTAPIClient) actionsGetRequiredWorkflowCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetRequiredWorkflowOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/required_workflows/{required_workflow_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{required_workflow_id}", url.PathEscape(strconv.FormatInt(int64(client.requiredWorkflowID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetRequiredWorkflowHandleResponse handles the ActionsGetRequiredWorkflow response.
func (client *GitHubV3RESTAPIClient) actionsGetRequiredWorkflowHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetRequiredWorkflowResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetRequiredWorkflowResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RequiredWorkflow); err != nil {
		return GitHubV3RESTAPIClientActionsGetRequiredWorkflowResponse{}, err
	}
	return result, nil
}

// ActionsGetReviewsForRun - Anyone with read access to the repository can use this endpoint. If the repository is private,
// you must use an access token with the repo scope. GitHub Apps must have the actions:read permission to
// use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetReviewsForRunOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetReviewsForRun
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetReviewsForRun(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetReviewsForRunOptions) (GitHubV3RESTAPIClientActionsGetReviewsForRunResponse, error) {
	req, err := client.actionsGetReviewsForRunCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetReviewsForRunResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetReviewsForRunResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetReviewsForRunResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetReviewsForRunHandleResponse(resp)
}

// actionsGetReviewsForRunCreateRequest creates the ActionsGetReviewsForRun request.
func (client *GitHubV3RESTAPIClient) actionsGetReviewsForRunCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetReviewsForRunOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetReviewsForRunHandleResponse handles the ActionsGetReviewsForRun response.
func (client *GitHubV3RESTAPIClient) actionsGetReviewsForRunHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetReviewsForRunResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetReviewsForRunResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.EnvironmentApprovalsArray); err != nil {
		return GitHubV3RESTAPIClientActionsGetReviewsForRunResponse{}, err
	}
	return result, nil
}

// ActionsGetSelfHostedRunnerForOrg - Gets a specific self-hosted runner configured in an organization.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetSelfHostedRunnerForOrg
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetSelfHostedRunnerForOrg(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForOrgOptions) (GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForOrgResponse, error) {
	req, err := client.actionsGetSelfHostedRunnerForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetSelfHostedRunnerForOrgHandleResponse(resp)
}

// actionsGetSelfHostedRunnerForOrgCreateRequest creates the ActionsGetSelfHostedRunnerForOrg request.
func (client *GitHubV3RESTAPIClient) actionsGetSelfHostedRunnerForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/runners/{runner_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{runner_id}", url.PathEscape(strconv.FormatInt(int64(client.runnerID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetSelfHostedRunnerForOrgHandleResponse handles the ActionsGetSelfHostedRunnerForOrg response.
func (client *GitHubV3RESTAPIClient) actionsGetSelfHostedRunnerForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForOrgResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Runner); err != nil {
		return GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForOrgResponse{}, err
	}
	return result, nil
}

// ActionsGetSelfHostedRunnerForRepo - Gets a specific self-hosted runner configured in a repository.
// You must authenticate using an access token with the repo scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetSelfHostedRunnerForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetSelfHostedRunnerForRepo(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForRepoOptions) (GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForRepoResponse, error) {
	req, err := client.actionsGetSelfHostedRunnerForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetSelfHostedRunnerForRepoHandleResponse(resp)
}

// actionsGetSelfHostedRunnerForRepoCreateRequest creates the ActionsGetSelfHostedRunnerForRepo request.
func (client *GitHubV3RESTAPIClient) actionsGetSelfHostedRunnerForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runners/{runner_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{runner_id}", url.PathEscape(strconv.FormatInt(int64(client.runnerID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetSelfHostedRunnerForRepoHandleResponse handles the ActionsGetSelfHostedRunnerForRepo response.
func (client *GitHubV3RESTAPIClient) actionsGetSelfHostedRunnerForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForRepoResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForRepoResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Runner); err != nil {
		return GitHubV3RESTAPIClientActionsGetSelfHostedRunnerForRepoResponse{}, err
	}
	return result, nil
}

// ActionsGetWorkflow - Gets a specific workflow. You can replace workflow_id with the workflow file name. For example, you
// could use main.yaml. Anyone with read access to the repository can use this endpoint. If the
// repository is private you must use an access token with the repo scope. GitHub Apps must have the actions:read permission
// to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetWorkflowOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetWorkflow
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetWorkflow(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetWorkflowOptions) (GitHubV3RESTAPIClientActionsGetWorkflowResponse, error) {
	req, err := client.actionsGetWorkflowCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetWorkflowResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetWorkflowHandleResponse(resp)
}

// actionsGetWorkflowCreateRequest creates the ActionsGetWorkflow request.
func (client *GitHubV3RESTAPIClient) actionsGetWorkflowCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetWorkflowOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/workflows/{workflow_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{workflow_id}", url.PathEscape(client.workflowID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetWorkflowHandleResponse handles the ActionsGetWorkflow response.
func (client *GitHubV3RESTAPIClient) actionsGetWorkflowHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetWorkflowResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetWorkflowResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Workflow); err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowResponse{}, err
	}
	return result, nil
}

// ActionsGetWorkflowAccessToRepository - Gets the level of access that workflows outside of the repository have to actions
// and reusable workflows in the repository. This endpoint only applies to private repositories. For more information,
// see "Allowing access to components in a private repository
// [https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository]
// ."
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the repository
// administration permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetWorkflowAccessToRepositoryOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetWorkflowAccessToRepository
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetWorkflowAccessToRepository(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetWorkflowAccessToRepositoryOptions) (GitHubV3RESTAPIClientActionsGetWorkflowAccessToRepositoryResponse, error) {
	req, err := client.actionsGetWorkflowAccessToRepositoryCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowAccessToRepositoryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowAccessToRepositoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetWorkflowAccessToRepositoryResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetWorkflowAccessToRepositoryHandleResponse(resp)
}

// actionsGetWorkflowAccessToRepositoryCreateRequest creates the ActionsGetWorkflowAccessToRepository request.
func (client *GitHubV3RESTAPIClient) actionsGetWorkflowAccessToRepositoryCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetWorkflowAccessToRepositoryOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/permissions/access"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetWorkflowAccessToRepositoryHandleResponse handles the ActionsGetWorkflowAccessToRepository response.
func (client *GitHubV3RESTAPIClient) actionsGetWorkflowAccessToRepositoryHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetWorkflowAccessToRepositoryResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetWorkflowAccessToRepositoryResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsWorkflowAccessToRepository); err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowAccessToRepositoryResponse{}, err
	}
	return result, nil
}

// ActionsGetWorkflowRun - Gets a specific workflow run. Anyone with read access to the repository can use this endpoint.
// If the repository is private you must use an access token with the repo scope. GitHub Apps must have the
// actions:read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetWorkflowRunOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetWorkflowRun
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetWorkflowRun(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetWorkflowRunOptions) (GitHubV3RESTAPIClientActionsGetWorkflowRunResponse, error) {
	req, err := client.actionsGetWorkflowRunCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowRunResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowRunResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetWorkflowRunResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetWorkflowRunHandleResponse(resp)
}

// actionsGetWorkflowRunCreateRequest creates the ActionsGetWorkflowRun request.
func (client *GitHubV3RESTAPIClient) actionsGetWorkflowRunCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetWorkflowRunOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.excludePullRequests != nil {
		reqQP.Set("exclude_pull_requests", strconv.FormatBool(*client.excludePullRequests))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetWorkflowRunHandleResponse handles the ActionsGetWorkflowRun response.
func (client *GitHubV3RESTAPIClient) actionsGetWorkflowRunHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetWorkflowRunResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetWorkflowRunResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkflowRun); err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowRunResponse{}, err
	}
	return result, nil
}

// ActionsGetWorkflowRunAttempt - Gets a specific workflow run attempt. Anyone with read access to the repository can use
// this endpoint. If the repository is private you must use an access token with the repo scope. GitHub Apps must
// have the actions:read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetWorkflowRunAttemptOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetWorkflowRunAttempt
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetWorkflowRunAttempt(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetWorkflowRunAttemptOptions) (GitHubV3RESTAPIClientActionsGetWorkflowRunAttemptResponse, error) {
	req, err := client.actionsGetWorkflowRunAttemptCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowRunAttemptResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowRunAttemptResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetWorkflowRunAttemptResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetWorkflowRunAttemptHandleResponse(resp)
}

// actionsGetWorkflowRunAttemptCreateRequest creates the ActionsGetWorkflowRunAttempt request.
func (client *GitHubV3RESTAPIClient) actionsGetWorkflowRunAttemptCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetWorkflowRunAttemptOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{attempt_number}", url.PathEscape(strconv.FormatInt(int64(client.attemptNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.excludePullRequests != nil {
		reqQP.Set("exclude_pull_requests", strconv.FormatBool(*client.excludePullRequests))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetWorkflowRunAttemptHandleResponse handles the ActionsGetWorkflowRunAttempt response.
func (client *GitHubV3RESTAPIClient) actionsGetWorkflowRunAttemptHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetWorkflowRunAttemptResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetWorkflowRunAttemptResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkflowRun); err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowRunAttemptResponse{}, err
	}
	return result, nil
}

// ActionsGetWorkflowRunUsage - Gets the number of billable minutes and total run time for a specific workflow run. Billable
// minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for
// each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does
// not include the multiplier for macOS and Windows runners and is not rounded
// up to the nearest whole minute. For more information, see "Managing billing for GitHub Actions
// [https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions]".
// Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token
// with the repo scope. GitHub Apps must have the actions:read permission to use
// this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetWorkflowRunUsageOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetWorkflowRunUsage
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetWorkflowRunUsage(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetWorkflowRunUsageOptions) (GitHubV3RESTAPIClientActionsGetWorkflowRunUsageResponse, error) {
	req, err := client.actionsGetWorkflowRunUsageCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowRunUsageResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowRunUsageResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetWorkflowRunUsageResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetWorkflowRunUsageHandleResponse(resp)
}

// actionsGetWorkflowRunUsageCreateRequest creates the ActionsGetWorkflowRunUsage request.
func (client *GitHubV3RESTAPIClient) actionsGetWorkflowRunUsageCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetWorkflowRunUsageOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}/timing"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetWorkflowRunUsageHandleResponse handles the ActionsGetWorkflowRunUsage response.
func (client *GitHubV3RESTAPIClient) actionsGetWorkflowRunUsageHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetWorkflowRunUsageResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetWorkflowRunUsageResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkflowRunUsage); err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowRunUsageResponse{}, err
	}
	return result, nil
}

// ActionsGetWorkflowUsage - Gets the number of billable minutes used by a specific workflow during the current billing cycle.
// Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage
// is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage.
// The usage does not include the multiplier for macOS and Windows runners and is
// not rounded up to the nearest whole minute. For more information, see "Managing billing for GitHub Actions
// [https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions]".
// You can replace workflow_id with the workflow file name. For example, you could use main.yaml. Anyone with read access
// to the repository can use this endpoint. If the repository is private you must
// use an access token with the repo scope. GitHub Apps must have the actions:read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsGetWorkflowUsageOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsGetWorkflowUsage
//     method.
func (client *GitHubV3RESTAPIClient) ActionsGetWorkflowUsage(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetWorkflowUsageOptions) (GitHubV3RESTAPIClientActionsGetWorkflowUsageResponse, error) {
	req, err := client.actionsGetWorkflowUsageCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowUsageResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowUsageResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsGetWorkflowUsageResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsGetWorkflowUsageHandleResponse(resp)
}

// actionsGetWorkflowUsageCreateRequest creates the ActionsGetWorkflowUsage request.
func (client *GitHubV3RESTAPIClient) actionsGetWorkflowUsageCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsGetWorkflowUsageOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{workflow_id}", url.PathEscape(client.workflowID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsGetWorkflowUsageHandleResponse handles the ActionsGetWorkflowUsage response.
func (client *GitHubV3RESTAPIClient) actionsGetWorkflowUsageHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsGetWorkflowUsageResponse, error) {
	result := GitHubV3RESTAPIClientActionsGetWorkflowUsageResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WorkflowUsage); err != nil {
		return GitHubV3RESTAPIClientActionsGetWorkflowUsageResponse{}, err
	}
	return result, nil
}

// ActionsListArtifactsForRepo - Lists all artifacts for a repository. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the repo scope. GitHub Apps must
// have the actions:read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListArtifactsForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListArtifactsForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListArtifactsForRepo(ctx context.Context, options *GitHubV3RESTAPIClientActionsListArtifactsForRepoOptions) (GitHubV3RESTAPIClientActionsListArtifactsForRepoResponse, error) {
	req, err := client.actionsListArtifactsForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListArtifactsForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListArtifactsForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListArtifactsForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListArtifactsForRepoHandleResponse(resp)
}

// actionsListArtifactsForRepoCreateRequest creates the ActionsListArtifactsForRepo request.
func (client *GitHubV3RESTAPIClient) actionsListArtifactsForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListArtifactsForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/artifacts"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if options != nil && options.Name != nil {
		reqQP.Set("name", *options.Name)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListArtifactsForRepoHandleResponse handles the ActionsListArtifactsForRepo response.
func (client *GitHubV3RESTAPIClient) actionsListArtifactsForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListArtifactsForRepoResponse, error) {
	result := GitHubV3RESTAPIClientActionsListArtifactsForRepoResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1084D7PReposOwnerRepoActionsArtifactsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListArtifactsForRepoResponse{}, err
	}
	return result, nil
}

// ActionsListEnvironmentSecrets - Lists all secrets available in an environment without revealing their encrypted values.
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the
// secrets repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListEnvironmentSecretsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListEnvironmentSecrets
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListEnvironmentSecrets(ctx context.Context, options *GitHubV3RESTAPIClientActionsListEnvironmentSecretsOptions) (GitHubV3RESTAPIClientActionsListEnvironmentSecretsResponse, error) {
	req, err := client.actionsListEnvironmentSecretsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListEnvironmentSecretsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListEnvironmentSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListEnvironmentSecretsResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListEnvironmentSecretsHandleResponse(resp)
}

// actionsListEnvironmentSecretsCreateRequest creates the ActionsListEnvironmentSecrets request.
func (client *GitHubV3RESTAPIClient) actionsListEnvironmentSecretsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListEnvironmentSecretsOptions) (*policy.Request, error) {
	urlPath := "/repositories/{repository_id}/environments/{environment_name}/secrets"
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListEnvironmentSecretsHandleResponse handles the ActionsListEnvironmentSecrets response.
func (client *GitHubV3RESTAPIClient) actionsListEnvironmentSecretsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListEnvironmentSecretsResponse, error) {
	result := GitHubV3RESTAPIClientActionsListEnvironmentSecretsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths17Vtn24RepositoriesRepositoryIDEnvironmentsEnvironmentNameSecretsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListEnvironmentSecretsResponse{}, err
	}
	return result, nil
}

// ActionsListEnvironmentVariables - Lists all environment variables. You must authenticate using an access token with the
// repo scope to use this endpoint. GitHub Apps must have the environments:read repository permission to use this
// endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListEnvironmentVariablesOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListEnvironmentVariables
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListEnvironmentVariables(ctx context.Context, options *GitHubV3RESTAPIClientActionsListEnvironmentVariablesOptions) (GitHubV3RESTAPIClientActionsListEnvironmentVariablesResponse, error) {
	req, err := client.actionsListEnvironmentVariablesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListEnvironmentVariablesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListEnvironmentVariablesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListEnvironmentVariablesResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListEnvironmentVariablesHandleResponse(resp)
}

// actionsListEnvironmentVariablesCreateRequest creates the ActionsListEnvironmentVariables request.
func (client *GitHubV3RESTAPIClient) actionsListEnvironmentVariablesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListEnvironmentVariablesOptions) (*policy.Request, error) {
	urlPath := "/repositories/{repository_id}/environments/{environment_name}/variables"
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListEnvironmentVariablesHandleResponse handles the ActionsListEnvironmentVariables response.
func (client *GitHubV3RESTAPIClient) actionsListEnvironmentVariablesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListEnvironmentVariablesResponse, error) {
	result := GitHubV3RESTAPIClientActionsListEnvironmentVariablesResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsSay17YRepositoriesRepositoryIDEnvironmentsEnvironmentNameVariablesGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListEnvironmentVariablesResponse{}, err
	}
	return result, nil
}

// ActionsListJobsForWorkflowRun - Lists jobs for a workflow run. Anyone with read access to the repository can use this endpoint.
// If the repository is private you must use an access token with the repo scope. GitHub Apps must have the
// actions:read permission to use this endpoint. You can use parameters to narrow the list of results. For more information
// about using parameters, see Parameters
// [https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListJobsForWorkflowRunOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListJobsForWorkflowRun
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListJobsForWorkflowRun(ctx context.Context, options *GitHubV3RESTAPIClientActionsListJobsForWorkflowRunOptions) (GitHubV3RESTAPIClientActionsListJobsForWorkflowRunResponse, error) {
	req, err := client.actionsListJobsForWorkflowRunCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListJobsForWorkflowRunResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListJobsForWorkflowRunResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListJobsForWorkflowRunResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListJobsForWorkflowRunHandleResponse(resp)
}

// actionsListJobsForWorkflowRunCreateRequest creates the ActionsListJobsForWorkflowRun request.
func (client *GitHubV3RESTAPIClient) actionsListJobsForWorkflowRunCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListJobsForWorkflowRunOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", string(*options.Filter))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListJobsForWorkflowRunHandleResponse handles the ActionsListJobsForWorkflowRun response.
func (client *GitHubV3RESTAPIClient) actionsListJobsForWorkflowRunHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListJobsForWorkflowRunResponse, error) {
	result := GitHubV3RESTAPIClientActionsListJobsForWorkflowRunResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsE9Csm0ReposOwnerRepoActionsRunsRunIDJobsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListJobsForWorkflowRunResponse{}, err
	}
	return result, nil
}

// ActionsListJobsForWorkflowRunAttempt - Lists jobs for a specific workflow run attempt. Anyone with read access to the repository
// can use this endpoint. If the repository is private you must use an access token with the repo scope. GitHub
// Apps must have the actions:read permission to use this endpoint. You can use parameters to narrow the list of results.
// For more information about using parameters, see Parameters
// [https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListJobsForWorkflowRunAttemptOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListJobsForWorkflowRunAttempt
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListJobsForWorkflowRunAttempt(ctx context.Context, options *GitHubV3RESTAPIClientActionsListJobsForWorkflowRunAttemptOptions) (GitHubV3RESTAPIClientActionsListJobsForWorkflowRunAttemptResponse, error) {
	req, err := client.actionsListJobsForWorkflowRunAttemptCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListJobsForWorkflowRunAttemptResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListJobsForWorkflowRunAttemptResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientActionsListJobsForWorkflowRunAttemptResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListJobsForWorkflowRunAttemptHandleResponse(resp)
}

// actionsListJobsForWorkflowRunAttemptCreateRequest creates the ActionsListJobsForWorkflowRunAttempt request.
func (client *GitHubV3RESTAPIClient) actionsListJobsForWorkflowRunAttemptCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListJobsForWorkflowRunAttemptOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{attempt_number}", url.PathEscape(strconv.FormatInt(int64(client.attemptNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListJobsForWorkflowRunAttemptHandleResponse handles the ActionsListJobsForWorkflowRunAttempt response.
func (client *GitHubV3RESTAPIClient) actionsListJobsForWorkflowRunAttemptHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListJobsForWorkflowRunAttemptResponse, error) {
	result := GitHubV3RESTAPIClientActionsListJobsForWorkflowRunAttemptResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PathsHtbmf3ReposOwnerRepoActionsRunsRunIDAttemptsAttemptNumberJobsGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsListJobsForWorkflowRunAttemptResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsListJobsForWorkflowRunAttemptResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsListJobsForWorkflowRunAttemptResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsListLabelsForSelfHostedRunnerForOrg - Lists all labels for a self-hosted runner configured in an organization.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForOrgOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ActionsListLabelsForSelfHostedRunnerForOrg method.
func (client *GitHubV3RESTAPIClient) ActionsListLabelsForSelfHostedRunnerForOrg(ctx context.Context, options *GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForOrgOptions) (GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForOrgResponse, error) {
	req, err := client.actionsListLabelsForSelfHostedRunnerForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListLabelsForSelfHostedRunnerForOrgHandleResponse(resp)
}

// actionsListLabelsForSelfHostedRunnerForOrgCreateRequest creates the ActionsListLabelsForSelfHostedRunnerForOrg request.
func (client *GitHubV3RESTAPIClient) actionsListLabelsForSelfHostedRunnerForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/runners/{runner_id}/labels"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{runner_id}", url.PathEscape(strconv.FormatInt(int64(client.runnerID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListLabelsForSelfHostedRunnerForOrgHandleResponse handles the ActionsListLabelsForSelfHostedRunnerForOrg response.
func (client *GitHubV3RESTAPIClient) actionsListLabelsForSelfHostedRunnerForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForOrgResponse, error) {
	result := GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForOrgResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ComponentsDhs7QhResponsesActionsRunnerLabelsContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsListLabelsForSelfHostedRunnerForRepo - Lists all labels for a self-hosted runner configured in a repository.
// You must authenticate using an access token with the repo scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForRepoOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.ActionsListLabelsForSelfHostedRunnerForRepo method.
func (client *GitHubV3RESTAPIClient) ActionsListLabelsForSelfHostedRunnerForRepo(ctx context.Context, options *GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForRepoOptions) (GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForRepoResponse, error) {
	req, err := client.actionsListLabelsForSelfHostedRunnerForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListLabelsForSelfHostedRunnerForRepoHandleResponse(resp)
}

// actionsListLabelsForSelfHostedRunnerForRepoCreateRequest creates the ActionsListLabelsForSelfHostedRunnerForRepo request.
func (client *GitHubV3RESTAPIClient) actionsListLabelsForSelfHostedRunnerForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{runner_id}", url.PathEscape(strconv.FormatInt(int64(client.runnerID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListLabelsForSelfHostedRunnerForRepoHandleResponse handles the ActionsListLabelsForSelfHostedRunnerForRepo response.
func (client *GitHubV3RESTAPIClient) actionsListLabelsForSelfHostedRunnerForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForRepoResponse, error) {
	result := GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForRepoResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ComponentsDhs7QhResponsesActionsRunnerLabelsContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsListLabelsForSelfHostedRunnerForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsListOrgSecrets - Lists all secrets available in an organization without revealing their encrypted values. You must
// authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must
// have the secrets organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListOrgSecretsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListOrgSecrets
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListOrgSecrets(ctx context.Context, options *GitHubV3RESTAPIClientActionsListOrgSecretsOptions) (GitHubV3RESTAPIClientActionsListOrgSecretsResponse, error) {
	req, err := client.actionsListOrgSecretsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListOrgSecretsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListOrgSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListOrgSecretsResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListOrgSecretsHandleResponse(resp)
}

// actionsListOrgSecretsCreateRequest creates the ActionsListOrgSecrets request.
func (client *GitHubV3RESTAPIClient) actionsListOrgSecretsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListOrgSecretsOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/secrets"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListOrgSecretsHandleResponse handles the ActionsListOrgSecrets response.
func (client *GitHubV3RESTAPIClient) actionsListOrgSecretsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListOrgSecretsResponse, error) {
	result := GitHubV3RESTAPIClientActionsListOrgSecretsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsWzzjweOrgsOrgActionsSecretsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListOrgSecretsResponse{}, err
	}
	return result, nil
}

// ActionsListOrgVariables - Lists all organization variables. You must authenticate using an access token with the admin:org
// scope to use this endpoint. GitHub Apps must have the organizationactionsvariables:read organization
// permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListOrgVariablesOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListOrgVariables
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListOrgVariables(ctx context.Context, options *GitHubV3RESTAPIClientActionsListOrgVariablesOptions) (GitHubV3RESTAPIClientActionsListOrgVariablesResponse, error) {
	req, err := client.actionsListOrgVariablesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListOrgVariablesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListOrgVariablesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListOrgVariablesResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListOrgVariablesHandleResponse(resp)
}

// actionsListOrgVariablesCreateRequest creates the ActionsListOrgVariables request.
func (client *GitHubV3RESTAPIClient) actionsListOrgVariablesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListOrgVariablesOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/variables"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListOrgVariablesHandleResponse handles the ActionsListOrgVariables response.
func (client *GitHubV3RESTAPIClient) actionsListOrgVariablesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListOrgVariablesResponse, error) {
	result := GitHubV3RESTAPIClientActionsListOrgVariablesResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths13O2M51OrgsOrgActionsVariablesGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListOrgVariablesResponse{}, err
	}
	return result, nil
}

// ActionsListRepoRequiredWorkflows - Lists the required workflows in a repository. Anyone with read access to the repository
// can use this endpoint. If the repository is private you must use an access token with the repo scope. GitHub
// Apps must have the actions:read permission to use this endpoint. For more information, see "Required Workflows [https://docs.github.com/actions/using-workflows/required-workflows]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListRepoRequiredWorkflowsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListRepoRequiredWorkflows
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListRepoRequiredWorkflows(ctx context.Context, options *GitHubV3RESTAPIClientActionsListRepoRequiredWorkflowsOptions) (GitHubV3RESTAPIClientActionsListRepoRequiredWorkflowsResponse, error) {
	req, err := client.actionsListRepoRequiredWorkflowsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListRepoRequiredWorkflowsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListRepoRequiredWorkflowsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientActionsListRepoRequiredWorkflowsResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListRepoRequiredWorkflowsHandleResponse(resp)
}

// actionsListRepoRequiredWorkflowsCreateRequest creates the ActionsListRepoRequiredWorkflows request.
func (client *GitHubV3RESTAPIClient) actionsListRepoRequiredWorkflowsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListRepoRequiredWorkflowsOptions) (*policy.Request, error) {
	urlPath := "/repos/{org}/{repo}/actions/required_workflows"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListRepoRequiredWorkflowsHandleResponse handles the ActionsListRepoRequiredWorkflows response.
func (client *GitHubV3RESTAPIClient) actionsListRepoRequiredWorkflowsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListRepoRequiredWorkflowsResponse, error) {
	result := GitHubV3RESTAPIClientActionsListRepoRequiredWorkflowsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PathsCewf7CReposOrgRepoActionsRequiredWorkflowsGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsListRepoRequiredWorkflowsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsListRepoRequiredWorkflowsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsListRepoRequiredWorkflowsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsListRepoSecrets - Lists all secrets available in a repository without revealing their encrypted values. You must
// authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the
// secrets repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListRepoSecretsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListRepoSecrets
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListRepoSecrets(ctx context.Context, options *GitHubV3RESTAPIClientActionsListRepoSecretsOptions) (GitHubV3RESTAPIClientActionsListRepoSecretsResponse, error) {
	req, err := client.actionsListRepoSecretsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListRepoSecretsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListRepoSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListRepoSecretsResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListRepoSecretsHandleResponse(resp)
}

// actionsListRepoSecretsCreateRequest creates the ActionsListRepoSecrets request.
func (client *GitHubV3RESTAPIClient) actionsListRepoSecretsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListRepoSecretsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/secrets"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListRepoSecretsHandleResponse handles the ActionsListRepoSecrets response.
func (client *GitHubV3RESTAPIClient) actionsListRepoSecretsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListRepoSecretsResponse, error) {
	result := GitHubV3RESTAPIClientActionsListRepoSecretsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1Mynu8UReposOwnerRepoActionsSecretsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListRepoSecretsResponse{}, err
	}
	return result, nil
}

// ActionsListRepoVariables - Lists all repository variables. You must authenticate using an access token with the repo scope
// to use this endpoint. GitHub Apps must have the actions_variables:read repository permission to use this
// endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListRepoVariablesOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListRepoVariables
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListRepoVariables(ctx context.Context, options *GitHubV3RESTAPIClientActionsListRepoVariablesOptions) (GitHubV3RESTAPIClientActionsListRepoVariablesResponse, error) {
	req, err := client.actionsListRepoVariablesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListRepoVariablesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListRepoVariablesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListRepoVariablesResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListRepoVariablesHandleResponse(resp)
}

// actionsListRepoVariablesCreateRequest creates the ActionsListRepoVariables request.
func (client *GitHubV3RESTAPIClient) actionsListRepoVariablesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListRepoVariablesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/variables"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListRepoVariablesHandleResponse handles the ActionsListRepoVariables response.
func (client *GitHubV3RESTAPIClient) actionsListRepoVariablesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListRepoVariablesResponse, error) {
	result := GitHubV3RESTAPIClientActionsListRepoVariablesResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1Gt83F3ReposOwnerRepoActionsVariablesGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListRepoVariablesResponse{}, err
	}
	return result, nil
}

// ActionsListRepoWorkflows - Lists the workflows in a repository. Anyone with read access to the repository can use this
// endpoint. If the repository is private you must use an access token with the repo scope. GitHub Apps must
// have the actions:read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListRepoWorkflowsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListRepoWorkflows
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListRepoWorkflows(ctx context.Context, options *GitHubV3RESTAPIClientActionsListRepoWorkflowsOptions) (GitHubV3RESTAPIClientActionsListRepoWorkflowsResponse, error) {
	req, err := client.actionsListRepoWorkflowsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListRepoWorkflowsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListRepoWorkflowsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListRepoWorkflowsResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListRepoWorkflowsHandleResponse(resp)
}

// actionsListRepoWorkflowsCreateRequest creates the ActionsListRepoWorkflows request.
func (client *GitHubV3RESTAPIClient) actionsListRepoWorkflowsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListRepoWorkflowsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/workflows"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListRepoWorkflowsHandleResponse handles the ActionsListRepoWorkflows response.
func (client *GitHubV3RESTAPIClient) actionsListRepoWorkflowsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListRepoWorkflowsResponse, error) {
	result := GitHubV3RESTAPIClientActionsListRepoWorkflowsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsOi3HvzReposOwnerRepoActionsWorkflowsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListRepoWorkflowsResponse{}, err
	}
	return result, nil
}

// ActionsListRequiredWorkflowRuns - List all workflow runs for a required workflow. You can use parameters to narrow the
// list of results. For more information about using parameters, see Parameters
// [https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters].
// Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token
// with the repo scope. For more information, see "Required Workflows
// [https://docs.github.com/actions/using-workflows/required-workflows]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListRequiredWorkflowRunsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListRequiredWorkflowRuns
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListRequiredWorkflowRuns(ctx context.Context, options *GitHubV3RESTAPIClientActionsListRequiredWorkflowRunsOptions) (GitHubV3RESTAPIClientActionsListRequiredWorkflowRunsResponse, error) {
	req, err := client.actionsListRequiredWorkflowRunsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListRequiredWorkflowRunsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListRequiredWorkflowRunsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListRequiredWorkflowRunsResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListRequiredWorkflowRunsHandleResponse(resp)
}

// actionsListRequiredWorkflowRunsCreateRequest creates the ActionsListRequiredWorkflowRuns request.
func (client *GitHubV3RESTAPIClient) actionsListRequiredWorkflowRunsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListRequiredWorkflowRunsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}/runs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{required_workflow_id_for_repo}", url.PathEscape(strconv.FormatInt(int64(client.requiredWorkflowIDForRepo), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.actor != nil {
		reqQP.Set("actor", *client.actor)
	}
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	if client.event != nil {
		reqQP.Set("event", *client.event)
	}
	if client.status != nil {
		reqQP.Set("status", string(*client.status))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.created != nil {
		reqQP.Set("created", client.created.Format(time.RFC3339Nano))
	}
	if client.excludePullRequests != nil {
		reqQP.Set("exclude_pull_requests", strconv.FormatBool(*client.excludePullRequests))
	}
	if client.checkSuiteID != nil {
		reqQP.Set("check_suite_id", strconv.FormatInt(int64(*client.checkSuiteID), 10))
	}
	if client.headSHA != nil {
		reqQP.Set("head_sha", *client.headSHA)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListRequiredWorkflowRunsHandleResponse handles the ActionsListRequiredWorkflowRuns response.
func (client *GitHubV3RESTAPIClient) actionsListRequiredWorkflowRunsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListRequiredWorkflowRunsResponse, error) {
	result := GitHubV3RESTAPIClientActionsListRequiredWorkflowRunsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsLti430ReposOwnerRepoActionsRequiredWorkflowsRequiredWorkflowIDForRepoRunsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListRequiredWorkflowRunsResponse{}, err
	}
	return result, nil
}

// ActionsListRequiredWorkflows - List all required workflows in an organization.
// You must authenticate using an access token with the read:org scope to use this endpoint.
// For more information, see "Required Workflows [https://docs.github.com/actions/using-workflows/required-workflows]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListRequiredWorkflowsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListRequiredWorkflows
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListRequiredWorkflows(ctx context.Context, options *GitHubV3RESTAPIClientActionsListRequiredWorkflowsOptions) (GitHubV3RESTAPIClientActionsListRequiredWorkflowsResponse, error) {
	req, err := client.actionsListRequiredWorkflowsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListRequiredWorkflowsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListRequiredWorkflowsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListRequiredWorkflowsResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListRequiredWorkflowsHandleResponse(resp)
}

// actionsListRequiredWorkflowsCreateRequest creates the ActionsListRequiredWorkflows request.
func (client *GitHubV3RESTAPIClient) actionsListRequiredWorkflowsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListRequiredWorkflowsOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/required_workflows"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListRequiredWorkflowsHandleResponse handles the ActionsListRequiredWorkflows response.
func (client *GitHubV3RESTAPIClient) actionsListRequiredWorkflowsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListRequiredWorkflowsResponse, error) {
	result := GitHubV3RESTAPIClientActionsListRequiredWorkflowsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1287N5JOrgsOrgActionsRequiredWorkflowsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListRequiredWorkflowsResponse{}, err
	}
	return result, nil
}

// ActionsListRunnerApplicationsForOrg - Lists binaries for the runner application that you can download and run.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListRunnerApplicationsForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListRunnerApplicationsForOrg
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListRunnerApplicationsForOrg(ctx context.Context, options *GitHubV3RESTAPIClientActionsListRunnerApplicationsForOrgOptions) (GitHubV3RESTAPIClientActionsListRunnerApplicationsForOrgResponse, error) {
	req, err := client.actionsListRunnerApplicationsForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListRunnerApplicationsForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListRunnerApplicationsForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListRunnerApplicationsForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListRunnerApplicationsForOrgHandleResponse(resp)
}

// actionsListRunnerApplicationsForOrgCreateRequest creates the ActionsListRunnerApplicationsForOrg request.
func (client *GitHubV3RESTAPIClient) actionsListRunnerApplicationsForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListRunnerApplicationsForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/runners/downloads"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListRunnerApplicationsForOrgHandleResponse handles the ActionsListRunnerApplicationsForOrg response.
func (client *GitHubV3RESTAPIClient) actionsListRunnerApplicationsForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListRunnerApplicationsForOrgResponse, error) {
	result := GitHubV3RESTAPIClientActionsListRunnerApplicationsForOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RunnerApplicationArray); err != nil {
		return GitHubV3RESTAPIClientActionsListRunnerApplicationsForOrgResponse{}, err
	}
	return result, nil
}

// ActionsListRunnerApplicationsForRepo - Lists binaries for the runner application that you can download and run.
// You must authenticate using an access token with the repo scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListRunnerApplicationsForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListRunnerApplicationsForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListRunnerApplicationsForRepo(ctx context.Context, options *GitHubV3RESTAPIClientActionsListRunnerApplicationsForRepoOptions) (GitHubV3RESTAPIClientActionsListRunnerApplicationsForRepoResponse, error) {
	req, err := client.actionsListRunnerApplicationsForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListRunnerApplicationsForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListRunnerApplicationsForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListRunnerApplicationsForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListRunnerApplicationsForRepoHandleResponse(resp)
}

// actionsListRunnerApplicationsForRepoCreateRequest creates the ActionsListRunnerApplicationsForRepo request.
func (client *GitHubV3RESTAPIClient) actionsListRunnerApplicationsForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListRunnerApplicationsForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runners/downloads"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListRunnerApplicationsForRepoHandleResponse handles the ActionsListRunnerApplicationsForRepo response.
func (client *GitHubV3RESTAPIClient) actionsListRunnerApplicationsForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListRunnerApplicationsForRepoResponse, error) {
	result := GitHubV3RESTAPIClientActionsListRunnerApplicationsForRepoResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RunnerApplicationArray); err != nil {
		return GitHubV3RESTAPIClientActionsListRunnerApplicationsForRepoResponse{}, err
	}
	return result, nil
}

// ActionsListSelectedReposForOrgSecret - Lists all repositories that have been selected when the visibility for repository
// access to a secret is set to selected. You must authenticate using an access token with the admin:org scope to use
// this endpoint. GitHub Apps must have the secrets organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListSelectedReposForOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListSelectedReposForOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListSelectedReposForOrgSecret(ctx context.Context, options *GitHubV3RESTAPIClientActionsListSelectedReposForOrgSecretOptions) (GitHubV3RESTAPIClientActionsListSelectedReposForOrgSecretResponse, error) {
	req, err := client.actionsListSelectedReposForOrgSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListSelectedReposForOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListSelectedReposForOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListSelectedReposForOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListSelectedReposForOrgSecretHandleResponse(resp)
}

// actionsListSelectedReposForOrgSecretCreateRequest creates the ActionsListSelectedReposForOrgSecret request.
func (client *GitHubV3RESTAPIClient) actionsListSelectedReposForOrgSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListSelectedReposForOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/secrets/{secret_name}/repositories"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListSelectedReposForOrgSecretHandleResponse handles the ActionsListSelectedReposForOrgSecret response.
func (client *GitHubV3RESTAPIClient) actionsListSelectedReposForOrgSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListSelectedReposForOrgSecretResponse, error) {
	result := GitHubV3RESTAPIClientActionsListSelectedReposForOrgSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1Ytc06JOrgsOrgActionsSecretsSecretNameRepositoriesGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListSelectedReposForOrgSecretResponse{}, err
	}
	return result, nil
}

// ActionsListSelectedReposForOrgVariable - Lists all repositories that can access an organization variable that is available
// to selected repositories. You must authenticate using an access token with the admin:org scope to use this endpoint.
// GitHub Apps must have the organizationactionsvariables:read organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListSelectedReposForOrgVariableOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListSelectedReposForOrgVariable
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListSelectedReposForOrgVariable(ctx context.Context, options *GitHubV3RESTAPIClientActionsListSelectedReposForOrgVariableOptions) (GitHubV3RESTAPIClientActionsListSelectedReposForOrgVariableResponse, error) {
	req, err := client.actionsListSelectedReposForOrgVariableCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListSelectedReposForOrgVariableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListSelectedReposForOrgVariableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusConflict) {
		return GitHubV3RESTAPIClientActionsListSelectedReposForOrgVariableResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListSelectedReposForOrgVariableHandleResponse(resp)
}

// actionsListSelectedReposForOrgVariableCreateRequest creates the ActionsListSelectedReposForOrgVariable request.
func (client *GitHubV3RESTAPIClient) actionsListSelectedReposForOrgVariableCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListSelectedReposForOrgVariableOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/variables/{name}/repositories"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.name == "" {
		return nil, errors.New("parameter client.name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(client.name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListSelectedReposForOrgVariableHandleResponse handles the ActionsListSelectedReposForOrgVariable response.
func (client *GitHubV3RESTAPIClient) actionsListSelectedReposForOrgVariableHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListSelectedReposForOrgVariableResponse, error) {
	result := GitHubV3RESTAPIClientActionsListSelectedReposForOrgVariableResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths10Nuc3UOrgsOrgActionsVariablesNameRepositoriesGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListSelectedReposForOrgVariableResponse{}, err
	}
	return result, nil
}

// ActionsListSelectedRepositoriesEnabledGithubActionsOrganization - Lists the selected repositories that are enabled for
// GitHub Actions in an organization. To use this endpoint, the organization permission policy for enabled_repositories must
// be configured to selected
// . For more information, see "Set GitHub Actions permissions for an organization."
// You must authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must have the administration
// organization permission to use this API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOptions contains the optional
//     parameters for the GitHubV3RESTAPIClient.ActionsListSelectedRepositoriesEnabledGithubActionsOrganization method.
func (client *GitHubV3RESTAPIClient) ActionsListSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, options *GitHubV3RESTAPIClientActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOptions) (GitHubV3RESTAPIClientActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse, error) {
	req, err := client.actionsListSelectedRepositoriesEnabledGithubActionsOrganizationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListSelectedRepositoriesEnabledGithubActionsOrganizationHandleResponse(resp)
}

// actionsListSelectedRepositoriesEnabledGithubActionsOrganizationCreateRequest creates the ActionsListSelectedRepositoriesEnabledGithubActionsOrganization request.
func (client *GitHubV3RESTAPIClient) actionsListSelectedRepositoriesEnabledGithubActionsOrganizationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListSelectedRepositoriesEnabledGithubActionsOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/permissions/repositories"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListSelectedRepositoriesEnabledGithubActionsOrganizationHandleResponse handles the ActionsListSelectedRepositoriesEnabledGithubActionsOrganization response.
func (client *GitHubV3RESTAPIClient) actionsListSelectedRepositoriesEnabledGithubActionsOrganizationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse, error) {
	result := GitHubV3RESTAPIClientActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsKt2637OrgsOrgActionsPermissionsRepositoriesGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse{}, err
	}
	return result, nil
}

// ActionsListSelectedRepositoriesRequiredWorkflow - Lists the selected repositories that are configured for a required workflow
// in an organization. To use this endpoint, the required workflow must be configured to run on selected repositories.
// You must authenticate using an access token with the read:org scope to use this endpoint. GitHub Apps must have the administration
// organization permission to use this endpoint.
// For more information, see "Required Workflows [https://docs.github.com/actions/using-workflows/required-workflows]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListSelectedRepositoriesRequiredWorkflowOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.ActionsListSelectedRepositoriesRequiredWorkflow method.
func (client *GitHubV3RESTAPIClient) ActionsListSelectedRepositoriesRequiredWorkflow(ctx context.Context, options *GitHubV3RESTAPIClientActionsListSelectedRepositoriesRequiredWorkflowOptions) (GitHubV3RESTAPIClientActionsListSelectedRepositoriesRequiredWorkflowResponse, error) {
	req, err := client.actionsListSelectedRepositoriesRequiredWorkflowCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListSelectedRepositoriesRequiredWorkflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListSelectedRepositoriesRequiredWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientActionsListSelectedRepositoriesRequiredWorkflowResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListSelectedRepositoriesRequiredWorkflowHandleResponse(resp)
}

// actionsListSelectedRepositoriesRequiredWorkflowCreateRequest creates the ActionsListSelectedRepositoriesRequiredWorkflow request.
func (client *GitHubV3RESTAPIClient) actionsListSelectedRepositoriesRequiredWorkflowCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListSelectedRepositoriesRequiredWorkflowOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{required_workflow_id}", url.PathEscape(strconv.FormatInt(int64(client.requiredWorkflowID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListSelectedRepositoriesRequiredWorkflowHandleResponse handles the ActionsListSelectedRepositoriesRequiredWorkflow response.
func (client *GitHubV3RESTAPIClient) actionsListSelectedRepositoriesRequiredWorkflowHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListSelectedRepositoriesRequiredWorkflowResponse, error) {
	result := GitHubV3RESTAPIClientActionsListSelectedRepositoriesRequiredWorkflowResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths76UzzdOrgsOrgActionsRequiredWorkflowsRequiredWorkflowIDRepositoriesGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListSelectedRepositoriesRequiredWorkflowResponse{}, err
	}
	return result, nil
}

// ActionsListSelfHostedRunnersForOrg - Lists all self-hosted runners configured in an organization.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListSelfHostedRunnersForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListSelfHostedRunnersForOrg
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListSelfHostedRunnersForOrg(ctx context.Context, options *GitHubV3RESTAPIClientActionsListSelfHostedRunnersForOrgOptions) (GitHubV3RESTAPIClientActionsListSelfHostedRunnersForOrgResponse, error) {
	req, err := client.actionsListSelfHostedRunnersForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListSelfHostedRunnersForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListSelfHostedRunnersForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListSelfHostedRunnersForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListSelfHostedRunnersForOrgHandleResponse(resp)
}

// actionsListSelfHostedRunnersForOrgCreateRequest creates the ActionsListSelfHostedRunnersForOrg request.
func (client *GitHubV3RESTAPIClient) actionsListSelfHostedRunnersForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListSelfHostedRunnersForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/runners"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListSelfHostedRunnersForOrgHandleResponse handles the ActionsListSelfHostedRunnersForOrg response.
func (client *GitHubV3RESTAPIClient) actionsListSelfHostedRunnersForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListSelfHostedRunnersForOrgResponse, error) {
	result := GitHubV3RESTAPIClientActionsListSelfHostedRunnersForOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsQ9KnwtOrgsOrgActionsRunnersGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListSelfHostedRunnersForOrgResponse{}, err
	}
	return result, nil
}

// ActionsListSelfHostedRunnersForRepo - Lists all self-hosted runners configured in a repository. You must authenticate using
// an access token with the repo scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListSelfHostedRunnersForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListSelfHostedRunnersForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListSelfHostedRunnersForRepo(ctx context.Context, options *GitHubV3RESTAPIClientActionsListSelfHostedRunnersForRepoOptions) (GitHubV3RESTAPIClientActionsListSelfHostedRunnersForRepoResponse, error) {
	req, err := client.actionsListSelfHostedRunnersForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListSelfHostedRunnersForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListSelfHostedRunnersForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListSelfHostedRunnersForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListSelfHostedRunnersForRepoHandleResponse(resp)
}

// actionsListSelfHostedRunnersForRepoCreateRequest creates the ActionsListSelfHostedRunnersForRepo request.
func (client *GitHubV3RESTAPIClient) actionsListSelfHostedRunnersForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListSelfHostedRunnersForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runners"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListSelfHostedRunnersForRepoHandleResponse handles the ActionsListSelfHostedRunnersForRepo response.
func (client *GitHubV3RESTAPIClient) actionsListSelfHostedRunnersForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListSelfHostedRunnersForRepoResponse, error) {
	result := GitHubV3RESTAPIClientActionsListSelfHostedRunnersForRepoResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1Iucyl4ReposOwnerRepoActionsRunnersGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListSelfHostedRunnersForRepoResponse{}, err
	}
	return result, nil
}

// ActionsListWorkflowRunArtifacts - Lists artifacts for a workflow run. Anyone with read access to the repository can use
// this endpoint. If the repository is private you must use an access token with the repo scope. GitHub Apps must
// have the actions:read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListWorkflowRunArtifactsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListWorkflowRunArtifacts
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListWorkflowRunArtifacts(ctx context.Context, options *GitHubV3RESTAPIClientActionsListWorkflowRunArtifactsOptions) (GitHubV3RESTAPIClientActionsListWorkflowRunArtifactsResponse, error) {
	req, err := client.actionsListWorkflowRunArtifactsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListWorkflowRunArtifactsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListWorkflowRunArtifactsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListWorkflowRunArtifactsResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListWorkflowRunArtifactsHandleResponse(resp)
}

// actionsListWorkflowRunArtifactsCreateRequest creates the ActionsListWorkflowRunArtifacts request.
func (client *GitHubV3RESTAPIClient) actionsListWorkflowRunArtifactsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListWorkflowRunArtifactsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListWorkflowRunArtifactsHandleResponse handles the ActionsListWorkflowRunArtifacts response.
func (client *GitHubV3RESTAPIClient) actionsListWorkflowRunArtifactsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListWorkflowRunArtifactsResponse, error) {
	result := GitHubV3RESTAPIClientActionsListWorkflowRunArtifactsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1Cfde2ReposOwnerRepoActionsRunsRunIDArtifactsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListWorkflowRunArtifactsResponse{}, err
	}
	return result, nil
}

// ActionsListWorkflowRuns - List all workflow runs for a workflow. You can replace workflow_id with the workflow file name.
// For example, you could use main.yaml. You can use parameters to narrow the list of results. For more
// information about using parameters, see Parameters [https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters].
// Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token
// with the repo scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListWorkflowRunsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListWorkflowRuns
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListWorkflowRuns(ctx context.Context, options *GitHubV3RESTAPIClientActionsListWorkflowRunsOptions) (GitHubV3RESTAPIClientActionsListWorkflowRunsResponse, error) {
	req, err := client.actionsListWorkflowRunsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListWorkflowRunsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListWorkflowRunsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListWorkflowRunsResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListWorkflowRunsHandleResponse(resp)
}

// actionsListWorkflowRunsCreateRequest creates the ActionsListWorkflowRuns request.
func (client *GitHubV3RESTAPIClient) actionsListWorkflowRunsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListWorkflowRunsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{workflow_id}", url.PathEscape(client.workflowID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.actor != nil {
		reqQP.Set("actor", *client.actor)
	}
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	if client.event != nil {
		reqQP.Set("event", *client.event)
	}
	if client.status != nil {
		reqQP.Set("status", string(*client.status))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.created != nil {
		reqQP.Set("created", client.created.Format(time.RFC3339Nano))
	}
	if client.excludePullRequests != nil {
		reqQP.Set("exclude_pull_requests", strconv.FormatBool(*client.excludePullRequests))
	}
	if client.checkSuiteID != nil {
		reqQP.Set("check_suite_id", strconv.FormatInt(int64(*client.checkSuiteID), 10))
	}
	if client.headSHA != nil {
		reqQP.Set("head_sha", *client.headSHA)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListWorkflowRunsHandleResponse handles the ActionsListWorkflowRuns response.
func (client *GitHubV3RESTAPIClient) actionsListWorkflowRunsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListWorkflowRunsResponse, error) {
	result := GitHubV3RESTAPIClientActionsListWorkflowRunsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsVb9Tf3ReposOwnerRepoActionsWorkflowsWorkflowIDRunsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListWorkflowRunsResponse{}, err
	}
	return result, nil
}

// ActionsListWorkflowRunsForRepo - Lists all workflow runs for a repository. You can use parameters to narrow the list of
// results. For more information about using parameters, see Parameters
// [https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters].
// Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token
// with the repo scope. GitHub Apps must have the actions:read permission to use
// this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsListWorkflowRunsForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsListWorkflowRunsForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ActionsListWorkflowRunsForRepo(ctx context.Context, options *GitHubV3RESTAPIClientActionsListWorkflowRunsForRepoOptions) (GitHubV3RESTAPIClientActionsListWorkflowRunsForRepoResponse, error) {
	req, err := client.actionsListWorkflowRunsForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListWorkflowRunsForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsListWorkflowRunsForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsListWorkflowRunsForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsListWorkflowRunsForRepoHandleResponse(resp)
}

// actionsListWorkflowRunsForRepoCreateRequest creates the ActionsListWorkflowRunsForRepo request.
func (client *GitHubV3RESTAPIClient) actionsListWorkflowRunsForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsListWorkflowRunsForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.actor != nil {
		reqQP.Set("actor", *client.actor)
	}
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	if client.event != nil {
		reqQP.Set("event", *client.event)
	}
	if client.status != nil {
		reqQP.Set("status", string(*client.status))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.created != nil {
		reqQP.Set("created", client.created.Format(time.RFC3339Nano))
	}
	if client.excludePullRequests != nil {
		reqQP.Set("exclude_pull_requests", strconv.FormatBool(*client.excludePullRequests))
	}
	if client.checkSuiteID != nil {
		reqQP.Set("check_suite_id", strconv.FormatInt(int64(*client.checkSuiteID), 10))
	}
	if client.headSHA != nil {
		reqQP.Set("head_sha", *client.headSHA)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsListWorkflowRunsForRepoHandleResponse handles the ActionsListWorkflowRunsForRepo response.
func (client *GitHubV3RESTAPIClient) actionsListWorkflowRunsForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsListWorkflowRunsForRepoResponse, error) {
	result := GitHubV3RESTAPIClientActionsListWorkflowRunsForRepoResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1O9Ial2ReposOwnerRepoActionsRunsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActionsListWorkflowRunsForRepoResponse{}, err
	}
	return result, nil
}

// ActionsReRunJobForWorkflowRun - Re-run a job and its dependent jobs in a workflow run. You must authenticate using an access
// token with the repo scope to use this endpoint. GitHub Apps must have the actions:write permission to use
// this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsReRunJobForWorkflowRunOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsReRunJobForWorkflowRun
//     method.
func (client *GitHubV3RESTAPIClient) ActionsReRunJobForWorkflowRun(ctx context.Context, options *GitHubV3RESTAPIClientActionsReRunJobForWorkflowRunOptions) (GitHubV3RESTAPIClientActionsReRunJobForWorkflowRunResponse, error) {
	req, err := client.actionsReRunJobForWorkflowRunCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsReRunJobForWorkflowRunResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsReRunJobForWorkflowRunResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden) {
		return GitHubV3RESTAPIClientActionsReRunJobForWorkflowRunResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsReRunJobForWorkflowRunHandleResponse(resp)
}

// actionsReRunJobForWorkflowRunCreateRequest creates the ActionsReRunJobForWorkflowRun request.
func (client *GitHubV3RESTAPIClient) actionsReRunJobForWorkflowRunCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsReRunJobForWorkflowRunOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{job_id}", url.PathEscape(strconv.FormatInt(int64(client.jobID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// actionsReRunJobForWorkflowRunHandleResponse handles the ActionsReRunJobForWorkflowRun response.
func (client *GitHubV3RESTAPIClient) actionsReRunJobForWorkflowRunHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsReRunJobForWorkflowRunResponse, error) {
	result := GitHubV3RESTAPIClientActionsReRunJobForWorkflowRunResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsReRunJobForWorkflowRunResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsReRunJobForWorkflowRunResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsReRunJobForWorkflowRunResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsReRunWorkflow - Re-runs your workflow run using its id. You must authenticate using an access token with the repo
// scope to use this endpoint. GitHub Apps must have the actions:write permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsReRunWorkflowOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsReRunWorkflow
//     method.
func (client *GitHubV3RESTAPIClient) ActionsReRunWorkflow(ctx context.Context, options *GitHubV3RESTAPIClientActionsReRunWorkflowOptions) (GitHubV3RESTAPIClientActionsReRunWorkflowResponse, error) {
	req, err := client.actionsReRunWorkflowCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsReRunWorkflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsReRunWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientActionsReRunWorkflowResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsReRunWorkflowHandleResponse(resp)
}

// actionsReRunWorkflowCreateRequest creates the ActionsReRunWorkflow request.
func (client *GitHubV3RESTAPIClient) actionsReRunWorkflowCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsReRunWorkflowOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}/rerun"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// actionsReRunWorkflowHandleResponse handles the ActionsReRunWorkflow response.
func (client *GitHubV3RESTAPIClient) actionsReRunWorkflowHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsReRunWorkflowResponse, error) {
	result := GitHubV3RESTAPIClientActionsReRunWorkflowResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return GitHubV3RESTAPIClientActionsReRunWorkflowResponse{}, err
	}
	return result, nil
}

// ActionsReRunWorkflowFailedJobs - Re-run all of the failed jobs and their dependent jobs in a workflow run using the id
// of the workflow run. You must authenticate using an access token with the repo scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsReRunWorkflowFailedJobsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsReRunWorkflowFailedJobs
//     method.
func (client *GitHubV3RESTAPIClient) ActionsReRunWorkflowFailedJobs(ctx context.Context, options *GitHubV3RESTAPIClientActionsReRunWorkflowFailedJobsOptions) (GitHubV3RESTAPIClientActionsReRunWorkflowFailedJobsResponse, error) {
	req, err := client.actionsReRunWorkflowFailedJobsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsReRunWorkflowFailedJobsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsReRunWorkflowFailedJobsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientActionsReRunWorkflowFailedJobsResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsReRunWorkflowFailedJobsHandleResponse(resp)
}

// actionsReRunWorkflowFailedJobsCreateRequest creates the ActionsReRunWorkflowFailedJobs request.
func (client *GitHubV3RESTAPIClient) actionsReRunWorkflowFailedJobsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsReRunWorkflowFailedJobsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// actionsReRunWorkflowFailedJobsHandleResponse handles the ActionsReRunWorkflowFailedJobs response.
func (client *GitHubV3RESTAPIClient) actionsReRunWorkflowFailedJobsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsReRunWorkflowFailedJobsResponse, error) {
	result := GitHubV3RESTAPIClientActionsReRunWorkflowFailedJobsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return GitHubV3RESTAPIClientActionsReRunWorkflowFailedJobsResponse{}, err
	}
	return result, nil
}

// ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg - Remove all custom labels from a self-hosted runner configured
// in an organization. Returns the remaining read-only labels from the runner.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg method.
func (client *GitHubV3RESTAPIClient) ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg(ctx context.Context, options *GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgOptions) (GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse, error) {
	req, err := client.actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgHandleResponse(resp)
}

// actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgCreateRequest creates the ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg request.
func (client *GitHubV3RESTAPIClient) actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/runners/{runner_id}/labels"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{runner_id}", url.PathEscape(strconv.FormatInt(int64(client.runnerID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgHandleResponse handles the ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg response.
func (client *GitHubV3RESTAPIClient) actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse, error) {
	result := GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Components42BwcuResponsesActionsRunnerLabelsReadonlyContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo - Remove all custom labels from a self-hosted runner configured
// in a repository. Returns the remaining read-only labels from the runner.
// You must authenticate using an access token with the repo scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo method.
func (client *GitHubV3RESTAPIClient) ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo(ctx context.Context, options *GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoOptions) (GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse, error) {
	req, err := client.actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoHandleResponse(resp)
}

// actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoCreateRequest creates the ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo request.
func (client *GitHubV3RESTAPIClient) actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{runner_id}", url.PathEscape(strconv.FormatInt(int64(client.runnerID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoHandleResponse handles the ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo response.
func (client *GitHubV3RESTAPIClient) actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse, error) {
	result := GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Components42BwcuResponsesActionsRunnerLabelsReadonlyContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg - Remove a custom label from a self-hosted runner configured in an organization.
// Returns the remaining labels from the runner.
// This endpoint returns a 404 Not Found status if the custom label is not present on the runner.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForOrgOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg method.
func (client *GitHubV3RESTAPIClient) ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg(ctx context.Context, options *GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForOrgOptions) (GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse, error) {
	req, err := client.actionsRemoveCustomLabelFromSelfHostedRunnerForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsRemoveCustomLabelFromSelfHostedRunnerForOrgHandleResponse(resp)
}

// actionsRemoveCustomLabelFromSelfHostedRunnerForOrgCreateRequest creates the ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg request.
func (client *GitHubV3RESTAPIClient) actionsRemoveCustomLabelFromSelfHostedRunnerForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/runners/{runner_id}/labels/{name}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{runner_id}", url.PathEscape(strconv.FormatInt(int64(client.runnerID), 10)))
	if client.name == "" {
		return nil, errors.New("parameter client.name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(client.name))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsRemoveCustomLabelFromSelfHostedRunnerForOrgHandleResponse handles the ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg response.
func (client *GitHubV3RESTAPIClient) actionsRemoveCustomLabelFromSelfHostedRunnerForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse, error) {
	result := GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ComponentsDhs7QhResponsesActionsRunnerLabelsContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo - Remove a custom label from a self-hosted runner configured in a repository.
// Returns the remaining labels from the runner.
// This endpoint returns a 404 Not Found status if the custom label is not present on the runner.
// You must authenticate using an access token with the repo scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForRepoOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo method.
func (client *GitHubV3RESTAPIClient) ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo(ctx context.Context, options *GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForRepoOptions) (GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse, error) {
	req, err := client.actionsRemoveCustomLabelFromSelfHostedRunnerForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsRemoveCustomLabelFromSelfHostedRunnerForRepoHandleResponse(resp)
}

// actionsRemoveCustomLabelFromSelfHostedRunnerForRepoCreateRequest creates the ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo request.
func (client *GitHubV3RESTAPIClient) actionsRemoveCustomLabelFromSelfHostedRunnerForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{runner_id}", url.PathEscape(strconv.FormatInt(int64(client.runnerID), 10)))
	if client.name == "" {
		return nil, errors.New("parameter client.name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(client.name))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// actionsRemoveCustomLabelFromSelfHostedRunnerForRepoHandleResponse handles the ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo response.
func (client *GitHubV3RESTAPIClient) actionsRemoveCustomLabelFromSelfHostedRunnerForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse, error) {
	result := GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ComponentsDhs7QhResponsesActionsRunnerLabelsContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsRemoveSelectedRepoFromOrgSecret - Removes a repository from an organization secret when the visibility for repository
// access is set to selected. The visibility is set when you Create or update an organization secret
// [https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret]. You must authenticate using an
// access token with the admin:org scope to use this endpoint. GitHub Apps must
// have the secrets organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsRemoveSelectedRepoFromOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) ActionsRemoveSelectedRepoFromOrgSecret(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromOrgSecretOptions) (GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromOrgSecretResponse, error) {
	req, err := client.actionsRemoveSelectedRepoFromOrgSecretCreateRequest(ctx, repositoryID, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusConflict) {
		return GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromOrgSecretResponse{}, nil
}

// actionsRemoveSelectedRepoFromOrgSecretCreateRequest creates the ActionsRemoveSelectedRepoFromOrgSecret request.
func (client *GitHubV3RESTAPIClient) actionsRemoveSelectedRepoFromOrgSecretCreateRequest(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsRemoveSelectedRepoFromOrgVariable - Removes a repository from an organization variable that is available to selected
// repositories. Organization variables that are available to selected repositories have their visibility field set to
// selected. You must authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must have
// the organizationactionsvariables:write organization permission to use this
// endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromOrgVariableOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ActionsRemoveSelectedRepoFromOrgVariable method.
func (client *GitHubV3RESTAPIClient) ActionsRemoveSelectedRepoFromOrgVariable(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromOrgVariableOptions) (GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromOrgVariableResponse, error) {
	req, err := client.actionsRemoveSelectedRepoFromOrgVariableCreateRequest(ctx, repositoryID, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromOrgVariableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromOrgVariableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusConflict) {
		return GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromOrgVariableResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromOrgVariableResponse{}, nil
}

// actionsRemoveSelectedRepoFromOrgVariableCreateRequest creates the ActionsRemoveSelectedRepoFromOrgVariable request.
func (client *GitHubV3RESTAPIClient) actionsRemoveSelectedRepoFromOrgVariableCreateRequest(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromOrgVariableOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.name == "" {
		return nil, errors.New("parameter client.name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(client.name))
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsRemoveSelectedRepoFromRequiredWorkflow - Removes a repository from a required workflow. To use this endpoint, the
// required workflow must be configured to run on selected repositories.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// For more information, see "Required Workflows [https://docs.github.com/actions/using-workflows/required-workflows]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromRequiredWorkflowOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.ActionsRemoveSelectedRepoFromRequiredWorkflow method.
func (client *GitHubV3RESTAPIClient) ActionsRemoveSelectedRepoFromRequiredWorkflow(ctx context.Context, options *GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromRequiredWorkflowOptions) (GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromRequiredWorkflowResponse, error) {
	req, err := client.actionsRemoveSelectedRepoFromRequiredWorkflowCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromRequiredWorkflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromRequiredWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromRequiredWorkflowResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromRequiredWorkflowResponse{}, nil
}

// actionsRemoveSelectedRepoFromRequiredWorkflowCreateRequest creates the ActionsRemoveSelectedRepoFromRequiredWorkflow request.
func (client *GitHubV3RESTAPIClient) actionsRemoveSelectedRepoFromRequiredWorkflowCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActionsRemoveSelectedRepoFromRequiredWorkflowOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories/{repository_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{required_workflow_id}", url.PathEscape(strconv.FormatInt(int64(client.requiredWorkflowID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActionsReviewPendingDeploymentsForRun - Approve or reject pending deployments that are waiting on approval by a required
// reviewer.
// Required reviewers with read access to the repository contents and deployments can use this endpoint. Required reviewers
// must authenticate using an access token with the repo scope to use this
// endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsReviewPendingDeploymentsForRunOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsReviewPendingDeploymentsForRun
//     method.
func (client *GitHubV3RESTAPIClient) ActionsReviewPendingDeploymentsForRun(ctx context.Context, body Paths1Ghtn1LReposOwnerRepoActionsRunsRunIDPendingDeploymentsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsReviewPendingDeploymentsForRunOptions) (GitHubV3RESTAPIClientActionsReviewPendingDeploymentsForRunResponse, error) {
	req, err := client.actionsReviewPendingDeploymentsForRunCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsReviewPendingDeploymentsForRunResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsReviewPendingDeploymentsForRunResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActionsReviewPendingDeploymentsForRunResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsReviewPendingDeploymentsForRunHandleResponse(resp)
}

// actionsReviewPendingDeploymentsForRunCreateRequest creates the ActionsReviewPendingDeploymentsForRun request.
func (client *GitHubV3RESTAPIClient) actionsReviewPendingDeploymentsForRunCreateRequest(ctx context.Context, body Paths1Ghtn1LReposOwnerRepoActionsRunsRunIDPendingDeploymentsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsReviewPendingDeploymentsForRunOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{run_id}", url.PathEscape(strconv.FormatInt(int64(client.runID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// actionsReviewPendingDeploymentsForRunHandleResponse handles the ActionsReviewPendingDeploymentsForRun response.
func (client *GitHubV3RESTAPIClient) actionsReviewPendingDeploymentsForRunHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsReviewPendingDeploymentsForRunResponse, error) {
	result := GitHubV3RESTAPIClientActionsReviewPendingDeploymentsForRunResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentArray); err != nil {
		return GitHubV3RESTAPIClientActionsReviewPendingDeploymentsForRunResponse{}, err
	}
	return result, nil
}

// ActionsSetAllowedActionsOrganization - Sets the actions and reusable workflows that are allowed in an organization. To
// use this endpoint, the organization permission policy for allowed_actions must be configured to selected. For more
// information, see "Set GitHub Actions permissions for an organization."
// You must authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must have the administration
// organization permission to use this API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsSetAllowedActionsOrganizationOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsSetAllowedActionsOrganization
//     method.
func (client *GitHubV3RESTAPIClient) ActionsSetAllowedActionsOrganization(ctx context.Context, body SelectedActions, options *GitHubV3RESTAPIClientActionsSetAllowedActionsOrganizationOptions) (GitHubV3RESTAPIClientActionsSetAllowedActionsOrganizationResponse, error) {
	req, err := client.actionsSetAllowedActionsOrganizationCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetAllowedActionsOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetAllowedActionsOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsSetAllowedActionsOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsSetAllowedActionsOrganizationResponse{}, nil
}

// actionsSetAllowedActionsOrganizationCreateRequest creates the ActionsSetAllowedActionsOrganization request.
func (client *GitHubV3RESTAPIClient) actionsSetAllowedActionsOrganizationCreateRequest(ctx context.Context, body SelectedActions, options *GitHubV3RESTAPIClientActionsSetAllowedActionsOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/permissions/selected-actions"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// ActionsSetAllowedActionsRepository - Sets the actions and reusable workflows that are allowed in a repository. To use this
// endpoint, the repository permission policy for allowed_actions must be configured to selected. For more
// information, see "Set GitHub Actions permissions for a repository."
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the administration
// repository permission to use this API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsSetAllowedActionsRepositoryOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsSetAllowedActionsRepository
//     method.
func (client *GitHubV3RESTAPIClient) ActionsSetAllowedActionsRepository(ctx context.Context, body SelectedActions, options *GitHubV3RESTAPIClientActionsSetAllowedActionsRepositoryOptions) (GitHubV3RESTAPIClientActionsSetAllowedActionsRepositoryResponse, error) {
	req, err := client.actionsSetAllowedActionsRepositoryCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetAllowedActionsRepositoryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetAllowedActionsRepositoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsSetAllowedActionsRepositoryResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsSetAllowedActionsRepositoryResponse{}, nil
}

// actionsSetAllowedActionsRepositoryCreateRequest creates the ActionsSetAllowedActionsRepository request.
func (client *GitHubV3RESTAPIClient) actionsSetAllowedActionsRepositoryCreateRequest(ctx context.Context, body SelectedActions, options *GitHubV3RESTAPIClientActionsSetAllowedActionsRepositoryOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/permissions/selected-actions"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// ActionsSetCustomLabelsForSelfHostedRunnerForOrg - Remove all previous custom labels and set the new custom labels for a
// specific self-hosted runner configured in an organization.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForOrgOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.ActionsSetCustomLabelsForSelfHostedRunnerForOrg method.
func (client *GitHubV3RESTAPIClient) ActionsSetCustomLabelsForSelfHostedRunnerForOrg(ctx context.Context, body Paths9J8NbyOrgsOrgActionsRunnersRunnerIDLabelsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForOrgOptions) (GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse, error) {
	req, err := client.actionsSetCustomLabelsForSelfHostedRunnerForOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsSetCustomLabelsForSelfHostedRunnerForOrgHandleResponse(resp)
}

// actionsSetCustomLabelsForSelfHostedRunnerForOrgCreateRequest creates the ActionsSetCustomLabelsForSelfHostedRunnerForOrg request.
func (client *GitHubV3RESTAPIClient) actionsSetCustomLabelsForSelfHostedRunnerForOrgCreateRequest(ctx context.Context, body Paths9J8NbyOrgsOrgActionsRunnersRunnerIDLabelsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/runners/{runner_id}/labels"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{runner_id}", url.PathEscape(strconv.FormatInt(int64(client.runnerID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// actionsSetCustomLabelsForSelfHostedRunnerForOrgHandleResponse handles the ActionsSetCustomLabelsForSelfHostedRunnerForOrg response.
func (client *GitHubV3RESTAPIClient) actionsSetCustomLabelsForSelfHostedRunnerForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse, error) {
	result := GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ComponentsDhs7QhResponsesActionsRunnerLabelsContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsSetCustomLabelsForSelfHostedRunnerForRepo - Remove all previous custom labels and set the new custom labels for
// a specific self-hosted runner configured in a repository.
// You must authenticate using an access token with the repo scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForRepoOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.ActionsSetCustomLabelsForSelfHostedRunnerForRepo method.
func (client *GitHubV3RESTAPIClient) ActionsSetCustomLabelsForSelfHostedRunnerForRepo(ctx context.Context, body PathsC8XtzdReposOwnerRepoActionsRunnersRunnerIDLabelsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForRepoOptions) (GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse, error) {
	req, err := client.actionsSetCustomLabelsForSelfHostedRunnerForRepoCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsSetCustomLabelsForSelfHostedRunnerForRepoHandleResponse(resp)
}

// actionsSetCustomLabelsForSelfHostedRunnerForRepoCreateRequest creates the ActionsSetCustomLabelsForSelfHostedRunnerForRepo request.
func (client *GitHubV3RESTAPIClient) actionsSetCustomLabelsForSelfHostedRunnerForRepoCreateRequest(ctx context.Context, body PathsC8XtzdReposOwnerRepoActionsRunnersRunnerIDLabelsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{runner_id}", url.PathEscape(strconv.FormatInt(int64(client.runnerID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// actionsSetCustomLabelsForSelfHostedRunnerForRepoHandleResponse handles the ActionsSetCustomLabelsForSelfHostedRunnerForRepo response.
func (client *GitHubV3RESTAPIClient) actionsSetCustomLabelsForSelfHostedRunnerForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse, error) {
	result := GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ComponentsDhs7QhResponsesActionsRunnerLabelsContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsSetCustomOidcSubClaimForRepo - Sets the customization template and opt-in or opt-out flag for an OpenID Connect
// (OIDC) subject claim for a repository. You must authenticate using an access token with the repo scope to use this
// endpoint. GitHub Apps must have the actions:write permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsSetCustomOidcSubClaimForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsSetCustomOidcSubClaimForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ActionsSetCustomOidcSubClaimForRepo(ctx context.Context, body ActionsOIDCSubjectCustomizationForARepository, options *GitHubV3RESTAPIClientActionsSetCustomOidcSubClaimForRepoOptions) (GitHubV3RESTAPIClientActionsSetCustomOidcSubClaimForRepoResponse, error) {
	req, err := client.actionsSetCustomOidcSubClaimForRepoCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetCustomOidcSubClaimForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetCustomOidcSubClaimForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusBadRequest, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientActionsSetCustomOidcSubClaimForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsSetCustomOidcSubClaimForRepoHandleResponse(resp)
}

// actionsSetCustomOidcSubClaimForRepoCreateRequest creates the ActionsSetCustomOidcSubClaimForRepo request.
func (client *GitHubV3RESTAPIClient) actionsSetCustomOidcSubClaimForRepoCreateRequest(ctx context.Context, body ActionsOIDCSubjectCustomizationForARepository, options *GitHubV3RESTAPIClientActionsSetCustomOidcSubClaimForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/oidc/customization/sub"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// actionsSetCustomOidcSubClaimForRepoHandleResponse handles the ActionsSetCustomOidcSubClaimForRepo response.
func (client *GitHubV3RESTAPIClient) actionsSetCustomOidcSubClaimForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsSetCustomOidcSubClaimForRepoResponse, error) {
	result := GitHubV3RESTAPIClientActionsSetCustomOidcSubClaimForRepoResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsSetCustomOidcSubClaimForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsSetCustomOidcSubClaimForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsSetCustomOidcSubClaimForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsSetCustomOidcSubClaimForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsSetCustomOidcSubClaimForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization - Sets the default workflow permissions granted to the GITHUBTOKEN
// when running workflows in an organization, and sets if GitHub Actions can submit approving pull request reviews. For more
// information,
// see "Setting the permissions of the GITHUBTOKEN for your organization
// [https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization]."
// You must authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must have the administration
// organization permission to use this API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationOptions contains the optional
//     parameters for the GitHubV3RESTAPIClient.ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization method.
func (client *GitHubV3RESTAPIClient) ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization(ctx context.Context, body ActionsSetDefaultWorkflowPermissions, options *GitHubV3RESTAPIClientActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationOptions) (GitHubV3RESTAPIClientActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponse, error) {
	req, err := client.actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponse{}, nil
}

// actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationCreateRequest creates the ActionsSetGithubActionsDefaultWorkflowPermissionsOrganization request.
func (client *GitHubV3RESTAPIClient) actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationCreateRequest(ctx context.Context, body ActionsSetDefaultWorkflowPermissions, options *GitHubV3RESTAPIClientActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/permissions/workflow"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// ActionsSetGithubActionsDefaultWorkflowPermissionsRepository - Sets the default workflow permissions granted to the GITHUBTOKEN
// when running workflows in a repository, and sets if GitHub Actions can submit approving pull request reviews. For more
// information, see
// "Setting the permissions of the GITHUBTOKEN for your repository
// [https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository]
// ."
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the repository
// administration permission to use this API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryOptions contains the optional
//     parameters for the GitHubV3RESTAPIClient.ActionsSetGithubActionsDefaultWorkflowPermissionsRepository method.
func (client *GitHubV3RESTAPIClient) ActionsSetGithubActionsDefaultWorkflowPermissionsRepository(ctx context.Context, body ActionsSetDefaultWorkflowPermissions, options *GitHubV3RESTAPIClientActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryOptions) (GitHubV3RESTAPIClientActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponse, error) {
	req, err := client.actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusConflict) {
		return GitHubV3RESTAPIClientActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponse{}, nil
}

// actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryCreateRequest creates the ActionsSetGithubActionsDefaultWorkflowPermissionsRepository request.
func (client *GitHubV3RESTAPIClient) actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryCreateRequest(ctx context.Context, body ActionsSetDefaultWorkflowPermissions, options *GitHubV3RESTAPIClientActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/permissions/workflow"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// ActionsSetGithubActionsPermissionsOrganization - Sets the GitHub Actions permissions policy for repositories and allowed
// actions and reusable workflows in an organization.
// You must authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must have the administration
// organization permission to use this API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsSetGithubActionsPermissionsOrganizationOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.ActionsSetGithubActionsPermissionsOrganization method.
func (client *GitHubV3RESTAPIClient) ActionsSetGithubActionsPermissionsOrganization(ctx context.Context, body Paths1Hsv14VOrgsOrgActionsPermissionsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsSetGithubActionsPermissionsOrganizationOptions) (GitHubV3RESTAPIClientActionsSetGithubActionsPermissionsOrganizationResponse, error) {
	req, err := client.actionsSetGithubActionsPermissionsOrganizationCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetGithubActionsPermissionsOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetGithubActionsPermissionsOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsSetGithubActionsPermissionsOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsSetGithubActionsPermissionsOrganizationResponse{}, nil
}

// actionsSetGithubActionsPermissionsOrganizationCreateRequest creates the ActionsSetGithubActionsPermissionsOrganization request.
func (client *GitHubV3RESTAPIClient) actionsSetGithubActionsPermissionsOrganizationCreateRequest(ctx context.Context, body Paths1Hsv14VOrgsOrgActionsPermissionsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsSetGithubActionsPermissionsOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/permissions"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// ActionsSetGithubActionsPermissionsRepository - Sets the GitHub Actions permissions policy for enabling GitHub Actions and
// allowed actions and reusable workflows in the repository.
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the administration
// repository permission to use this API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsSetGithubActionsPermissionsRepositoryOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.ActionsSetGithubActionsPermissionsRepository method.
func (client *GitHubV3RESTAPIClient) ActionsSetGithubActionsPermissionsRepository(ctx context.Context, body Paths188IrkpReposOwnerRepoActionsPermissionsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsSetGithubActionsPermissionsRepositoryOptions) (GitHubV3RESTAPIClientActionsSetGithubActionsPermissionsRepositoryResponse, error) {
	req, err := client.actionsSetGithubActionsPermissionsRepositoryCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetGithubActionsPermissionsRepositoryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetGithubActionsPermissionsRepositoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsSetGithubActionsPermissionsRepositoryResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsSetGithubActionsPermissionsRepositoryResponse{}, nil
}

// actionsSetGithubActionsPermissionsRepositoryCreateRequest creates the ActionsSetGithubActionsPermissionsRepository request.
func (client *GitHubV3RESTAPIClient) actionsSetGithubActionsPermissionsRepositoryCreateRequest(ctx context.Context, body Paths188IrkpReposOwnerRepoActionsPermissionsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsSetGithubActionsPermissionsRepositoryOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/permissions"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// ActionsSetSelectedReposForOrgSecret - Replaces all repositories for an organization secret when the visibility for repository
// access is set to selected. The visibility is set when you Create or update an organization secret
// [https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret]. You must authenticate using an
// access token with the admin:org scope to use this endpoint. GitHub Apps must
// have the secrets organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsSetSelectedReposForOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsSetSelectedReposForOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) ActionsSetSelectedReposForOrgSecret(ctx context.Context, body PathsI1765WOrgsOrgActionsSecretsSecretNameRepositoriesPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsSetSelectedReposForOrgSecretOptions) (GitHubV3RESTAPIClientActionsSetSelectedReposForOrgSecretResponse, error) {
	req, err := client.actionsSetSelectedReposForOrgSecretCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetSelectedReposForOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetSelectedReposForOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsSetSelectedReposForOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsSetSelectedReposForOrgSecretResponse{}, nil
}

// actionsSetSelectedReposForOrgSecretCreateRequest creates the ActionsSetSelectedReposForOrgSecret request.
func (client *GitHubV3RESTAPIClient) actionsSetSelectedReposForOrgSecretCreateRequest(ctx context.Context, body PathsI1765WOrgsOrgActionsSecretsSecretNameRepositoriesPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsSetSelectedReposForOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/secrets/{secret_name}/repositories"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// ActionsSetSelectedReposForOrgVariable - Replaces all repositories for an organization variable that is available to selected
// repositories. Organization variables that are available to selected repositories have their visibility field set to
// selected. You must authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must have
// the organizationactionsvariables:write organization permission to use this
// endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsSetSelectedReposForOrgVariableOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsSetSelectedReposForOrgVariable
//     method.
func (client *GitHubV3RESTAPIClient) ActionsSetSelectedReposForOrgVariable(ctx context.Context, body Paths1Op2LjlOrgsOrgActionsVariablesNameRepositoriesPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsSetSelectedReposForOrgVariableOptions) (GitHubV3RESTAPIClientActionsSetSelectedReposForOrgVariableResponse, error) {
	req, err := client.actionsSetSelectedReposForOrgVariableCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetSelectedReposForOrgVariableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetSelectedReposForOrgVariableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusConflict) {
		return GitHubV3RESTAPIClientActionsSetSelectedReposForOrgVariableResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsSetSelectedReposForOrgVariableResponse{}, nil
}

// actionsSetSelectedReposForOrgVariableCreateRequest creates the ActionsSetSelectedReposForOrgVariable request.
func (client *GitHubV3RESTAPIClient) actionsSetSelectedReposForOrgVariableCreateRequest(ctx context.Context, body Paths1Op2LjlOrgsOrgActionsVariablesNameRepositoriesPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsSetSelectedReposForOrgVariableOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/variables/{name}/repositories"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.name == "" {
		return nil, errors.New("parameter client.name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(client.name))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// ActionsSetSelectedReposToRequiredWorkflow - Sets the repositories for a required workflow that is required for selected
// repositories.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// For more information, see "Required Workflows [https://docs.github.com/actions/using-workflows/required-workflows]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsSetSelectedReposToRequiredWorkflowOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ActionsSetSelectedReposToRequiredWorkflow method.
func (client *GitHubV3RESTAPIClient) ActionsSetSelectedReposToRequiredWorkflow(ctx context.Context, body Paths7Jq6AdOrgsOrgActionsRequiredWorkflowsRequiredWorkflowIDRepositoriesPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsSetSelectedReposToRequiredWorkflowOptions) (GitHubV3RESTAPIClientActionsSetSelectedReposToRequiredWorkflowResponse, error) {
	req, err := client.actionsSetSelectedReposToRequiredWorkflowCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetSelectedReposToRequiredWorkflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetSelectedReposToRequiredWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsSetSelectedReposToRequiredWorkflowResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsSetSelectedReposToRequiredWorkflowResponse{}, nil
}

// actionsSetSelectedReposToRequiredWorkflowCreateRequest creates the ActionsSetSelectedReposToRequiredWorkflow request.
func (client *GitHubV3RESTAPIClient) actionsSetSelectedReposToRequiredWorkflowCreateRequest(ctx context.Context, body Paths7Jq6AdOrgsOrgActionsRequiredWorkflowsRequiredWorkflowIDRepositoriesPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsSetSelectedReposToRequiredWorkflowOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{required_workflow_id}", url.PathEscape(strconv.FormatInt(int64(client.requiredWorkflowID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization - Replaces the list of selected repositories that are enabled
// for GitHub Actions in an organization. To use this endpoint, the organization permission policy for enabled_repositories
// must be configured
// to selected. For more information, see "Set GitHub Actions permissions for an organization."
// You must authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must have the administration
// organization permission to use this API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationOptions contains the optional
//     parameters for the GitHubV3RESTAPIClient.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization method.
func (client *GitHubV3RESTAPIClient) ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, body PathsFjpghsOrgsOrgActionsPermissionsRepositoriesPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationOptions) (GitHubV3RESTAPIClientActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse, error) {
	req, err := client.actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse{}, nil
}

// actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationCreateRequest creates the ActionsSetSelectedRepositoriesEnabledGithubActionsOrganization request.
func (client *GitHubV3RESTAPIClient) actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationCreateRequest(ctx context.Context, body PathsFjpghsOrgsOrgActionsPermissionsRepositoriesPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/permissions/repositories"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// ActionsSetWorkflowAccessToRepository - Sets the level of access that workflows outside of the repository have to actions
// and reusable workflows in the repository. This endpoint only applies to private repositories. For more information,
// see "Allowing access to components in a private repository
// [https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository]
// ".
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the repository
// administration permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsSetWorkflowAccessToRepositoryOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsSetWorkflowAccessToRepository
//     method.
func (client *GitHubV3RESTAPIClient) ActionsSetWorkflowAccessToRepository(ctx context.Context, body ActionsWorkflowAccessToRepository, options *GitHubV3RESTAPIClientActionsSetWorkflowAccessToRepositoryOptions) (GitHubV3RESTAPIClientActionsSetWorkflowAccessToRepositoryResponse, error) {
	req, err := client.actionsSetWorkflowAccessToRepositoryCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetWorkflowAccessToRepositoryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsSetWorkflowAccessToRepositoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsSetWorkflowAccessToRepositoryResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsSetWorkflowAccessToRepositoryResponse{}, nil
}

// actionsSetWorkflowAccessToRepositoryCreateRequest creates the ActionsSetWorkflowAccessToRepository request.
func (client *GitHubV3RESTAPIClient) actionsSetWorkflowAccessToRepositoryCreateRequest(ctx context.Context, body ActionsWorkflowAccessToRepository, options *GitHubV3RESTAPIClientActionsSetWorkflowAccessToRepositoryOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/permissions/access"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// ActionsUpdateEnvironmentVariable - Updates an environment variable that you can reference in a GitHub Actions workflow.
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the
// environment:write repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsUpdateEnvironmentVariableOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsUpdateEnvironmentVariable
//     method.
func (client *GitHubV3RESTAPIClient) ActionsUpdateEnvironmentVariable(ctx context.Context, body Paths1OnljmgRepositoriesRepositoryIDEnvironmentsEnvironmentNameVariablesNamePatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsUpdateEnvironmentVariableOptions) (GitHubV3RESTAPIClientActionsUpdateEnvironmentVariableResponse, error) {
	req, err := client.actionsUpdateEnvironmentVariableCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsUpdateEnvironmentVariableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsUpdateEnvironmentVariableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsUpdateEnvironmentVariableResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsUpdateEnvironmentVariableResponse{}, nil
}

// actionsUpdateEnvironmentVariableCreateRequest creates the ActionsUpdateEnvironmentVariable request.
func (client *GitHubV3RESTAPIClient) actionsUpdateEnvironmentVariableCreateRequest(ctx context.Context, body Paths1OnljmgRepositoriesRepositoryIDEnvironmentsEnvironmentNameVariablesNamePatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsUpdateEnvironmentVariableOptions) (*policy.Request, error) {
	urlPath := "/repositories/{repository_id}/environments/{environment_name}/variables/{name}"
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	if client.name == "" {
		return nil, errors.New("parameter client.name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(client.name))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// ActionsUpdateOrgVariable - Updates an organization variable that you can reference in a GitHub Actions workflow. You must
// authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must have
// the organizationactionsvariables:write organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsUpdateOrgVariableOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsUpdateOrgVariable
//     method.
func (client *GitHubV3RESTAPIClient) ActionsUpdateOrgVariable(ctx context.Context, body Paths1Phxf31OrgsOrgActionsVariablesNamePatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsUpdateOrgVariableOptions) (GitHubV3RESTAPIClientActionsUpdateOrgVariableResponse, error) {
	req, err := client.actionsUpdateOrgVariableCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsUpdateOrgVariableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsUpdateOrgVariableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsUpdateOrgVariableResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsUpdateOrgVariableResponse{}, nil
}

// actionsUpdateOrgVariableCreateRequest creates the ActionsUpdateOrgVariable request.
func (client *GitHubV3RESTAPIClient) actionsUpdateOrgVariableCreateRequest(ctx context.Context, body Paths1Phxf31OrgsOrgActionsVariablesNamePatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsUpdateOrgVariableOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/variables/{name}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.name == "" {
		return nil, errors.New("parameter client.name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(client.name))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// ActionsUpdateRepoVariable - Updates a repository variable that you can reference in a GitHub Actions workflow. You must
// authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the
// actions_variables:write repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsUpdateRepoVariableOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsUpdateRepoVariable
//     method.
func (client *GitHubV3RESTAPIClient) ActionsUpdateRepoVariable(ctx context.Context, body PathsEwomnfReposOwnerRepoActionsVariablesNamePatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsUpdateRepoVariableOptions) (GitHubV3RESTAPIClientActionsUpdateRepoVariableResponse, error) {
	req, err := client.actionsUpdateRepoVariableCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsUpdateRepoVariableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsUpdateRepoVariableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActionsUpdateRepoVariableResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActionsUpdateRepoVariableResponse{}, nil
}

// actionsUpdateRepoVariableCreateRequest creates the ActionsUpdateRepoVariable request.
func (client *GitHubV3RESTAPIClient) actionsUpdateRepoVariableCreateRequest(ctx context.Context, body PathsEwomnfReposOwnerRepoActionsVariablesNamePatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsUpdateRepoVariableOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/actions/variables/{name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.name == "" {
		return nil, errors.New("parameter client.name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(client.name))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// ActionsUpdateRequiredWorkflow - Update a required workflow in an organization.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// For more information, see "Required Workflows [https://docs.github.com/actions/using-workflows/required-workflows]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActionsUpdateRequiredWorkflowOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActionsUpdateRequiredWorkflow
//     method.
func (client *GitHubV3RESTAPIClient) ActionsUpdateRequiredWorkflow(ctx context.Context, body Paths118P0LvOrgsOrgActionsRequiredWorkflowsRequiredWorkflowIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsUpdateRequiredWorkflowOptions) (GitHubV3RESTAPIClientActionsUpdateRequiredWorkflowResponse, error) {
	req, err := client.actionsUpdateRequiredWorkflowCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActionsUpdateRequiredWorkflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActionsUpdateRequiredWorkflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientActionsUpdateRequiredWorkflowResponse{}, runtime.NewResponseError(resp)
	}
	return client.actionsUpdateRequiredWorkflowHandleResponse(resp)
}

// actionsUpdateRequiredWorkflowCreateRequest creates the ActionsUpdateRequiredWorkflow request.
func (client *GitHubV3RESTAPIClient) actionsUpdateRequiredWorkflowCreateRequest(ctx context.Context, body Paths118P0LvOrgsOrgActionsRequiredWorkflowsRequiredWorkflowIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActionsUpdateRequiredWorkflowOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/required_workflows/{required_workflow_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{required_workflow_id}", url.PathEscape(strconv.FormatInt(int64(client.requiredWorkflowID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// actionsUpdateRequiredWorkflowHandleResponse handles the ActionsUpdateRequiredWorkflow response.
func (client *GitHubV3RESTAPIClient) actionsUpdateRequiredWorkflowHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActionsUpdateRequiredWorkflowResponse, error) {
	result := GitHubV3RESTAPIClientActionsUpdateRequiredWorkflowResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val RequiredWorkflow
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsUpdateRequiredWorkflowResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActionsUpdateRequiredWorkflowResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActionsUpdateRequiredWorkflowResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActivityCheckRepoIsStarredByAuthenticatedUser - Check if a repository is starred by the authenticated user
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityCheckRepoIsStarredByAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.ActivityCheckRepoIsStarredByAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) ActivityCheckRepoIsStarredByAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientActivityCheckRepoIsStarredByAuthenticatedUserOptions) (GitHubV3RESTAPIClientActivityCheckRepoIsStarredByAuthenticatedUserResponse, error) {
	req, err := client.activityCheckRepoIsStarredByAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityCheckRepoIsStarredByAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityCheckRepoIsStarredByAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientActivityCheckRepoIsStarredByAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityCheckRepoIsStarredByAuthenticatedUserHandleResponse(resp)
}

// activityCheckRepoIsStarredByAuthenticatedUserCreateRequest creates the ActivityCheckRepoIsStarredByAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) activityCheckRepoIsStarredByAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityCheckRepoIsStarredByAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/starred/{owner}/{repo}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityCheckRepoIsStarredByAuthenticatedUserHandleResponse handles the ActivityCheckRepoIsStarredByAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) activityCheckRepoIsStarredByAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityCheckRepoIsStarredByAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientActivityCheckRepoIsStarredByAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientActivityCheckRepoIsStarredByAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// ActivityDeleteRepoSubscription - This endpoint should only be used to stop watching a repository. To control whether or
// not you wish to receive notifications from a repository, set the repository's subscription manually
// [https://docs.github.com/rest/reference/activity#set-a-repository-subscription].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityDeleteRepoSubscriptionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityDeleteRepoSubscription
//     method.
func (client *GitHubV3RESTAPIClient) ActivityDeleteRepoSubscription(ctx context.Context, options *GitHubV3RESTAPIClientActivityDeleteRepoSubscriptionOptions) (GitHubV3RESTAPIClientActivityDeleteRepoSubscriptionResponse, error) {
	req, err := client.activityDeleteRepoSubscriptionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityDeleteRepoSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityDeleteRepoSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientActivityDeleteRepoSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientActivityDeleteRepoSubscriptionResponse{}, nil
}

// activityDeleteRepoSubscriptionCreateRequest creates the ActivityDeleteRepoSubscription request.
func (client *GitHubV3RESTAPIClient) activityDeleteRepoSubscriptionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityDeleteRepoSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/subscription"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ActivityDeleteThreadSubscription - Mutes all future notifications for a conversation until you comment on the thread or
// get an @mention. If you are watching the repository of the thread, you will still receive notifications. To ignore
// future notifications for a repository you are watching, use the Set a thread subscription [https://docs.github.com/rest/reference/activity#set-a-thread-subscription]
// endpoint and set ignore to true.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityDeleteThreadSubscriptionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityDeleteThreadSubscription
//     method.
func (client *GitHubV3RESTAPIClient) ActivityDeleteThreadSubscription(ctx context.Context, options *GitHubV3RESTAPIClientActivityDeleteThreadSubscriptionOptions) (GitHubV3RESTAPIClientActivityDeleteThreadSubscriptionResponse, error) {
	req, err := client.activityDeleteThreadSubscriptionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityDeleteThreadSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityDeleteThreadSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientActivityDeleteThreadSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityDeleteThreadSubscriptionHandleResponse(resp)
}

// activityDeleteThreadSubscriptionCreateRequest creates the ActivityDeleteThreadSubscription request.
func (client *GitHubV3RESTAPIClient) activityDeleteThreadSubscriptionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityDeleteThreadSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/notifications/threads/{thread_id}/subscription"
	urlPath = strings.ReplaceAll(urlPath, "{thread_id}", url.PathEscape(strconv.FormatInt(int64(client.threadID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityDeleteThreadSubscriptionHandleResponse handles the ActivityDeleteThreadSubscription response.
func (client *GitHubV3RESTAPIClient) activityDeleteThreadSubscriptionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityDeleteThreadSubscriptionResponse, error) {
	result := GitHubV3RESTAPIClientActivityDeleteThreadSubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientActivityDeleteThreadSubscriptionResponse{}, err
	}
	return result, nil
}

// ActivityGetFeeds - GitHub provides several timeline resources in Atom [http://en.wikipedia.org/wiki/Atom_(standard)] format.
// The Feeds API lists all the feeds available to the authenticated user:
// * Timeline: The GitHub global public timeline
// * User: The public timeline for any user, using URI template [https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia]
// * Current user public: The public timeline for the authenticated user
// * Current user: The private timeline for the authenticated user
// * Current user actor: The private timeline for activity created by the authenticated user
// * Current user organizations: The private timeline for the organizations the authenticated user is a member of.
// * Security advisories: A collection of public announcements that provide information about security-related vulnerabilities
// in software on GitHub.
// Note: Private feeds are only returned when authenticating via Basic Auth [https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication]
// since current feed URIs use the
// older, non revocable auth tokens.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityGetFeedsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityGetFeeds
//     method.
func (client *GitHubV3RESTAPIClient) ActivityGetFeeds(ctx context.Context, options *GitHubV3RESTAPIClientActivityGetFeedsOptions) (GitHubV3RESTAPIClientActivityGetFeedsResponse, error) {
	req, err := client.activityGetFeedsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityGetFeedsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityGetFeedsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActivityGetFeedsResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityGetFeedsHandleResponse(resp)
}

// activityGetFeedsCreateRequest creates the ActivityGetFeeds request.
func (client *GitHubV3RESTAPIClient) activityGetFeedsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityGetFeedsOptions) (*policy.Request, error) {
	urlPath := "/feeds"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityGetFeedsHandleResponse handles the ActivityGetFeeds response.
func (client *GitHubV3RESTAPIClient) activityGetFeedsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityGetFeedsResponse, error) {
	result := GitHubV3RESTAPIClientActivityGetFeedsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Feed); err != nil {
		return GitHubV3RESTAPIClientActivityGetFeedsResponse{}, err
	}
	return result, nil
}

// ActivityGetRepoSubscription - Get a repository subscription
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityGetRepoSubscriptionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityGetRepoSubscription
//     method.
func (client *GitHubV3RESTAPIClient) ActivityGetRepoSubscription(ctx context.Context, options *GitHubV3RESTAPIClientActivityGetRepoSubscriptionOptions) (GitHubV3RESTAPIClientActivityGetRepoSubscriptionResponse, error) {
	req, err := client.activityGetRepoSubscriptionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityGetRepoSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityGetRepoSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientActivityGetRepoSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityGetRepoSubscriptionHandleResponse(resp)
}

// activityGetRepoSubscriptionCreateRequest creates the ActivityGetRepoSubscription request.
func (client *GitHubV3RESTAPIClient) activityGetRepoSubscriptionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityGetRepoSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/subscription"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityGetRepoSubscriptionHandleResponse handles the ActivityGetRepoSubscription response.
func (client *GitHubV3RESTAPIClient) activityGetRepoSubscriptionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityGetRepoSubscriptionResponse, error) {
	result := GitHubV3RESTAPIClientActivityGetRepoSubscriptionResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val RepositorySubscription
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityGetRepoSubscriptionResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityGetRepoSubscriptionResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	default:
		return GitHubV3RESTAPIClientActivityGetRepoSubscriptionResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActivityGetThread - Gets information about a notification thread.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityGetThreadOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityGetThread
//     method.
func (client *GitHubV3RESTAPIClient) ActivityGetThread(ctx context.Context, options *GitHubV3RESTAPIClientActivityGetThreadOptions) (GitHubV3RESTAPIClientActivityGetThreadResponse, error) {
	req, err := client.activityGetThreadCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityGetThreadResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityGetThreadResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientActivityGetThreadResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityGetThreadHandleResponse(resp)
}

// activityGetThreadCreateRequest creates the ActivityGetThread request.
func (client *GitHubV3RESTAPIClient) activityGetThreadCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityGetThreadOptions) (*policy.Request, error) {
	urlPath := "/notifications/threads/{thread_id}"
	urlPath = strings.ReplaceAll(urlPath, "{thread_id}", url.PathEscape(strconv.FormatInt(int64(client.threadID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityGetThreadHandleResponse handles the ActivityGetThread response.
func (client *GitHubV3RESTAPIClient) activityGetThreadHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityGetThreadResponse, error) {
	result := GitHubV3RESTAPIClientActivityGetThreadResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Thread
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityGetThreadResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityGetThreadResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityGetThreadResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActivityGetThreadResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActivityGetThreadSubscriptionForAuthenticatedUser - This checks to see if the current user is subscribed to a thread. You
// can also get a repository subscription [https://docs.github.com/rest/reference/activity#get-a-repository-subscription].
// Note that subscriptions are only generated if a user is participating in a conversation--for example, they've replied to
// the thread, were @mentioned, or manually subscribe to a thread.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityGetThreadSubscriptionForAuthenticatedUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.ActivityGetThreadSubscriptionForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) ActivityGetThreadSubscriptionForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientActivityGetThreadSubscriptionForAuthenticatedUserOptions) (GitHubV3RESTAPIClientActivityGetThreadSubscriptionForAuthenticatedUserResponse, error) {
	req, err := client.activityGetThreadSubscriptionForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityGetThreadSubscriptionForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityGetThreadSubscriptionForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientActivityGetThreadSubscriptionForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityGetThreadSubscriptionForAuthenticatedUserHandleResponse(resp)
}

// activityGetThreadSubscriptionForAuthenticatedUserCreateRequest creates the ActivityGetThreadSubscriptionForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) activityGetThreadSubscriptionForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityGetThreadSubscriptionForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/notifications/threads/{thread_id}/subscription"
	urlPath = strings.ReplaceAll(urlPath, "{thread_id}", url.PathEscape(strconv.FormatInt(int64(client.threadID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityGetThreadSubscriptionForAuthenticatedUserHandleResponse handles the ActivityGetThreadSubscriptionForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) activityGetThreadSubscriptionForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityGetThreadSubscriptionForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientActivityGetThreadSubscriptionForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ThreadSubscription
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityGetThreadSubscriptionForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityGetThreadSubscriptionForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityGetThreadSubscriptionForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActivityGetThreadSubscriptionForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActivityListEventsForAuthenticatedUser - If you are authenticated as the given user, you will see your private events.
// Otherwise, you'll only see public events.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListEventsForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityListEventsForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) ActivityListEventsForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientActivityListEventsForAuthenticatedUserOptions) (GitHubV3RESTAPIClientActivityListEventsForAuthenticatedUserResponse, error) {
	req, err := client.activityListEventsForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListEventsForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListEventsForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActivityListEventsForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListEventsForAuthenticatedUserHandleResponse(resp)
}

// activityListEventsForAuthenticatedUserCreateRequest creates the ActivityListEventsForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) activityListEventsForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListEventsForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/events"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityListEventsForAuthenticatedUserHandleResponse handles the ActivityListEventsForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) activityListEventsForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListEventsForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientActivityListEventsForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.EventArray); err != nil {
		return GitHubV3RESTAPIClientActivityListEventsForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// ActivityListNotificationsForAuthenticatedUser - List all notifications for the current user, sorted by most recently updated.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListNotificationsForAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.ActivityListNotificationsForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) ActivityListNotificationsForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientActivityListNotificationsForAuthenticatedUserOptions) (GitHubV3RESTAPIClientActivityListNotificationsForAuthenticatedUserResponse, error) {
	req, err := client.activityListNotificationsForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListNotificationsForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListNotificationsForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientActivityListNotificationsForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListNotificationsForAuthenticatedUserHandleResponse(resp)
}

// activityListNotificationsForAuthenticatedUserCreateRequest creates the ActivityListNotificationsForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) activityListNotificationsForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListNotificationsForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/notifications"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.all != nil {
		reqQP.Set("all", strconv.FormatBool(*client.all))
	}
	if client.participating != nil {
		reqQP.Set("participating", strconv.FormatBool(*client.participating))
	}
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if client.before != nil {
		reqQP.Set("before", *client.before)
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if options != nil && options.PerPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*options.PerPage), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityListNotificationsForAuthenticatedUserHandleResponse handles the ActivityListNotificationsForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) activityListNotificationsForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListNotificationsForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientActivityListNotificationsForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Thread
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListNotificationsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListNotificationsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListNotificationsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListNotificationsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActivityListNotificationsForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActivityListOrgEventsForAuthenticatedUser - This is the user's organization dashboard. You must be authenticated as the
// user to view this.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListOrgEventsForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ActivityListOrgEventsForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) ActivityListOrgEventsForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientActivityListOrgEventsForAuthenticatedUserOptions) (GitHubV3RESTAPIClientActivityListOrgEventsForAuthenticatedUserResponse, error) {
	req, err := client.activityListOrgEventsForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListOrgEventsForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListOrgEventsForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActivityListOrgEventsForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListOrgEventsForAuthenticatedUserHandleResponse(resp)
}

// activityListOrgEventsForAuthenticatedUserCreateRequest creates the ActivityListOrgEventsForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) activityListOrgEventsForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListOrgEventsForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/events/orgs/{org}"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityListOrgEventsForAuthenticatedUserHandleResponse handles the ActivityListOrgEventsForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) activityListOrgEventsForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListOrgEventsForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientActivityListOrgEventsForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.EventArray); err != nil {
		return GitHubV3RESTAPIClientActivityListOrgEventsForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// ActivityListPublicEvents - We delay the public events feed by five minutes, which means the most recent event returned
// by the public events API actually occurred at least five minutes ago.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListPublicEventsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityListPublicEvents
//     method.
func (client *GitHubV3RESTAPIClient) ActivityListPublicEvents(ctx context.Context, options *GitHubV3RESTAPIClientActivityListPublicEventsOptions) (GitHubV3RESTAPIClientActivityListPublicEventsResponse, error) {
	req, err := client.activityListPublicEventsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListPublicEventsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListPublicEventsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientActivityListPublicEventsResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListPublicEventsHandleResponse(resp)
}

// activityListPublicEventsCreateRequest creates the ActivityListPublicEvents request.
func (client *GitHubV3RESTAPIClient) activityListPublicEventsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListPublicEventsOptions) (*policy.Request, error) {
	urlPath := "/events"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityListPublicEventsHandleResponse handles the ActivityListPublicEvents response.
func (client *GitHubV3RESTAPIClient) activityListPublicEventsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListPublicEventsResponse, error) {
	result := GitHubV3RESTAPIClientActivityListPublicEventsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Event
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListPublicEventsResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListPublicEventsResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListPublicEventsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActivityListPublicEventsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActivityListPublicEventsForRepoNetwork - List public events for a network of repositories
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListPublicEventsForRepoNetworkOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityListPublicEventsForRepoNetwork
//     method.
func (client *GitHubV3RESTAPIClient) ActivityListPublicEventsForRepoNetwork(ctx context.Context, options *GitHubV3RESTAPIClientActivityListPublicEventsForRepoNetworkOptions) (GitHubV3RESTAPIClientActivityListPublicEventsForRepoNetworkResponse, error) {
	req, err := client.activityListPublicEventsForRepoNetworkCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListPublicEventsForRepoNetworkResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListPublicEventsForRepoNetworkResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientActivityListPublicEventsForRepoNetworkResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListPublicEventsForRepoNetworkHandleResponse(resp)
}

// activityListPublicEventsForRepoNetworkCreateRequest creates the ActivityListPublicEventsForRepoNetwork request.
func (client *GitHubV3RESTAPIClient) activityListPublicEventsForRepoNetworkCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListPublicEventsForRepoNetworkOptions) (*policy.Request, error) {
	urlPath := "/networks/{owner}/{repo}/events"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityListPublicEventsForRepoNetworkHandleResponse handles the ActivityListPublicEventsForRepoNetwork response.
func (client *GitHubV3RESTAPIClient) activityListPublicEventsForRepoNetworkHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListPublicEventsForRepoNetworkResponse, error) {
	result := GitHubV3RESTAPIClientActivityListPublicEventsForRepoNetworkResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Event
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListPublicEventsForRepoNetworkResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListPublicEventsForRepoNetworkResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListPublicEventsForRepoNetworkResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActivityListPublicEventsForRepoNetworkResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActivityListPublicEventsForUser - List public events for a user
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListPublicEventsForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityListPublicEventsForUser
//     method.
func (client *GitHubV3RESTAPIClient) ActivityListPublicEventsForUser(ctx context.Context, options *GitHubV3RESTAPIClientActivityListPublicEventsForUserOptions) (GitHubV3RESTAPIClientActivityListPublicEventsForUserResponse, error) {
	req, err := client.activityListPublicEventsForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListPublicEventsForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListPublicEventsForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActivityListPublicEventsForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListPublicEventsForUserHandleResponse(resp)
}

// activityListPublicEventsForUserCreateRequest creates the ActivityListPublicEventsForUser request.
func (client *GitHubV3RESTAPIClient) activityListPublicEventsForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListPublicEventsForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/events/public"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityListPublicEventsForUserHandleResponse handles the ActivityListPublicEventsForUser response.
func (client *GitHubV3RESTAPIClient) activityListPublicEventsForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListPublicEventsForUserResponse, error) {
	result := GitHubV3RESTAPIClientActivityListPublicEventsForUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.EventArray); err != nil {
		return GitHubV3RESTAPIClientActivityListPublicEventsForUserResponse{}, err
	}
	return result, nil
}

// ActivityListPublicOrgEvents - List public organization events
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListPublicOrgEventsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityListPublicOrgEvents
//     method.
func (client *GitHubV3RESTAPIClient) ActivityListPublicOrgEvents(ctx context.Context, options *GitHubV3RESTAPIClientActivityListPublicOrgEventsOptions) (GitHubV3RESTAPIClientActivityListPublicOrgEventsResponse, error) {
	req, err := client.activityListPublicOrgEventsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListPublicOrgEventsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListPublicOrgEventsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActivityListPublicOrgEventsResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListPublicOrgEventsHandleResponse(resp)
}

// activityListPublicOrgEventsCreateRequest creates the ActivityListPublicOrgEvents request.
func (client *GitHubV3RESTAPIClient) activityListPublicOrgEventsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListPublicOrgEventsOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/events"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityListPublicOrgEventsHandleResponse handles the ActivityListPublicOrgEvents response.
func (client *GitHubV3RESTAPIClient) activityListPublicOrgEventsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListPublicOrgEventsResponse, error) {
	result := GitHubV3RESTAPIClientActivityListPublicOrgEventsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.EventArray); err != nil {
		return GitHubV3RESTAPIClientActivityListPublicOrgEventsResponse{}, err
	}
	return result, nil
}

// ActivityListReceivedEventsForUser - These are events that you've received by watching repos and following users. If you
// are authenticated as the given user, you will see private events. Otherwise, you'll only see public events.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListReceivedEventsForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityListReceivedEventsForUser
//     method.
func (client *GitHubV3RESTAPIClient) ActivityListReceivedEventsForUser(ctx context.Context, options *GitHubV3RESTAPIClientActivityListReceivedEventsForUserOptions) (GitHubV3RESTAPIClientActivityListReceivedEventsForUserResponse, error) {
	req, err := client.activityListReceivedEventsForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListReceivedEventsForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListReceivedEventsForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActivityListReceivedEventsForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListReceivedEventsForUserHandleResponse(resp)
}

// activityListReceivedEventsForUserCreateRequest creates the ActivityListReceivedEventsForUser request.
func (client *GitHubV3RESTAPIClient) activityListReceivedEventsForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListReceivedEventsForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/received_events"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityListReceivedEventsForUserHandleResponse handles the ActivityListReceivedEventsForUser response.
func (client *GitHubV3RESTAPIClient) activityListReceivedEventsForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListReceivedEventsForUserResponse, error) {
	result := GitHubV3RESTAPIClientActivityListReceivedEventsForUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.EventArray); err != nil {
		return GitHubV3RESTAPIClientActivityListReceivedEventsForUserResponse{}, err
	}
	return result, nil
}

// ActivityListReceivedPublicEventsForUser - List public events received by a user
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListReceivedPublicEventsForUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ActivityListReceivedPublicEventsForUser method.
func (client *GitHubV3RESTAPIClient) ActivityListReceivedPublicEventsForUser(ctx context.Context, options *GitHubV3RESTAPIClientActivityListReceivedPublicEventsForUserOptions) (GitHubV3RESTAPIClientActivityListReceivedPublicEventsForUserResponse, error) {
	req, err := client.activityListReceivedPublicEventsForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListReceivedPublicEventsForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListReceivedPublicEventsForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActivityListReceivedPublicEventsForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListReceivedPublicEventsForUserHandleResponse(resp)
}

// activityListReceivedPublicEventsForUserCreateRequest creates the ActivityListReceivedPublicEventsForUser request.
func (client *GitHubV3RESTAPIClient) activityListReceivedPublicEventsForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListReceivedPublicEventsForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/received_events/public"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityListReceivedPublicEventsForUserHandleResponse handles the ActivityListReceivedPublicEventsForUser response.
func (client *GitHubV3RESTAPIClient) activityListReceivedPublicEventsForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListReceivedPublicEventsForUserResponse, error) {
	result := GitHubV3RESTAPIClientActivityListReceivedPublicEventsForUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.EventArray); err != nil {
		return GitHubV3RESTAPIClientActivityListReceivedPublicEventsForUserResponse{}, err
	}
	return result, nil
}

// ActivityListRepoEvents - List repository events
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListRepoEventsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityListRepoEvents
//     method.
func (client *GitHubV3RESTAPIClient) ActivityListRepoEvents(ctx context.Context, options *GitHubV3RESTAPIClientActivityListRepoEventsOptions) (GitHubV3RESTAPIClientActivityListRepoEventsResponse, error) {
	req, err := client.activityListRepoEventsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListRepoEventsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListRepoEventsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActivityListRepoEventsResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListRepoEventsHandleResponse(resp)
}

// activityListRepoEventsCreateRequest creates the ActivityListRepoEvents request.
func (client *GitHubV3RESTAPIClient) activityListRepoEventsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListRepoEventsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/events"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityListRepoEventsHandleResponse handles the ActivityListRepoEvents response.
func (client *GitHubV3RESTAPIClient) activityListRepoEventsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListRepoEventsResponse, error) {
	result := GitHubV3RESTAPIClientActivityListRepoEventsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.EventArray); err != nil {
		return GitHubV3RESTAPIClientActivityListRepoEventsResponse{}, err
	}
	return result, nil
}

// ActivityListRepoNotificationsForAuthenticatedUser - Lists all notifications for the current user in the specified repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListRepoNotificationsForAuthenticatedUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.ActivityListRepoNotificationsForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) ActivityListRepoNotificationsForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientActivityListRepoNotificationsForAuthenticatedUserOptions) (GitHubV3RESTAPIClientActivityListRepoNotificationsForAuthenticatedUserResponse, error) {
	req, err := client.activityListRepoNotificationsForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListRepoNotificationsForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListRepoNotificationsForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActivityListRepoNotificationsForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListRepoNotificationsForAuthenticatedUserHandleResponse(resp)
}

// activityListRepoNotificationsForAuthenticatedUserCreateRequest creates the ActivityListRepoNotificationsForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) activityListRepoNotificationsForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListRepoNotificationsForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/notifications"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.all != nil {
		reqQP.Set("all", strconv.FormatBool(*client.all))
	}
	if client.participating != nil {
		reqQP.Set("participating", strconv.FormatBool(*client.participating))
	}
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if client.before != nil {
		reqQP.Set("before", *client.before)
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityListRepoNotificationsForAuthenticatedUserHandleResponse handles the ActivityListRepoNotificationsForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) activityListRepoNotificationsForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListRepoNotificationsForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientActivityListRepoNotificationsForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ThreadArray); err != nil {
		return GitHubV3RESTAPIClientActivityListRepoNotificationsForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// ActivityListReposStarredByAuthenticatedUser - Lists repositories the authenticated user has starred.
// You can also find out when stars were created by passing the following custom media type [https://docs.github.com/rest/overview/media-types/]
// via the Accept header: application/vnd.github.star+json.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListReposStarredByAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.ActivityListReposStarredByAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) ActivityListReposStarredByAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientActivityListReposStarredByAuthenticatedUserOptions) (GitHubV3RESTAPIClientActivityListReposStarredByAuthenticatedUserResponse, error) {
	req, err := client.activityListReposStarredByAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListReposStarredByAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListReposStarredByAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientActivityListReposStarredByAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListReposStarredByAuthenticatedUserHandleResponse(resp)
}

// activityListReposStarredByAuthenticatedUserCreateRequest creates the ActivityListReposStarredByAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) activityListReposStarredByAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListReposStarredByAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/starred"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.sortParam != nil {
		reqQP.Set("sort", string(*client.sortParam))
	}
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json, application/vnd.github.v3.star+json"}
	return req, nil
}

// activityListReposStarredByAuthenticatedUserHandleResponse handles the ActivityListReposStarredByAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) activityListReposStarredByAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListReposStarredByAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientActivityListReposStarredByAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Repository
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListReposStarredByAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListReposStarredByAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListReposStarredByAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActivityListReposStarredByAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActivityListReposStarredByUser - Lists repositories a user has starred.
// You can also find out when stars were created by passing the following custom media type [https://docs.github.com/rest/overview/media-types/]
// via the Accept header: application/vnd.github.star+json.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListReposStarredByUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityListReposStarredByUser
//     method.
func (client *GitHubV3RESTAPIClient) ActivityListReposStarredByUser(ctx context.Context, options *GitHubV3RESTAPIClientActivityListReposStarredByUserOptions) (GitHubV3RESTAPIClientActivityListReposStarredByUserResponse, error) {
	req, err := client.activityListReposStarredByUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListReposStarredByUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListReposStarredByUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActivityListReposStarredByUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListReposStarredByUserHandleResponse(resp)
}

// activityListReposStarredByUserCreateRequest creates the ActivityListReposStarredByUser request.
func (client *GitHubV3RESTAPIClient) activityListReposStarredByUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListReposStarredByUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/starred"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.sortParam != nil {
		reqQP.Set("sort", string(*client.sortParam))
	}
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityListReposStarredByUserHandleResponse handles the ActivityListReposStarredByUser response.
func (client *GitHubV3RESTAPIClient) activityListReposStarredByUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListReposStarredByUserResponse, error) {
	result := GitHubV3RESTAPIClientActivityListReposStarredByUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsMarvfxUsersUsernameStarredGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActivityListReposStarredByUserResponse{}, err
	}
	return result, nil
}

// ActivityListReposWatchedByUser - Lists repositories a user is watching.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListReposWatchedByUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityListReposWatchedByUser
//     method.
func (client *GitHubV3RESTAPIClient) ActivityListReposWatchedByUser(ctx context.Context, options *GitHubV3RESTAPIClientActivityListReposWatchedByUserOptions) (GitHubV3RESTAPIClientActivityListReposWatchedByUserResponse, error) {
	req, err := client.activityListReposWatchedByUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListReposWatchedByUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListReposWatchedByUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActivityListReposWatchedByUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListReposWatchedByUserHandleResponse(resp)
}

// activityListReposWatchedByUserCreateRequest creates the ActivityListReposWatchedByUser request.
func (client *GitHubV3RESTAPIClient) activityListReposWatchedByUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListReposWatchedByUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/subscriptions"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityListReposWatchedByUserHandleResponse handles the ActivityListReposWatchedByUser response.
func (client *GitHubV3RESTAPIClient) activityListReposWatchedByUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListReposWatchedByUserResponse, error) {
	result := GitHubV3RESTAPIClientActivityListReposWatchedByUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.MinimalRepositoryArray); err != nil {
		return GitHubV3RESTAPIClientActivityListReposWatchedByUserResponse{}, err
	}
	return result, nil
}

// ActivityListStargazersForRepo - Lists the people that have starred the repository.
// You can also find out when stars were created by passing the following custom media type [https://docs.github.com/rest/overview/media-types/]
// via the Accept header: application/vnd.github.star+json.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListStargazersForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityListStargazersForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ActivityListStargazersForRepo(ctx context.Context, options *GitHubV3RESTAPIClientActivityListStargazersForRepoOptions) (GitHubV3RESTAPIClientActivityListStargazersForRepoResponse, error) {
	req, err := client.activityListStargazersForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListStargazersForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListStargazersForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientActivityListStargazersForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListStargazersForRepoHandleResponse(resp)
}

// activityListStargazersForRepoCreateRequest creates the ActivityListStargazersForRepo request.
func (client *GitHubV3RESTAPIClient) activityListStargazersForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListStargazersForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/stargazers"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityListStargazersForRepoHandleResponse handles the ActivityListStargazersForRepo response.
func (client *GitHubV3RESTAPIClient) activityListStargazersForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListStargazersForRepoResponse, error) {
	result := GitHubV3RESTAPIClientActivityListStargazersForRepoResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Paths1Ib8ZziReposOwnerRepoStargazersGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListStargazersForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListStargazersForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActivityListStargazersForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActivityListWatchedReposForAuthenticatedUser - Lists repositories the authenticated user is watching.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListWatchedReposForAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.ActivityListWatchedReposForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) ActivityListWatchedReposForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientActivityListWatchedReposForAuthenticatedUserOptions) (GitHubV3RESTAPIClientActivityListWatchedReposForAuthenticatedUserResponse, error) {
	req, err := client.activityListWatchedReposForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListWatchedReposForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListWatchedReposForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientActivityListWatchedReposForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListWatchedReposForAuthenticatedUserHandleResponse(resp)
}

// activityListWatchedReposForAuthenticatedUserCreateRequest creates the ActivityListWatchedReposForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) activityListWatchedReposForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListWatchedReposForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/subscriptions"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityListWatchedReposForAuthenticatedUserHandleResponse handles the ActivityListWatchedReposForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) activityListWatchedReposForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListWatchedReposForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientActivityListWatchedReposForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*MinimalRepository
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListWatchedReposForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListWatchedReposForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityListWatchedReposForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActivityListWatchedReposForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActivityListWatchersForRepo - Lists the people watching the specified repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityListWatchersForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityListWatchersForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ActivityListWatchersForRepo(ctx context.Context, options *GitHubV3RESTAPIClientActivityListWatchersForRepoOptions) (GitHubV3RESTAPIClientActivityListWatchersForRepoResponse, error) {
	req, err := client.activityListWatchersForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListWatchersForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityListWatchersForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActivityListWatchersForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityListWatchersForRepoHandleResponse(resp)
}

// activityListWatchersForRepoCreateRequest creates the ActivityListWatchersForRepo request.
func (client *GitHubV3RESTAPIClient) activityListWatchersForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityListWatchersForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/subscribers"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityListWatchersForRepoHandleResponse handles the ActivityListWatchersForRepo response.
func (client *GitHubV3RESTAPIClient) activityListWatchersForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityListWatchersForRepoResponse, error) {
	result := GitHubV3RESTAPIClientActivityListWatchersForRepoResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.SimpleUserArray); err != nil {
		return GitHubV3RESTAPIClientActivityListWatchersForRepoResponse{}, err
	}
	return result, nil
}

// ActivityMarkNotificationsAsRead - Marks all notifications as "read" for the current user. If the number of notifications
// is too large to complete in one request, you will receive a 202 Accepted status and GitHub will run an
// asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the
// List notifications for the authenticated user
// [https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user] endpoint and pass the query
// parameter all=false.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityMarkNotificationsAsReadOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityMarkNotificationsAsRead
//     method.
func (client *GitHubV3RESTAPIClient) ActivityMarkNotificationsAsRead(ctx context.Context, body PathsLawabgNotificationsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActivityMarkNotificationsAsReadOptions) (GitHubV3RESTAPIClientActivityMarkNotificationsAsReadResponse, error) {
	req, err := client.activityMarkNotificationsAsReadCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityMarkNotificationsAsReadResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityMarkNotificationsAsReadResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusResetContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientActivityMarkNotificationsAsReadResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityMarkNotificationsAsReadHandleResponse(resp)
}

// activityMarkNotificationsAsReadCreateRequest creates the ActivityMarkNotificationsAsRead request.
func (client *GitHubV3RESTAPIClient) activityMarkNotificationsAsReadCreateRequest(ctx context.Context, body PathsLawabgNotificationsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActivityMarkNotificationsAsReadOptions) (*policy.Request, error) {
	urlPath := "/notifications"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// activityMarkNotificationsAsReadHandleResponse handles the ActivityMarkNotificationsAsRead response.
func (client *GitHubV3RESTAPIClient) activityMarkNotificationsAsReadHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityMarkNotificationsAsReadResponse, error) {
	result := GitHubV3RESTAPIClientActivityMarkNotificationsAsReadResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val Paths17VlsfoNotificationsPutResponses202ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityMarkNotificationsAsReadResponse{}, err
	}
	result.Value = val
	case http.StatusResetContent:
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityMarkNotificationsAsReadResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivityMarkNotificationsAsReadResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActivityMarkNotificationsAsReadResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActivityMarkRepoNotificationsAsRead - Marks all notifications in a repository as "read" for the current user. If the number
// of notifications is too large to complete in one request, you will receive a 202 Accepted status and GitHub will
// run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can
// use the List repository notifications for the authenticated user
// [https://docs.github.com/rest/reference/activity#list-repository-notifications-for-the-authenticated-user] endpoint and
// pass the query parameter all=false.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityMarkRepoNotificationsAsReadOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityMarkRepoNotificationsAsRead
//     method.
func (client *GitHubV3RESTAPIClient) ActivityMarkRepoNotificationsAsRead(ctx context.Context, body Paths14Fjsy0ReposOwnerRepoNotificationsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActivityMarkRepoNotificationsAsReadOptions) (GitHubV3RESTAPIClientActivityMarkRepoNotificationsAsReadResponse, error) {
	req, err := client.activityMarkRepoNotificationsAsReadCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityMarkRepoNotificationsAsReadResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityMarkRepoNotificationsAsReadResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusResetContent) {
		return GitHubV3RESTAPIClientActivityMarkRepoNotificationsAsReadResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityMarkRepoNotificationsAsReadHandleResponse(resp)
}

// activityMarkRepoNotificationsAsReadCreateRequest creates the ActivityMarkRepoNotificationsAsRead request.
func (client *GitHubV3RESTAPIClient) activityMarkRepoNotificationsAsReadCreateRequest(ctx context.Context, body Paths14Fjsy0ReposOwnerRepoNotificationsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActivityMarkRepoNotificationsAsReadOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/notifications"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// activityMarkRepoNotificationsAsReadHandleResponse handles the ActivityMarkRepoNotificationsAsRead response.
func (client *GitHubV3RESTAPIClient) activityMarkRepoNotificationsAsReadHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityMarkRepoNotificationsAsReadResponse, error) {
	result := GitHubV3RESTAPIClientActivityMarkRepoNotificationsAsReadResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsUf4AvrReposOwnerRepoNotificationsPutResponses202ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientActivityMarkRepoNotificationsAsReadResponse{}, err
	}
	return result, nil
}

// ActivityMarkThreadAsRead - Marks a thread as "read." Marking a thread as "read" is equivalent to clicking a notification
// in your notification inbox on GitHub: https://github.com/notifications.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityMarkThreadAsReadOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityMarkThreadAsRead
//     method.
func (client *GitHubV3RESTAPIClient) ActivityMarkThreadAsRead(ctx context.Context, options *GitHubV3RESTAPIClientActivityMarkThreadAsReadOptions) (GitHubV3RESTAPIClientActivityMarkThreadAsReadResponse, error) {
	req, err := client.activityMarkThreadAsReadCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityMarkThreadAsReadResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityMarkThreadAsReadResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusResetContent, http.StatusNotModified, http.StatusForbidden) {
		return GitHubV3RESTAPIClientActivityMarkThreadAsReadResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityMarkThreadAsReadHandleResponse(resp)
}

// activityMarkThreadAsReadCreateRequest creates the ActivityMarkThreadAsRead request.
func (client *GitHubV3RESTAPIClient) activityMarkThreadAsReadCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityMarkThreadAsReadOptions) (*policy.Request, error) {
	urlPath := "/notifications/threads/{thread_id}"
	urlPath = strings.ReplaceAll(urlPath, "{thread_id}", url.PathEscape(strconv.FormatInt(int64(client.threadID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityMarkThreadAsReadHandleResponse handles the ActivityMarkThreadAsRead response.
func (client *GitHubV3RESTAPIClient) activityMarkThreadAsReadHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityMarkThreadAsReadResponse, error) {
	result := GitHubV3RESTAPIClientActivityMarkThreadAsReadResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientActivityMarkThreadAsReadResponse{}, err
	}
	return result, nil
}

// ActivitySetRepoSubscription - If you would like to watch a repository, set subscribed to true. If you would like to ignore
// notifications made within a repository, set ignored to true. If you would like to stop watching a
// repository, delete the repository's subscription [https://docs.github.com/rest/reference/activity#delete-a-repository-subscription]
// completely.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivitySetRepoSubscriptionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivitySetRepoSubscription
//     method.
func (client *GitHubV3RESTAPIClient) ActivitySetRepoSubscription(ctx context.Context, body Paths4RobthReposOwnerRepoSubscriptionPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActivitySetRepoSubscriptionOptions) (GitHubV3RESTAPIClientActivitySetRepoSubscriptionResponse, error) {
	req, err := client.activitySetRepoSubscriptionCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivitySetRepoSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivitySetRepoSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientActivitySetRepoSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return client.activitySetRepoSubscriptionHandleResponse(resp)
}

// activitySetRepoSubscriptionCreateRequest creates the ActivitySetRepoSubscription request.
func (client *GitHubV3RESTAPIClient) activitySetRepoSubscriptionCreateRequest(ctx context.Context, body Paths4RobthReposOwnerRepoSubscriptionPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActivitySetRepoSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/subscription"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// activitySetRepoSubscriptionHandleResponse handles the ActivitySetRepoSubscription response.
func (client *GitHubV3RESTAPIClient) activitySetRepoSubscriptionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivitySetRepoSubscriptionResponse, error) {
	result := GitHubV3RESTAPIClientActivitySetRepoSubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RepositorySubscription); err != nil {
		return GitHubV3RESTAPIClientActivitySetRepoSubscriptionResponse{}, err
	}
	return result, nil
}

// ActivitySetThreadSubscription - If you are watching a repository, you receive notifications for all threads by default.
// Use this endpoint to ignore future notifications for threads until you comment on the thread or get an @mention.
// You can also use this endpoint to subscribe to threads that you are currently not receiving notifications for or to subscribed
// to threads that you have previously ignored.
// Unsubscribing from a conversation in a repository that you are not watching is functionally equivalent to the Delete a
// thread subscription
// [https://docs.github.com/rest/reference/activity#delete-a-thread-subscription] endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivitySetThreadSubscriptionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivitySetThreadSubscription
//     method.
func (client *GitHubV3RESTAPIClient) ActivitySetThreadSubscription(ctx context.Context, body PathsUk32QoNotificationsThreadsThreadIDSubscriptionPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActivitySetThreadSubscriptionOptions) (GitHubV3RESTAPIClientActivitySetThreadSubscriptionResponse, error) {
	req, err := client.activitySetThreadSubscriptionCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivitySetThreadSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivitySetThreadSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientActivitySetThreadSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return client.activitySetThreadSubscriptionHandleResponse(resp)
}

// activitySetThreadSubscriptionCreateRequest creates the ActivitySetThreadSubscription request.
func (client *GitHubV3RESTAPIClient) activitySetThreadSubscriptionCreateRequest(ctx context.Context, body PathsUk32QoNotificationsThreadsThreadIDSubscriptionPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientActivitySetThreadSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/notifications/threads/{thread_id}/subscription"
	urlPath = strings.ReplaceAll(urlPath, "{thread_id}", url.PathEscape(strconv.FormatInt(int64(client.threadID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// activitySetThreadSubscriptionHandleResponse handles the ActivitySetThreadSubscription response.
func (client *GitHubV3RESTAPIClient) activitySetThreadSubscriptionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivitySetThreadSubscriptionResponse, error) {
	result := GitHubV3RESTAPIClientActivitySetThreadSubscriptionResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ThreadSubscription
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivitySetThreadSubscriptionResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivitySetThreadSubscriptionResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientActivitySetThreadSubscriptionResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientActivitySetThreadSubscriptionResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ActivityStarRepoForAuthenticatedUser - Note that you'll need to set Content-Length to zero when calling out to this endpoint.
// For more information, see "HTTP verbs
// [https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityStarRepoForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityStarRepoForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) ActivityStarRepoForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientActivityStarRepoForAuthenticatedUserOptions) (GitHubV3RESTAPIClientActivityStarRepoForAuthenticatedUserResponse, error) {
	req, err := client.activityStarRepoForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityStarRepoForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityStarRepoForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientActivityStarRepoForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityStarRepoForAuthenticatedUserHandleResponse(resp)
}

// activityStarRepoForAuthenticatedUserCreateRequest creates the ActivityStarRepoForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) activityStarRepoForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityStarRepoForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/starred/{owner}/{repo}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityStarRepoForAuthenticatedUserHandleResponse handles the ActivityStarRepoForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) activityStarRepoForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityStarRepoForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientActivityStarRepoForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientActivityStarRepoForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// ActivityUnstarRepoForAuthenticatedUser - Unstar a repository for the authenticated user
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientActivityUnstarRepoForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.ActivityUnstarRepoForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) ActivityUnstarRepoForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientActivityUnstarRepoForAuthenticatedUserOptions) (GitHubV3RESTAPIClientActivityUnstarRepoForAuthenticatedUserResponse, error) {
	req, err := client.activityUnstarRepoForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientActivityUnstarRepoForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientActivityUnstarRepoForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientActivityUnstarRepoForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.activityUnstarRepoForAuthenticatedUserHandleResponse(resp)
}

// activityUnstarRepoForAuthenticatedUserCreateRequest creates the ActivityUnstarRepoForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) activityUnstarRepoForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientActivityUnstarRepoForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/starred/{owner}/{repo}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// activityUnstarRepoForAuthenticatedUserHandleResponse handles the ActivityUnstarRepoForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) activityUnstarRepoForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientActivityUnstarRepoForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientActivityUnstarRepoForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientActivityUnstarRepoForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// AppsAddRepoToInstallationForAuthenticatedUser - Add a single repository to an installation. The authenticated user must
// have admin access to the repository.
// You must use a personal access token (which you can create via the command line [https://docs.github.com/github/authenticating-to-github/creating-a-personal-access-token]
// or Basic Authentication
// [https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication]) to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsAddRepoToInstallationForAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.AppsAddRepoToInstallationForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) AppsAddRepoToInstallationForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientAppsAddRepoToInstallationForAuthenticatedUserOptions) (GitHubV3RESTAPIClientAppsAddRepoToInstallationForAuthenticatedUserResponse, error) {
	req, err := client.appsAddRepoToInstallationForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsAddRepoToInstallationForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsAddRepoToInstallationForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientAppsAddRepoToInstallationForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsAddRepoToInstallationForAuthenticatedUserHandleResponse(resp)
}

// appsAddRepoToInstallationForAuthenticatedUserCreateRequest creates the AppsAddRepoToInstallationForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) appsAddRepoToInstallationForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsAddRepoToInstallationForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/installations/{installation_id}/repositories/{repository_id}"
	urlPath = strings.ReplaceAll(urlPath, "{installation_id}", url.PathEscape(strconv.FormatInt(int64(client.installationID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsAddRepoToInstallationForAuthenticatedUserHandleResponse handles the AppsAddRepoToInstallationForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) appsAddRepoToInstallationForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsAddRepoToInstallationForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientAppsAddRepoToInstallationForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientAppsAddRepoToInstallationForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// AppsCheckToken - OAuth applications can use a special API method for checking OAuth token validity without exceeding the
// normal rate limits for failed login attempts. Authentication works differently with this
// particular endpoint. You must use Basic Authentication [https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication]
// to use this endpoint, where the username is the OAuth
// application clientid and the password is its clientsecret. Invalid tokens will return 404 NOT FOUND.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsCheckTokenOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsCheckToken
//     method.
func (client *GitHubV3RESTAPIClient) AppsCheckToken(ctx context.Context, body Paths1BqvfchApplicationsClientIDTokenPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientAppsCheckTokenOptions) (GitHubV3RESTAPIClientAppsCheckTokenResponse, error) {
	req, err := client.appsCheckTokenCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsCheckTokenResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsCheckTokenResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientAppsCheckTokenResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsCheckTokenHandleResponse(resp)
}

// appsCheckTokenCreateRequest creates the AppsCheckToken request.
func (client *GitHubV3RESTAPIClient) appsCheckTokenCreateRequest(ctx context.Context, body Paths1BqvfchApplicationsClientIDTokenPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientAppsCheckTokenOptions) (*policy.Request, error) {
	urlPath := "/applications/{client_id}/token"
	if client.clientID == "" {
		return nil, errors.New("parameter client.clientID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{client_id}", url.PathEscape(client.clientID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// appsCheckTokenHandleResponse handles the AppsCheckToken response.
func (client *GitHubV3RESTAPIClient) appsCheckTokenHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsCheckTokenResponse, error) {
	result := GitHubV3RESTAPIClientAppsCheckTokenResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Authorization
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsCheckTokenResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsCheckTokenResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsCheckTokenResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsCheckTokenResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsCreateFromManifest - Use this endpoint to complete the handshake necessary when implementing the GitHub App Manifest
// flow [https://docs.github.com/apps/building-github-apps/creating-github-apps-from-a-manifest/]. When you
// create a GitHub App with the manifest flow, you receive a temporary code used to retrieve the GitHub App's id, pem (private
// key), and webhook_secret.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsCreateFromManifestOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsCreateFromManifest
//     method.
func (client *GitHubV3RESTAPIClient) AppsCreateFromManifest(ctx context.Context, code string, options *GitHubV3RESTAPIClientAppsCreateFromManifestOptions) (GitHubV3RESTAPIClientAppsCreateFromManifestResponse, error) {
	req, err := client.appsCreateFromManifestCreateRequest(ctx, code, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsCreateFromManifestResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsCreateFromManifestResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientAppsCreateFromManifestResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsCreateFromManifestHandleResponse(resp)
}

// appsCreateFromManifestCreateRequest creates the AppsCreateFromManifest request.
func (client *GitHubV3RESTAPIClient) appsCreateFromManifestCreateRequest(ctx context.Context, code string, options *GitHubV3RESTAPIClientAppsCreateFromManifestOptions) (*policy.Request, error) {
	urlPath := "/app-manifests/{code}/conversions"
	if code == "" {
		return nil, errors.New("parameter code cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{code}", url.PathEscape(code))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsCreateFromManifestHandleResponse handles the AppsCreateFromManifest response.
func (client *GitHubV3RESTAPIClient) appsCreateFromManifestHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsCreateFromManifestResponse, error) {
	result := GitHubV3RESTAPIClientAppsCreateFromManifestResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val PathsQezna3AppManifestsCodeConversionsPostResponses201ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsCreateFromManifestResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsCreateFromManifestResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsCreateFromManifestResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsCreateFromManifestResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsCreateInstallationAccessToken - Creates an installation access token that enables a GitHub App to make authenticated
// API requests for the app's installation on an organization or individual account. Installation tokens expire one
// hour from the time you create them. Using an expired token produces a status code of 401 - Unauthorized, and requires creating
// a new installation token. By default the installation token has access to
// all repositories that the installation can access. To restrict the access to specific repositories, you can provide the
// repositoryids when creating the token. When you omit repositoryids, the response
// does not contain the repositories key.
// You must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsCreateInstallationAccessTokenOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsCreateInstallationAccessToken
//     method.
func (client *GitHubV3RESTAPIClient) AppsCreateInstallationAccessToken(ctx context.Context, options *GitHubV3RESTAPIClientAppsCreateInstallationAccessTokenOptions) (GitHubV3RESTAPIClientAppsCreateInstallationAccessTokenResponse, error) {
	req, err := client.appsCreateInstallationAccessTokenCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsCreateInstallationAccessTokenResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsCreateInstallationAccessTokenResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientAppsCreateInstallationAccessTokenResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsCreateInstallationAccessTokenHandleResponse(resp)
}

// appsCreateInstallationAccessTokenCreateRequest creates the AppsCreateInstallationAccessToken request.
func (client *GitHubV3RESTAPIClient) appsCreateInstallationAccessTokenCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsCreateInstallationAccessTokenOptions) (*policy.Request, error) {
	urlPath := "/app/installations/{installation_id}/access_tokens"
	urlPath = strings.ReplaceAll(urlPath, "{installation_id}", url.PathEscape(strconv.FormatInt(int64(client.installationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// appsCreateInstallationAccessTokenHandleResponse handles the AppsCreateInstallationAccessToken response.
func (client *GitHubV3RESTAPIClient) appsCreateInstallationAccessTokenHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsCreateInstallationAccessTokenResponse, error) {
	result := GitHubV3RESTAPIClientAppsCreateInstallationAccessTokenResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val InstallationToken
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsCreateInstallationAccessTokenResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsCreateInstallationAccessTokenResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsCreateInstallationAccessTokenResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsCreateInstallationAccessTokenResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsCreateInstallationAccessTokenResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsCreateInstallationAccessTokenResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsDeleteAuthorization - OAuth application owners can revoke a grant for their OAuth application and a specific user.
// You must use Basic Authentication
// [https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication] when accessing this endpoint,
// using the OAuth application's clientid and clientsecret as the username and
// password. You must also provide a valid OAuth access_token as an input parameter and the grant for the token's owner will
// be deleted. Deleting an OAuth application's grant will also delete all OAuth
// tokens associated with the application for the user. Once deleted, the application will have no access to the user's account
// and will no longer be listed on the application authorizations settings
// screen within GitHub [https://github.com/settings/applications#authorized].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsDeleteAuthorizationOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsDeleteAuthorization
//     method.
func (client *GitHubV3RESTAPIClient) AppsDeleteAuthorization(ctx context.Context, body Paths1MalsmdApplicationsClientIDGrantDeleteRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientAppsDeleteAuthorizationOptions) (GitHubV3RESTAPIClientAppsDeleteAuthorizationResponse, error) {
	req, err := client.appsDeleteAuthorizationCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsDeleteAuthorizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsDeleteAuthorizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientAppsDeleteAuthorizationResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsDeleteAuthorizationHandleResponse(resp)
}

// appsDeleteAuthorizationCreateRequest creates the AppsDeleteAuthorization request.
func (client *GitHubV3RESTAPIClient) appsDeleteAuthorizationCreateRequest(ctx context.Context, body Paths1MalsmdApplicationsClientIDGrantDeleteRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientAppsDeleteAuthorizationOptions) (*policy.Request, error) {
	urlPath := "/applications/{client_id}/grant"
	if client.clientID == "" {
		return nil, errors.New("parameter client.clientID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{client_id}", url.PathEscape(client.clientID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// appsDeleteAuthorizationHandleResponse handles the AppsDeleteAuthorization response.
func (client *GitHubV3RESTAPIClient) appsDeleteAuthorizationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsDeleteAuthorizationResponse, error) {
	result := GitHubV3RESTAPIClientAppsDeleteAuthorizationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ValidationError); err != nil {
		return GitHubV3RESTAPIClientAppsDeleteAuthorizationResponse{}, err
	}
	return result, nil
}

// AppsDeleteInstallation - Uninstalls a GitHub App on a user, organization, or business account. If you prefer to temporarily
// suspend an app's access to your account's resources, then we recommend the "Suspend an app
// installation [https://docs.github.com/rest/reference/apps/#suspend-an-app-installation]" endpoint.
// You must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsDeleteInstallationOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsDeleteInstallation
//     method.
func (client *GitHubV3RESTAPIClient) AppsDeleteInstallation(ctx context.Context, options *GitHubV3RESTAPIClientAppsDeleteInstallationOptions) (GitHubV3RESTAPIClientAppsDeleteInstallationResponse, error) {
	req, err := client.appsDeleteInstallationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsDeleteInstallationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsDeleteInstallationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientAppsDeleteInstallationResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsDeleteInstallationHandleResponse(resp)
}

// appsDeleteInstallationCreateRequest creates the AppsDeleteInstallation request.
func (client *GitHubV3RESTAPIClient) appsDeleteInstallationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsDeleteInstallationOptions) (*policy.Request, error) {
	urlPath := "/app/installations/{installation_id}"
	urlPath = strings.ReplaceAll(urlPath, "{installation_id}", url.PathEscape(strconv.FormatInt(int64(client.installationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsDeleteInstallationHandleResponse handles the AppsDeleteInstallation response.
func (client *GitHubV3RESTAPIClient) appsDeleteInstallationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsDeleteInstallationResponse, error) {
	result := GitHubV3RESTAPIClientAppsDeleteInstallationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientAppsDeleteInstallationResponse{}, err
	}
	return result, nil
}

// AppsDeleteToken - OAuth application owners can revoke a single token for an OAuth application. You must use Basic Authentication
// [https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication]
// when accessing this endpoint, using the OAuth application's clientid and clientsecret as the username and password.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsDeleteTokenOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsDeleteToken
//     method.
func (client *GitHubV3RESTAPIClient) AppsDeleteToken(ctx context.Context, body Paths10Re8XwApplicationsClientIDTokenDeleteRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientAppsDeleteTokenOptions) (GitHubV3RESTAPIClientAppsDeleteTokenResponse, error) {
	req, err := client.appsDeleteTokenCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsDeleteTokenResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsDeleteTokenResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientAppsDeleteTokenResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsDeleteTokenHandleResponse(resp)
}

// appsDeleteTokenCreateRequest creates the AppsDeleteToken request.
func (client *GitHubV3RESTAPIClient) appsDeleteTokenCreateRequest(ctx context.Context, body Paths10Re8XwApplicationsClientIDTokenDeleteRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientAppsDeleteTokenOptions) (*policy.Request, error) {
	urlPath := "/applications/{client_id}/token"
	if client.clientID == "" {
		return nil, errors.New("parameter client.clientID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{client_id}", url.PathEscape(client.clientID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// appsDeleteTokenHandleResponse handles the AppsDeleteToken response.
func (client *GitHubV3RESTAPIClient) appsDeleteTokenHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsDeleteTokenResponse, error) {
	result := GitHubV3RESTAPIClientAppsDeleteTokenResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ValidationError); err != nil {
		return GitHubV3RESTAPIClientAppsDeleteTokenResponse{}, err
	}
	return result, nil
}

// AppsGetAuthenticated - Returns the GitHub App associated with the authentication credentials used. To see how many app
// installations are associated with this GitHub App, see the installations_count in the response. For more
// details about your app's installations, see the "List installations for the authenticated app [https://docs.github.com/rest/reference/apps#list-installations-for-the-authenticated-app]"
// endpoint.
// You must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsGetAuthenticatedOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsGetAuthenticated
//     method.
func (client *GitHubV3RESTAPIClient) AppsGetAuthenticated(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetAuthenticatedOptions) (GitHubV3RESTAPIClientAppsGetAuthenticatedResponse, error) {
	req, err := client.appsGetAuthenticatedCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetAuthenticatedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetAuthenticatedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientAppsGetAuthenticatedResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsGetAuthenticatedHandleResponse(resp)
}

// appsGetAuthenticatedCreateRequest creates the AppsGetAuthenticated request.
func (client *GitHubV3RESTAPIClient) appsGetAuthenticatedCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetAuthenticatedOptions) (*policy.Request, error) {
	urlPath := "/app"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsGetAuthenticatedHandleResponse handles the AppsGetAuthenticated response.
func (client *GitHubV3RESTAPIClient) appsGetAuthenticatedHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsGetAuthenticatedResponse, error) {
	result := GitHubV3RESTAPIClientAppsGetAuthenticatedResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Integration); err != nil {
		return GitHubV3RESTAPIClientAppsGetAuthenticatedResponse{}, err
	}
	return result, nil
}

// AppsGetBySlug - Note: The :appslug is just the URL-friendly name of your GitHub App. You can find this on the settings
// page for your GitHub App (e.g., https://github.com/settings/apps/:appslug).
// If the GitHub App you specify is public, you can access this endpoint without authenticating. If the GitHub App you specify
// is private, you must authenticate with a personal access token
// [https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line/] or an installation access token
// [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsGetBySlugOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsGetBySlug
//     method.
func (client *GitHubV3RESTAPIClient) AppsGetBySlug(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetBySlugOptions) (GitHubV3RESTAPIClientAppsGetBySlugResponse, error) {
	req, err := client.appsGetBySlugCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetBySlugResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetBySlugResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientAppsGetBySlugResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsGetBySlugHandleResponse(resp)
}

// appsGetBySlugCreateRequest creates the AppsGetBySlug request.
func (client *GitHubV3RESTAPIClient) appsGetBySlugCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetBySlugOptions) (*policy.Request, error) {
	urlPath := "/apps/{app_slug}"
	if client.appSlug == "" {
		return nil, errors.New("parameter client.appSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{app_slug}", url.PathEscape(client.appSlug))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsGetBySlugHandleResponse handles the AppsGetBySlug response.
func (client *GitHubV3RESTAPIClient) appsGetBySlugHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsGetBySlugResponse, error) {
	result := GitHubV3RESTAPIClientAppsGetBySlugResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Integration
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsGetBySlugResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsGetBySlugResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsGetBySlugResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsGetBySlugResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsGetInstallation - Enables an authenticated GitHub App to find an installation's information using the installation
// id.
// You must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsGetInstallationOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsGetInstallation
//     method.
func (client *GitHubV3RESTAPIClient) AppsGetInstallation(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetInstallationOptions) (GitHubV3RESTAPIClientAppsGetInstallationResponse, error) {
	req, err := client.appsGetInstallationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetInstallationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetInstallationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientAppsGetInstallationResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsGetInstallationHandleResponse(resp)
}

// appsGetInstallationCreateRequest creates the AppsGetInstallation request.
func (client *GitHubV3RESTAPIClient) appsGetInstallationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetInstallationOptions) (*policy.Request, error) {
	urlPath := "/app/installations/{installation_id}"
	urlPath = strings.ReplaceAll(urlPath, "{installation_id}", url.PathEscape(strconv.FormatInt(int64(client.installationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsGetInstallationHandleResponse handles the AppsGetInstallation response.
func (client *GitHubV3RESTAPIClient) appsGetInstallationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsGetInstallationResponse, error) {
	result := GitHubV3RESTAPIClientAppsGetInstallationResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Installation
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsGetInstallationResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsGetInstallationResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsGetInstallationResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsGetOrgInstallation - Enables an authenticated GitHub App to find the organization's installation information.
// You must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsGetOrgInstallationOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsGetOrgInstallation
//     method.
func (client *GitHubV3RESTAPIClient) AppsGetOrgInstallation(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetOrgInstallationOptions) (GitHubV3RESTAPIClientAppsGetOrgInstallationResponse, error) {
	req, err := client.appsGetOrgInstallationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetOrgInstallationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetOrgInstallationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientAppsGetOrgInstallationResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsGetOrgInstallationHandleResponse(resp)
}

// appsGetOrgInstallationCreateRequest creates the AppsGetOrgInstallation request.
func (client *GitHubV3RESTAPIClient) appsGetOrgInstallationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetOrgInstallationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/installation"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsGetOrgInstallationHandleResponse handles the AppsGetOrgInstallation response.
func (client *GitHubV3RESTAPIClient) appsGetOrgInstallationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsGetOrgInstallationResponse, error) {
	result := GitHubV3RESTAPIClientAppsGetOrgInstallationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Installation); err != nil {
		return GitHubV3RESTAPIClientAppsGetOrgInstallationResponse{}, err
	}
	return result, nil
}

// AppsGetRepoInstallation - Enables an authenticated GitHub App to find the repository's installation information. The installation's
// account type will be either an organization or a user account, depending which account the
// repository belongs to.
// You must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsGetRepoInstallationOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsGetRepoInstallation
//     method.
func (client *GitHubV3RESTAPIClient) AppsGetRepoInstallation(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetRepoInstallationOptions) (GitHubV3RESTAPIClientAppsGetRepoInstallationResponse, error) {
	req, err := client.appsGetRepoInstallationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetRepoInstallationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetRepoInstallationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientAppsGetRepoInstallationResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsGetRepoInstallationHandleResponse(resp)
}

// appsGetRepoInstallationCreateRequest creates the AppsGetRepoInstallation request.
func (client *GitHubV3RESTAPIClient) appsGetRepoInstallationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetRepoInstallationOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/installation"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsGetRepoInstallationHandleResponse handles the AppsGetRepoInstallation response.
func (client *GitHubV3RESTAPIClient) appsGetRepoInstallationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsGetRepoInstallationResponse, error) {
	result := GitHubV3RESTAPIClientAppsGetRepoInstallationResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Installation
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsGetRepoInstallationResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsGetRepoInstallationResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsGetRepoInstallationResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsGetSubscriptionPlanForAccount - Shows whether the user or organization account actively subscribes to a plan listed
// by the authenticated GitHub App. When someone submits a plan change that won't be processed until the end of their
// billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint. OAuth Apps must use basic
// authentication [https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication] with their client
// ID and client secret to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsGetSubscriptionPlanForAccount
//     method.
func (client *GitHubV3RESTAPIClient) AppsGetSubscriptionPlanForAccount(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountOptions) (GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountResponse, error) {
	req, err := client.appsGetSubscriptionPlanForAccountCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusNotFound) {
		return GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsGetSubscriptionPlanForAccountHandleResponse(resp)
}

// appsGetSubscriptionPlanForAccountCreateRequest creates the AppsGetSubscriptionPlanForAccount request.
func (client *GitHubV3RESTAPIClient) appsGetSubscriptionPlanForAccountCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountOptions) (*policy.Request, error) {
	urlPath := "/marketplace_listing/accounts/{account_id}"
	urlPath = strings.ReplaceAll(urlPath, "{account_id}", url.PathEscape(strconv.FormatInt(int64(client.accountID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsGetSubscriptionPlanForAccountHandleResponse handles the AppsGetSubscriptionPlanForAccount response.
func (client *GitHubV3RESTAPIClient) appsGetSubscriptionPlanForAccountHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountResponse, error) {
	result := GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val MarketplacePurchase
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsGetSubscriptionPlanForAccountStubbed - Shows whether the user or organization account actively subscribes to a plan
// listed by the authenticated GitHub App. When someone submits a plan change that won't be processed until the end of their
// billing cycle, you will also see the upcoming pending change.
// GitHub Apps must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint. OAuth Apps must use basic
// authentication [https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication] with their client
// ID and client secret to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountStubbedOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.AppsGetSubscriptionPlanForAccountStubbed method.
func (client *GitHubV3RESTAPIClient) AppsGetSubscriptionPlanForAccountStubbed(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountStubbedOptions) (GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountStubbedResponse, error) {
	req, err := client.appsGetSubscriptionPlanForAccountStubbedCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountStubbedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountStubbedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusNotFound) {
		return GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountStubbedResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsGetSubscriptionPlanForAccountStubbedHandleResponse(resp)
}

// appsGetSubscriptionPlanForAccountStubbedCreateRequest creates the AppsGetSubscriptionPlanForAccountStubbed request.
func (client *GitHubV3RESTAPIClient) appsGetSubscriptionPlanForAccountStubbedCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountStubbedOptions) (*policy.Request, error) {
	urlPath := "/marketplace_listing/stubbed/accounts/{account_id}"
	urlPath = strings.ReplaceAll(urlPath, "{account_id}", url.PathEscape(strconv.FormatInt(int64(client.accountID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsGetSubscriptionPlanForAccountStubbedHandleResponse handles the AppsGetSubscriptionPlanForAccountStubbed response.
func (client *GitHubV3RESTAPIClient) appsGetSubscriptionPlanForAccountStubbedHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountStubbedResponse, error) {
	result := GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountStubbedResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val MarketplacePurchase
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountStubbedResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountStubbedResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	default:
		return GitHubV3RESTAPIClientAppsGetSubscriptionPlanForAccountStubbedResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsGetUserInstallation - Enables an authenticated GitHub App to find the users installation information.
// You must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsGetUserInstallationOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsGetUserInstallation
//     method.
func (client *GitHubV3RESTAPIClient) AppsGetUserInstallation(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetUserInstallationOptions) (GitHubV3RESTAPIClientAppsGetUserInstallationResponse, error) {
	req, err := client.appsGetUserInstallationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetUserInstallationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetUserInstallationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientAppsGetUserInstallationResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsGetUserInstallationHandleResponse(resp)
}

// appsGetUserInstallationCreateRequest creates the AppsGetUserInstallation request.
func (client *GitHubV3RESTAPIClient) appsGetUserInstallationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetUserInstallationOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/installation"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsGetUserInstallationHandleResponse handles the AppsGetUserInstallation response.
func (client *GitHubV3RESTAPIClient) appsGetUserInstallationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsGetUserInstallationResponse, error) {
	result := GitHubV3RESTAPIClientAppsGetUserInstallationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Installation); err != nil {
		return GitHubV3RESTAPIClientAppsGetUserInstallationResponse{}, err
	}
	return result, nil
}

// AppsGetWebhookConfigForApp - Returns the webhook configuration for a GitHub App. For more information about configuring
// a webhook for your app, see "Creating a GitHub App [/developers/apps/creating-a-github-app]."
// You must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsGetWebhookConfigForAppOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsGetWebhookConfigForApp
//     method.
func (client *GitHubV3RESTAPIClient) AppsGetWebhookConfigForApp(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetWebhookConfigForAppOptions) (GitHubV3RESTAPIClientAppsGetWebhookConfigForAppResponse, error) {
	req, err := client.appsGetWebhookConfigForAppCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetWebhookConfigForAppResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetWebhookConfigForAppResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientAppsGetWebhookConfigForAppResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsGetWebhookConfigForAppHandleResponse(resp)
}

// appsGetWebhookConfigForAppCreateRequest creates the AppsGetWebhookConfigForApp request.
func (client *GitHubV3RESTAPIClient) appsGetWebhookConfigForAppCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetWebhookConfigForAppOptions) (*policy.Request, error) {
	urlPath := "/app/hook/config"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsGetWebhookConfigForAppHandleResponse handles the AppsGetWebhookConfigForApp response.
func (client *GitHubV3RESTAPIClient) appsGetWebhookConfigForAppHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsGetWebhookConfigForAppResponse, error) {
	result := GitHubV3RESTAPIClientAppsGetWebhookConfigForAppResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebhookConfig); err != nil {
		return GitHubV3RESTAPIClientAppsGetWebhookConfigForAppResponse{}, err
	}
	return result, nil
}

// AppsGetWebhookDelivery - Returns a delivery for the webhook configured for a GitHub App.
// You must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsGetWebhookDeliveryOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsGetWebhookDelivery
//     method.
func (client *GitHubV3RESTAPIClient) AppsGetWebhookDelivery(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetWebhookDeliveryOptions) (GitHubV3RESTAPIClientAppsGetWebhookDeliveryResponse, error) {
	req, err := client.appsGetWebhookDeliveryCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetWebhookDeliveryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsGetWebhookDeliveryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientAppsGetWebhookDeliveryResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsGetWebhookDeliveryHandleResponse(resp)
}

// appsGetWebhookDeliveryCreateRequest creates the AppsGetWebhookDelivery request.
func (client *GitHubV3RESTAPIClient) appsGetWebhookDeliveryCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsGetWebhookDeliveryOptions) (*policy.Request, error) {
	urlPath := "/app/hook/deliveries/{delivery_id}"
	urlPath = strings.ReplaceAll(urlPath, "{delivery_id}", url.PathEscape(strconv.FormatInt(int64(client.deliveryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// appsGetWebhookDeliveryHandleResponse handles the AppsGetWebhookDelivery response.
func (client *GitHubV3RESTAPIClient) appsGetWebhookDeliveryHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsGetWebhookDeliveryResponse, error) {
	result := GitHubV3RESTAPIClientAppsGetWebhookDeliveryResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val HookDelivery
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsGetWebhookDeliveryResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsGetWebhookDeliveryResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsGetWebhookDeliveryResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsGetWebhookDeliveryResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsListAccountsForPlan - Returns user and organization accounts associated with the specified plan, including free plans.
// For per-seat pricing, you see the list of accounts that have purchased the plan, including the number
// of seats purchased. When someone submits a plan change that won't be processed until the end of their billing cycle, you
// will also see the upcoming pending change.
// GitHub Apps must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint. OAuth Apps must use basic
// authentication [https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication] with their client
// ID and client secret to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsListAccountsForPlanOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsListAccountsForPlan
//     method.
func (client *GitHubV3RESTAPIClient) AppsListAccountsForPlan(ctx context.Context, options *GitHubV3RESTAPIClientAppsListAccountsForPlanOptions) (GitHubV3RESTAPIClientAppsListAccountsForPlanResponse, error) {
	req, err := client.appsListAccountsForPlanCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListAccountsForPlanResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListAccountsForPlanResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientAppsListAccountsForPlanResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsListAccountsForPlanHandleResponse(resp)
}

// appsListAccountsForPlanCreateRequest creates the AppsListAccountsForPlan request.
func (client *GitHubV3RESTAPIClient) appsListAccountsForPlanCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsListAccountsForPlanOptions) (*policy.Request, error) {
	urlPath := "/marketplace_listing/plans/{plan_id}/accounts"
	urlPath = strings.ReplaceAll(urlPath, "{plan_id}", url.PathEscape(strconv.FormatInt(int64(client.planID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.sortParam != nil {
		reqQP.Set("sort", string(*client.sortParam))
	}
	if options != nil && options.Direction != nil {
		reqQP.Set("direction", string(*options.Direction))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsListAccountsForPlanHandleResponse handles the AppsListAccountsForPlan response.
func (client *GitHubV3RESTAPIClient) appsListAccountsForPlanHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsListAccountsForPlanResponse, error) {
	result := GitHubV3RESTAPIClientAppsListAccountsForPlanResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*MarketplacePurchase
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListAccountsForPlanResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListAccountsForPlanResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListAccountsForPlanResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListAccountsForPlanResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsListAccountsForPlanResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsListAccountsForPlanStubbed - Returns repository and organization accounts associated with the specified plan, including
// free plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including the
// number of seats purchased. When someone submits a plan change that won't be processed until the end of their billing cycle,
// you will also see the upcoming pending change.
// GitHub Apps must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint. OAuth Apps must use basic
// authentication [https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication] with their client
// ID and client secret to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsListAccountsForPlanStubbedOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsListAccountsForPlanStubbed
//     method.
func (client *GitHubV3RESTAPIClient) AppsListAccountsForPlanStubbed(ctx context.Context, options *GitHubV3RESTAPIClientAppsListAccountsForPlanStubbedOptions) (GitHubV3RESTAPIClientAppsListAccountsForPlanStubbedResponse, error) {
	req, err := client.appsListAccountsForPlanStubbedCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListAccountsForPlanStubbedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListAccountsForPlanStubbedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized) {
		return GitHubV3RESTAPIClientAppsListAccountsForPlanStubbedResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsListAccountsForPlanStubbedHandleResponse(resp)
}

// appsListAccountsForPlanStubbedCreateRequest creates the AppsListAccountsForPlanStubbed request.
func (client *GitHubV3RESTAPIClient) appsListAccountsForPlanStubbedCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsListAccountsForPlanStubbedOptions) (*policy.Request, error) {
	urlPath := "/marketplace_listing/stubbed/plans/{plan_id}/accounts"
	urlPath = strings.ReplaceAll(urlPath, "{plan_id}", url.PathEscape(strconv.FormatInt(int64(client.planID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.sortParam != nil {
		reqQP.Set("sort", string(*client.sortParam))
	}
	if options != nil && options.Direction != nil {
		reqQP.Set("direction", string(*options.Direction))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsListAccountsForPlanStubbedHandleResponse handles the AppsListAccountsForPlanStubbed response.
func (client *GitHubV3RESTAPIClient) appsListAccountsForPlanStubbedHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsListAccountsForPlanStubbedResponse, error) {
	result := GitHubV3RESTAPIClientAppsListAccountsForPlanStubbedResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*MarketplacePurchase
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListAccountsForPlanStubbedResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListAccountsForPlanStubbedResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsListAccountsForPlanStubbedResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsListInstallationReposForAuthenticatedUser - List repositories that the authenticated user has explicit permission (:read,
// :write, or :admin) to access for an installation.
// The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator,
// and repositories that they can access through an organization membership.
// You must use a user-to-server OAuth access token [https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site],
// created for a
// user who has authorized your GitHub App, to access this endpoint.
// The access the user has to each repository is included in the hash under the permissions key.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsListInstallationReposForAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.AppsListInstallationReposForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) AppsListInstallationReposForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientAppsListInstallationReposForAuthenticatedUserOptions) (GitHubV3RESTAPIClientAppsListInstallationReposForAuthenticatedUserResponse, error) {
	req, err := client.appsListInstallationReposForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListInstallationReposForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListInstallationReposForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientAppsListInstallationReposForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsListInstallationReposForAuthenticatedUserHandleResponse(resp)
}

// appsListInstallationReposForAuthenticatedUserCreateRequest creates the AppsListInstallationReposForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) appsListInstallationReposForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsListInstallationReposForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/installations/{installation_id}/repositories"
	urlPath = strings.ReplaceAll(urlPath, "{installation_id}", url.PathEscape(strconv.FormatInt(int64(client.installationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsListInstallationReposForAuthenticatedUserHandleResponse handles the AppsListInstallationReposForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) appsListInstallationReposForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsListInstallationReposForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientAppsListInstallationReposForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Paths1061OcyUserInstallationsInstallationIDRepositoriesGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListInstallationReposForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListInstallationReposForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListInstallationReposForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsListInstallationReposForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsListInstallations - You must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint.
// The permissions the installation has are included under the permissions key.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsListInstallationsOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsListInstallations
//     method.
func (client *GitHubV3RESTAPIClient) AppsListInstallations(ctx context.Context, options *GitHubV3RESTAPIClientAppsListInstallationsOptions) (GitHubV3RESTAPIClientAppsListInstallationsResponse, error) {
	req, err := client.appsListInstallationsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListInstallationsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListInstallationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientAppsListInstallationsResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsListInstallationsHandleResponse(resp)
}

// appsListInstallationsCreateRequest creates the AppsListInstallations request.
func (client *GitHubV3RESTAPIClient) appsListInstallationsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsListInstallationsOptions) (*policy.Request, error) {
	urlPath := "/app/installations"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if options != nil && options.Outdated != nil {
		reqQP.Set("outdated", *options.Outdated)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsListInstallationsHandleResponse handles the AppsListInstallations response.
func (client *GitHubV3RESTAPIClient) appsListInstallationsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsListInstallationsResponse, error) {
	result := GitHubV3RESTAPIClientAppsListInstallationsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.InstallationArray); err != nil {
		return GitHubV3RESTAPIClientAppsListInstallationsResponse{}, err
	}
	return result, nil
}

// AppsListInstallationsForAuthenticatedUser - Lists installations of your GitHub App that the authenticated user has explicit
// permission (:read, :write, or :admin) to access.
// You must use a user-to-server OAuth access token [https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site],
// created for a
// user who has authorized your GitHub App, to access this endpoint.
// The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator,
// and repositories that they can access through an organization membership.
// You can find the permissions for the installation under the permissions key.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsListInstallationsForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.AppsListInstallationsForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) AppsListInstallationsForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientAppsListInstallationsForAuthenticatedUserOptions) (GitHubV3RESTAPIClientAppsListInstallationsForAuthenticatedUserResponse, error) {
	req, err := client.appsListInstallationsForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListInstallationsForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListInstallationsForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientAppsListInstallationsForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsListInstallationsForAuthenticatedUserHandleResponse(resp)
}

// appsListInstallationsForAuthenticatedUserCreateRequest creates the AppsListInstallationsForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) appsListInstallationsForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsListInstallationsForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/installations"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsListInstallationsForAuthenticatedUserHandleResponse handles the AppsListInstallationsForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) appsListInstallationsForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsListInstallationsForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientAppsListInstallationsForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Paths16PcesmUserInstallationsGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListInstallationsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListInstallationsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListInstallationsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsListInstallationsForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsListPlans - Lists all plans that are part of your GitHub Marketplace listing.
// GitHub Apps must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint. OAuth Apps must use basic
// authentication [https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication] with their client
// ID and client secret to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsListPlansOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsListPlans
//     method.
func (client *GitHubV3RESTAPIClient) AppsListPlans(ctx context.Context, options *GitHubV3RESTAPIClientAppsListPlansOptions) (GitHubV3RESTAPIClientAppsListPlansResponse, error) {
	req, err := client.appsListPlansCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListPlansResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListPlansResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusNotFound) {
		return GitHubV3RESTAPIClientAppsListPlansResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsListPlansHandleResponse(resp)
}

// appsListPlansCreateRequest creates the AppsListPlans request.
func (client *GitHubV3RESTAPIClient) appsListPlansCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsListPlansOptions) (*policy.Request, error) {
	urlPath := "/marketplace_listing/plans"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsListPlansHandleResponse handles the AppsListPlans response.
func (client *GitHubV3RESTAPIClient) appsListPlansHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsListPlansResponse, error) {
	result := GitHubV3RESTAPIClientAppsListPlansResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*MarketplaceListingPlan
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListPlansResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListPlansResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListPlansResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsListPlansResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsListPlansStubbed - Lists all plans that are part of your GitHub Marketplace listing.
// GitHub Apps must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint. OAuth Apps must use basic
// authentication [https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication] with their client
// ID and client secret to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsListPlansStubbedOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsListPlansStubbed
//     method.
func (client *GitHubV3RESTAPIClient) AppsListPlansStubbed(ctx context.Context, options *GitHubV3RESTAPIClientAppsListPlansStubbedOptions) (GitHubV3RESTAPIClientAppsListPlansStubbedResponse, error) {
	req, err := client.appsListPlansStubbedCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListPlansStubbedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListPlansStubbedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized) {
		return GitHubV3RESTAPIClientAppsListPlansStubbedResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsListPlansStubbedHandleResponse(resp)
}

// appsListPlansStubbedCreateRequest creates the AppsListPlansStubbed request.
func (client *GitHubV3RESTAPIClient) appsListPlansStubbedCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsListPlansStubbedOptions) (*policy.Request, error) {
	urlPath := "/marketplace_listing/stubbed/plans"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsListPlansStubbedHandleResponse handles the AppsListPlansStubbed response.
func (client *GitHubV3RESTAPIClient) appsListPlansStubbedHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsListPlansStubbedResponse, error) {
	result := GitHubV3RESTAPIClientAppsListPlansStubbedResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*MarketplaceListingPlan
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListPlansStubbedResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListPlansStubbedResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsListPlansStubbedResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsListReposAccessibleToInstallation - List repositories that an app installation can access.
// You must use an installation access token [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsListReposAccessibleToInstallationOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsListReposAccessibleToInstallation
//     method.
func (client *GitHubV3RESTAPIClient) AppsListReposAccessibleToInstallation(ctx context.Context, options *GitHubV3RESTAPIClientAppsListReposAccessibleToInstallationOptions) (GitHubV3RESTAPIClientAppsListReposAccessibleToInstallationResponse, error) {
	req, err := client.appsListReposAccessibleToInstallationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListReposAccessibleToInstallationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListReposAccessibleToInstallationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientAppsListReposAccessibleToInstallationResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsListReposAccessibleToInstallationHandleResponse(resp)
}

// appsListReposAccessibleToInstallationCreateRequest creates the AppsListReposAccessibleToInstallation request.
func (client *GitHubV3RESTAPIClient) appsListReposAccessibleToInstallationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsListReposAccessibleToInstallationOptions) (*policy.Request, error) {
	urlPath := "/installation/repositories"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsListReposAccessibleToInstallationHandleResponse handles the AppsListReposAccessibleToInstallation response.
func (client *GitHubV3RESTAPIClient) appsListReposAccessibleToInstallationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsListReposAccessibleToInstallationResponse, error) {
	result := GitHubV3RESTAPIClientAppsListReposAccessibleToInstallationResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Paths21T9E3InstallationRepositoriesGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListReposAccessibleToInstallationResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListReposAccessibleToInstallationResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListReposAccessibleToInstallationResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsListReposAccessibleToInstallationResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsListSubscriptionsForAuthenticatedUser - Lists the active subscriptions for the authenticated user. You must use a user-to-server
// OAuth access token
// [https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site],
// created for a user who has authorized your GitHub App, to access
// this endpoint. . OAuth Apps must authenticate using an OAuth token [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.AppsListSubscriptionsForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) AppsListSubscriptionsForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserOptions) (GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserResponse, error) {
	req, err := client.appsListSubscriptionsForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusNotFound) {
		return GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsListSubscriptionsForAuthenticatedUserHandleResponse(resp)
}

// appsListSubscriptionsForAuthenticatedUserCreateRequest creates the AppsListSubscriptionsForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) appsListSubscriptionsForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/marketplace_purchases"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsListSubscriptionsForAuthenticatedUserHandleResponse handles the AppsListSubscriptionsForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) appsListSubscriptionsForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*UserMarketplacePurchase
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsListSubscriptionsForAuthenticatedUserStubbed - Lists the active subscriptions for the authenticated user. You must
// use a user-to-server OAuth access token
// [https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site],
// created for a user who has authorized your GitHub App, to access
// this endpoint. . OAuth Apps must authenticate using an OAuth token [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserStubbedOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.AppsListSubscriptionsForAuthenticatedUserStubbed method.
func (client *GitHubV3RESTAPIClient) AppsListSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, options *GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserStubbedOptions) (GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserStubbedResponse, error) {
	req, err := client.appsListSubscriptionsForAuthenticatedUserStubbedCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserStubbedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserStubbedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized) {
		return GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserStubbedResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsListSubscriptionsForAuthenticatedUserStubbedHandleResponse(resp)
}

// appsListSubscriptionsForAuthenticatedUserStubbedCreateRequest creates the AppsListSubscriptionsForAuthenticatedUserStubbed request.
func (client *GitHubV3RESTAPIClient) appsListSubscriptionsForAuthenticatedUserStubbedCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserStubbedOptions) (*policy.Request, error) {
	urlPath := "/user/marketplace_purchases/stubbed"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsListSubscriptionsForAuthenticatedUserStubbedHandleResponse handles the AppsListSubscriptionsForAuthenticatedUserStubbed response.
func (client *GitHubV3RESTAPIClient) appsListSubscriptionsForAuthenticatedUserStubbedHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserStubbedResponse, error) {
	result := GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserStubbedResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*UserMarketplacePurchase
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserStubbedResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserStubbedResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsListSubscriptionsForAuthenticatedUserStubbedResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsListWebhookDeliveries - Returns a list of webhook deliveries for the webhook configured for a GitHub App.
// You must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsListWebhookDeliveriesOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsListWebhookDeliveries
//     method.
func (client *GitHubV3RESTAPIClient) AppsListWebhookDeliveries(ctx context.Context, options *GitHubV3RESTAPIClientAppsListWebhookDeliveriesOptions) (GitHubV3RESTAPIClientAppsListWebhookDeliveriesResponse, error) {
	req, err := client.appsListWebhookDeliveriesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListWebhookDeliveriesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsListWebhookDeliveriesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientAppsListWebhookDeliveriesResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsListWebhookDeliveriesHandleResponse(resp)
}

// appsListWebhookDeliveriesCreateRequest creates the AppsListWebhookDeliveries request.
func (client *GitHubV3RESTAPIClient) appsListWebhookDeliveriesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsListWebhookDeliveriesOptions) (*policy.Request, error) {
	urlPath := "/app/hook/deliveries"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.cursor != nil {
		reqQP.Set("cursor", *client.cursor)
	}
	if options != nil && options.Redelivery != nil {
		reqQP.Set("redelivery", strconv.FormatBool(*options.Redelivery))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// appsListWebhookDeliveriesHandleResponse handles the AppsListWebhookDeliveries response.
func (client *GitHubV3RESTAPIClient) appsListWebhookDeliveriesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsListWebhookDeliveriesResponse, error) {
	result := GitHubV3RESTAPIClientAppsListWebhookDeliveriesResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*HookDeliveryItem
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListWebhookDeliveriesResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListWebhookDeliveriesResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsListWebhookDeliveriesResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsListWebhookDeliveriesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsRedeliverWebhookDelivery - Redeliver a delivery for the webhook configured for a GitHub App.
// You must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsRedeliverWebhookDeliveryOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsRedeliverWebhookDelivery
//     method.
func (client *GitHubV3RESTAPIClient) AppsRedeliverWebhookDelivery(ctx context.Context, options *GitHubV3RESTAPIClientAppsRedeliverWebhookDeliveryOptions) (GitHubV3RESTAPIClientAppsRedeliverWebhookDeliveryResponse, error) {
	req, err := client.appsRedeliverWebhookDeliveryCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsRedeliverWebhookDeliveryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsRedeliverWebhookDeliveryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusBadRequest, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientAppsRedeliverWebhookDeliveryResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsRedeliverWebhookDeliveryHandleResponse(resp)
}

// appsRedeliverWebhookDeliveryCreateRequest creates the AppsRedeliverWebhookDelivery request.
func (client *GitHubV3RESTAPIClient) appsRedeliverWebhookDeliveryCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsRedeliverWebhookDeliveryOptions) (*policy.Request, error) {
	urlPath := "/app/hook/deliveries/{delivery_id}/attempts"
	urlPath = strings.ReplaceAll(urlPath, "{delivery_id}", url.PathEscape(strconv.FormatInt(int64(client.deliveryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// appsRedeliverWebhookDeliveryHandleResponse handles the AppsRedeliverWebhookDelivery response.
func (client *GitHubV3RESTAPIClient) appsRedeliverWebhookDeliveryHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsRedeliverWebhookDeliveryResponse, error) {
	result := GitHubV3RESTAPIClientAppsRedeliverWebhookDeliveryResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsRedeliverWebhookDeliveryResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsRedeliverWebhookDeliveryResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsRedeliverWebhookDeliveryResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsRedeliverWebhookDeliveryResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsRemoveRepoFromInstallationForAuthenticatedUser - Remove a single repository from an installation. The authenticated
// user must have admin access to the repository.
// You must use a personal access token (which you can create via the command line [https://docs.github.com/github/authenticating-to-github/creating-a-personal-access-token]
// or Basic Authentication
// [https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication]) to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsRemoveRepoFromInstallationForAuthenticatedUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.AppsRemoveRepoFromInstallationForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) AppsRemoveRepoFromInstallationForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientAppsRemoveRepoFromInstallationForAuthenticatedUserOptions) (GitHubV3RESTAPIClientAppsRemoveRepoFromInstallationForAuthenticatedUserResponse, error) {
	req, err := client.appsRemoveRepoFromInstallationForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsRemoveRepoFromInstallationForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsRemoveRepoFromInstallationForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientAppsRemoveRepoFromInstallationForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsRemoveRepoFromInstallationForAuthenticatedUserHandleResponse(resp)
}

// appsRemoveRepoFromInstallationForAuthenticatedUserCreateRequest creates the AppsRemoveRepoFromInstallationForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) appsRemoveRepoFromInstallationForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsRemoveRepoFromInstallationForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/installations/{installation_id}/repositories/{repository_id}"
	urlPath = strings.ReplaceAll(urlPath, "{installation_id}", url.PathEscape(strconv.FormatInt(int64(client.installationID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsRemoveRepoFromInstallationForAuthenticatedUserHandleResponse handles the AppsRemoveRepoFromInstallationForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) appsRemoveRepoFromInstallationForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsRemoveRepoFromInstallationForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientAppsRemoveRepoFromInstallationForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientAppsRemoveRepoFromInstallationForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// AppsResetToken - OAuth applications can use this API method to reset a valid OAuth token without end-user involvement.
// Applications must save the "token" property in the response because changes take effect
// immediately. You must use Basic Authentication [https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication]
// when accessing this endpoint, using the OAuth application's
// clientid and clientsecret as the username and password. Invalid tokens will return 404 NOT FOUND.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsResetTokenOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsResetToken
//     method.
func (client *GitHubV3RESTAPIClient) AppsResetToken(ctx context.Context, body Paths1K6Pj3BApplicationsClientIDTokenPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientAppsResetTokenOptions) (GitHubV3RESTAPIClientAppsResetTokenResponse, error) {
	req, err := client.appsResetTokenCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsResetTokenResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsResetTokenResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientAppsResetTokenResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsResetTokenHandleResponse(resp)
}

// appsResetTokenCreateRequest creates the AppsResetToken request.
func (client *GitHubV3RESTAPIClient) appsResetTokenCreateRequest(ctx context.Context, body Paths1K6Pj3BApplicationsClientIDTokenPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientAppsResetTokenOptions) (*policy.Request, error) {
	urlPath := "/applications/{client_id}/token"
	if client.clientID == "" {
		return nil, errors.New("parameter client.clientID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{client_id}", url.PathEscape(client.clientID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// appsResetTokenHandleResponse handles the AppsResetToken response.
func (client *GitHubV3RESTAPIClient) appsResetTokenHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsResetTokenResponse, error) {
	result := GitHubV3RESTAPIClientAppsResetTokenResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Authorization
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsResetTokenResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsResetTokenResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsResetTokenResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsRevokeInstallationAccessToken - Revokes the installation token you're using to authenticate as an installation and
// access this endpoint.
// Once an installation token is revoked, the token is invalidated and cannot be used. Other endpoints that require the revoked
// installation token must have a new installation token to work. You can
// create a new token using the "Create an installation access token for an app [https://docs.github.com/rest/reference/apps#create-an-installation-access-token-for-an-app]"
// endpoint.
// You must use an installation access token [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsRevokeInstallationAccessTokenOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsRevokeInstallationAccessToken
//     method.
func (client *GitHubV3RESTAPIClient) AppsRevokeInstallationAccessToken(ctx context.Context, options *GitHubV3RESTAPIClientAppsRevokeInstallationAccessTokenOptions) (GitHubV3RESTAPIClientAppsRevokeInstallationAccessTokenResponse, error) {
	req, err := client.appsRevokeInstallationAccessTokenCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsRevokeInstallationAccessTokenResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsRevokeInstallationAccessTokenResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientAppsRevokeInstallationAccessTokenResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientAppsRevokeInstallationAccessTokenResponse{}, nil
}

// appsRevokeInstallationAccessTokenCreateRequest creates the AppsRevokeInstallationAccessToken request.
func (client *GitHubV3RESTAPIClient) appsRevokeInstallationAccessTokenCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsRevokeInstallationAccessTokenOptions) (*policy.Request, error) {
	urlPath := "/installation/token"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// AppsScopeToken - Use a non-scoped user-to-server access token to create a repository scoped and/or permission scoped user-to-server
// access token. You can specify which repositories the token can access and which
// permissions are granted to the token. You must use Basic Authentication [https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication]
// when accessing this endpoint, using
// the clientid and clientsecret of the GitHub App as the username and password. Invalid tokens will return 404 NOT FOUND.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsScopeTokenOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsScopeToken
//     method.
func (client *GitHubV3RESTAPIClient) AppsScopeToken(ctx context.Context, body Paths1Pfvnv0ApplicationsClientIDTokenScopedPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientAppsScopeTokenOptions) (GitHubV3RESTAPIClientAppsScopeTokenResponse, error) {
	req, err := client.appsScopeTokenCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsScopeTokenResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsScopeTokenResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientAppsScopeTokenResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsScopeTokenHandleResponse(resp)
}

// appsScopeTokenCreateRequest creates the AppsScopeToken request.
func (client *GitHubV3RESTAPIClient) appsScopeTokenCreateRequest(ctx context.Context, body Paths1Pfvnv0ApplicationsClientIDTokenScopedPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientAppsScopeTokenOptions) (*policy.Request, error) {
	urlPath := "/applications/{client_id}/token/scoped"
	if client.clientID == "" {
		return nil, errors.New("parameter client.clientID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{client_id}", url.PathEscape(client.clientID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// appsScopeTokenHandleResponse handles the AppsScopeToken response.
func (client *GitHubV3RESTAPIClient) appsScopeTokenHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsScopeTokenResponse, error) {
	result := GitHubV3RESTAPIClientAppsScopeTokenResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Authorization
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsScopeTokenResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsScopeTokenResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsScopeTokenResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsScopeTokenResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientAppsScopeTokenResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientAppsScopeTokenResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// AppsSuspendInstallation - Suspends a GitHub App on a user, organization, or business account, which blocks the app from
// accessing the account's resources. When a GitHub App is suspended, the app's access to the GitHub API or
// webhook events is blocked for that account.
// You must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsSuspendInstallationOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsSuspendInstallation
//     method.
func (client *GitHubV3RESTAPIClient) AppsSuspendInstallation(ctx context.Context, options *GitHubV3RESTAPIClientAppsSuspendInstallationOptions) (GitHubV3RESTAPIClientAppsSuspendInstallationResponse, error) {
	req, err := client.appsSuspendInstallationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsSuspendInstallationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsSuspendInstallationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientAppsSuspendInstallationResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsSuspendInstallationHandleResponse(resp)
}

// appsSuspendInstallationCreateRequest creates the AppsSuspendInstallation request.
func (client *GitHubV3RESTAPIClient) appsSuspendInstallationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsSuspendInstallationOptions) (*policy.Request, error) {
	urlPath := "/app/installations/{installation_id}/suspended"
	urlPath = strings.ReplaceAll(urlPath, "{installation_id}", url.PathEscape(strconv.FormatInt(int64(client.installationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsSuspendInstallationHandleResponse handles the AppsSuspendInstallation response.
func (client *GitHubV3RESTAPIClient) appsSuspendInstallationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsSuspendInstallationResponse, error) {
	result := GitHubV3RESTAPIClientAppsSuspendInstallationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientAppsSuspendInstallationResponse{}, err
	}
	return result, nil
}

// AppsUnsuspendInstallation - Removes a GitHub App installation suspension.
// You must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsUnsuspendInstallationOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsUnsuspendInstallation
//     method.
func (client *GitHubV3RESTAPIClient) AppsUnsuspendInstallation(ctx context.Context, options *GitHubV3RESTAPIClientAppsUnsuspendInstallationOptions) (GitHubV3RESTAPIClientAppsUnsuspendInstallationResponse, error) {
	req, err := client.appsUnsuspendInstallationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsUnsuspendInstallationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsUnsuspendInstallationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientAppsUnsuspendInstallationResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsUnsuspendInstallationHandleResponse(resp)
}

// appsUnsuspendInstallationCreateRequest creates the AppsUnsuspendInstallation request.
func (client *GitHubV3RESTAPIClient) appsUnsuspendInstallationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientAppsUnsuspendInstallationOptions) (*policy.Request, error) {
	urlPath := "/app/installations/{installation_id}/suspended"
	urlPath = strings.ReplaceAll(urlPath, "{installation_id}", url.PathEscape(strconv.FormatInt(int64(client.installationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// appsUnsuspendInstallationHandleResponse handles the AppsUnsuspendInstallation response.
func (client *GitHubV3RESTAPIClient) appsUnsuspendInstallationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsUnsuspendInstallationResponse, error) {
	result := GitHubV3RESTAPIClientAppsUnsuspendInstallationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientAppsUnsuspendInstallationResponse{}, err
	}
	return result, nil
}

// AppsUpdateWebhookConfigForApp - Updates the webhook configuration for a GitHub App. For more information about configuring
// a webhook for your app, see "Creating a GitHub App [/developers/apps/creating-a-github-app]."
// You must use a JWT [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app]
// to access this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientAppsUpdateWebhookConfigForAppOptions contains the optional parameters for the GitHubV3RESTAPIClient.AppsUpdateWebhookConfigForApp
//     method.
func (client *GitHubV3RESTAPIClient) AppsUpdateWebhookConfigForApp(ctx context.Context, body Paths1Jt5S7KAppHookConfigPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientAppsUpdateWebhookConfigForAppOptions) (GitHubV3RESTAPIClientAppsUpdateWebhookConfigForAppResponse, error) {
	req, err := client.appsUpdateWebhookConfigForAppCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientAppsUpdateWebhookConfigForAppResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientAppsUpdateWebhookConfigForAppResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientAppsUpdateWebhookConfigForAppResponse{}, runtime.NewResponseError(resp)
	}
	return client.appsUpdateWebhookConfigForAppHandleResponse(resp)
}

// appsUpdateWebhookConfigForAppCreateRequest creates the AppsUpdateWebhookConfigForApp request.
func (client *GitHubV3RESTAPIClient) appsUpdateWebhookConfigForAppCreateRequest(ctx context.Context, body Paths1Jt5S7KAppHookConfigPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientAppsUpdateWebhookConfigForAppOptions) (*policy.Request, error) {
	urlPath := "/app/hook/config"
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// appsUpdateWebhookConfigForAppHandleResponse handles the AppsUpdateWebhookConfigForApp response.
func (client *GitHubV3RESTAPIClient) appsUpdateWebhookConfigForAppHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientAppsUpdateWebhookConfigForAppResponse, error) {
	result := GitHubV3RESTAPIClientAppsUpdateWebhookConfigForAppResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebhookConfig); err != nil {
		return GitHubV3RESTAPIClientAppsUpdateWebhookConfigForAppResponse{}, err
	}
	return result, nil
}

// BillingGetGithubActionsBillingOrg - Gets the summary of the free and paid GitHub Actions minutes used.
// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners. Minutes used is listed for
// each GitHub-hosted runner operating system. Any job re-runs are also included in
// the usage. The usage returned includes any minute multipliers for macOS and Windows runners, and is rounded up to the nearest
// whole minute. For more information, see "Managing billing for GitHub
// Actions [https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions]".
// Access tokens must have the repo or admin:org scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientBillingGetGithubActionsBillingOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.BillingGetGithubActionsBillingOrg
//     method.
func (client *GitHubV3RESTAPIClient) BillingGetGithubActionsBillingOrg(ctx context.Context, options *GitHubV3RESTAPIClientBillingGetGithubActionsBillingOrgOptions) (GitHubV3RESTAPIClientBillingGetGithubActionsBillingOrgResponse, error) {
	req, err := client.billingGetGithubActionsBillingOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientBillingGetGithubActionsBillingOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientBillingGetGithubActionsBillingOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientBillingGetGithubActionsBillingOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.billingGetGithubActionsBillingOrgHandleResponse(resp)
}

// billingGetGithubActionsBillingOrgCreateRequest creates the BillingGetGithubActionsBillingOrg request.
func (client *GitHubV3RESTAPIClient) billingGetGithubActionsBillingOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientBillingGetGithubActionsBillingOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/settings/billing/actions"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// billingGetGithubActionsBillingOrgHandleResponse handles the BillingGetGithubActionsBillingOrg response.
func (client *GitHubV3RESTAPIClient) billingGetGithubActionsBillingOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientBillingGetGithubActionsBillingOrgResponse, error) {
	result := GitHubV3RESTAPIClientBillingGetGithubActionsBillingOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsBillingUsage); err != nil {
		return GitHubV3RESTAPIClientBillingGetGithubActionsBillingOrgResponse{}, err
	}
	return result, nil
}

// BillingGetGithubActionsBillingUser - Gets the summary of the free and paid GitHub Actions minutes used.
// Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners. Minutes used is listed for
// each GitHub-hosted runner operating system. Any job re-runs are also included in
// the usage. The usage returned includes any minute multipliers for macOS and Windows runners, and is rounded up to the nearest
// whole minute. For more information, see "Managing billing for GitHub
// Actions [https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions]".
// Access tokens must have the user scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientBillingGetGithubActionsBillingUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.BillingGetGithubActionsBillingUser
//     method.
func (client *GitHubV3RESTAPIClient) BillingGetGithubActionsBillingUser(ctx context.Context, options *GitHubV3RESTAPIClientBillingGetGithubActionsBillingUserOptions) (GitHubV3RESTAPIClientBillingGetGithubActionsBillingUserResponse, error) {
	req, err := client.billingGetGithubActionsBillingUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientBillingGetGithubActionsBillingUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientBillingGetGithubActionsBillingUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientBillingGetGithubActionsBillingUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.billingGetGithubActionsBillingUserHandleResponse(resp)
}

// billingGetGithubActionsBillingUserCreateRequest creates the BillingGetGithubActionsBillingUser request.
func (client *GitHubV3RESTAPIClient) billingGetGithubActionsBillingUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientBillingGetGithubActionsBillingUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/settings/billing/actions"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// billingGetGithubActionsBillingUserHandleResponse handles the BillingGetGithubActionsBillingUser response.
func (client *GitHubV3RESTAPIClient) billingGetGithubActionsBillingUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientBillingGetGithubActionsBillingUserResponse, error) {
	result := GitHubV3RESTAPIClientBillingGetGithubActionsBillingUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ActionsBillingUsage); err != nil {
		return GitHubV3RESTAPIClientBillingGetGithubActionsBillingUserResponse{}, err
	}
	return result, nil
}

// BillingGetGithubPackagesBillingOrg - Gets the free and paid storage used for GitHub Packages in gigabytes.
// Paid minutes only apply to packages stored for private repositories. For more information, see "Managing billing for GitHub
// Packages
// [https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages]."
// Access tokens must have the repo or admin:org scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientBillingGetGithubPackagesBillingOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.BillingGetGithubPackagesBillingOrg
//     method.
func (client *GitHubV3RESTAPIClient) BillingGetGithubPackagesBillingOrg(ctx context.Context, options *GitHubV3RESTAPIClientBillingGetGithubPackagesBillingOrgOptions) (GitHubV3RESTAPIClientBillingGetGithubPackagesBillingOrgResponse, error) {
	req, err := client.billingGetGithubPackagesBillingOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientBillingGetGithubPackagesBillingOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientBillingGetGithubPackagesBillingOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientBillingGetGithubPackagesBillingOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.billingGetGithubPackagesBillingOrgHandleResponse(resp)
}

// billingGetGithubPackagesBillingOrgCreateRequest creates the BillingGetGithubPackagesBillingOrg request.
func (client *GitHubV3RESTAPIClient) billingGetGithubPackagesBillingOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientBillingGetGithubPackagesBillingOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/settings/billing/packages"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// billingGetGithubPackagesBillingOrgHandleResponse handles the BillingGetGithubPackagesBillingOrg response.
func (client *GitHubV3RESTAPIClient) billingGetGithubPackagesBillingOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientBillingGetGithubPackagesBillingOrgResponse, error) {
	result := GitHubV3RESTAPIClientBillingGetGithubPackagesBillingOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PackagesBillingUsage); err != nil {
		return GitHubV3RESTAPIClientBillingGetGithubPackagesBillingOrgResponse{}, err
	}
	return result, nil
}

// BillingGetGithubPackagesBillingUser - Gets the free and paid storage used for GitHub Packages in gigabytes.
// Paid minutes only apply to packages stored for private repositories. For more information, see "Managing billing for GitHub
// Packages
// [https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages]."
// Access tokens must have the user scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientBillingGetGithubPackagesBillingUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.BillingGetGithubPackagesBillingUser
//     method.
func (client *GitHubV3RESTAPIClient) BillingGetGithubPackagesBillingUser(ctx context.Context, options *GitHubV3RESTAPIClientBillingGetGithubPackagesBillingUserOptions) (GitHubV3RESTAPIClientBillingGetGithubPackagesBillingUserResponse, error) {
	req, err := client.billingGetGithubPackagesBillingUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientBillingGetGithubPackagesBillingUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientBillingGetGithubPackagesBillingUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientBillingGetGithubPackagesBillingUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.billingGetGithubPackagesBillingUserHandleResponse(resp)
}

// billingGetGithubPackagesBillingUserCreateRequest creates the BillingGetGithubPackagesBillingUser request.
func (client *GitHubV3RESTAPIClient) billingGetGithubPackagesBillingUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientBillingGetGithubPackagesBillingUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/settings/billing/packages"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// billingGetGithubPackagesBillingUserHandleResponse handles the BillingGetGithubPackagesBillingUser response.
func (client *GitHubV3RESTAPIClient) billingGetGithubPackagesBillingUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientBillingGetGithubPackagesBillingUserResponse, error) {
	result := GitHubV3RESTAPIClientBillingGetGithubPackagesBillingUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PackagesBillingUsage); err != nil {
		return GitHubV3RESTAPIClientBillingGetGithubPackagesBillingUserResponse{}, err
	}
	return result, nil
}

// BillingGetSharedStorageBillingOrg - Gets the estimated paid and estimated total storage used for GitHub Actions and GitHub
// Packages.
// Paid minutes only apply to packages stored for private repositories. For more information, see "Managing billing for GitHub
// Packages
// [https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages]."
// Access tokens must have the repo or admin:org scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientBillingGetSharedStorageBillingOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.BillingGetSharedStorageBillingOrg
//     method.
func (client *GitHubV3RESTAPIClient) BillingGetSharedStorageBillingOrg(ctx context.Context, options *GitHubV3RESTAPIClientBillingGetSharedStorageBillingOrgOptions) (GitHubV3RESTAPIClientBillingGetSharedStorageBillingOrgResponse, error) {
	req, err := client.billingGetSharedStorageBillingOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientBillingGetSharedStorageBillingOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientBillingGetSharedStorageBillingOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientBillingGetSharedStorageBillingOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.billingGetSharedStorageBillingOrgHandleResponse(resp)
}

// billingGetSharedStorageBillingOrgCreateRequest creates the BillingGetSharedStorageBillingOrg request.
func (client *GitHubV3RESTAPIClient) billingGetSharedStorageBillingOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientBillingGetSharedStorageBillingOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/settings/billing/shared-storage"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// billingGetSharedStorageBillingOrgHandleResponse handles the BillingGetSharedStorageBillingOrg response.
func (client *GitHubV3RESTAPIClient) billingGetSharedStorageBillingOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientBillingGetSharedStorageBillingOrgResponse, error) {
	result := GitHubV3RESTAPIClientBillingGetSharedStorageBillingOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CombinedBillingUsage); err != nil {
		return GitHubV3RESTAPIClientBillingGetSharedStorageBillingOrgResponse{}, err
	}
	return result, nil
}

// BillingGetSharedStorageBillingUser - Gets the estimated paid and estimated total storage used for GitHub Actions and GitHub
// Packages.
// Paid minutes only apply to packages stored for private repositories. For more information, see "Managing billing for GitHub
// Packages
// [https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages]."
// Access tokens must have the user scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientBillingGetSharedStorageBillingUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.BillingGetSharedStorageBillingUser
//     method.
func (client *GitHubV3RESTAPIClient) BillingGetSharedStorageBillingUser(ctx context.Context, options *GitHubV3RESTAPIClientBillingGetSharedStorageBillingUserOptions) (GitHubV3RESTAPIClientBillingGetSharedStorageBillingUserResponse, error) {
	req, err := client.billingGetSharedStorageBillingUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientBillingGetSharedStorageBillingUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientBillingGetSharedStorageBillingUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientBillingGetSharedStorageBillingUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.billingGetSharedStorageBillingUserHandleResponse(resp)
}

// billingGetSharedStorageBillingUserCreateRequest creates the BillingGetSharedStorageBillingUser request.
func (client *GitHubV3RESTAPIClient) billingGetSharedStorageBillingUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientBillingGetSharedStorageBillingUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/settings/billing/shared-storage"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// billingGetSharedStorageBillingUserHandleResponse handles the BillingGetSharedStorageBillingUser response.
func (client *GitHubV3RESTAPIClient) billingGetSharedStorageBillingUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientBillingGetSharedStorageBillingUserResponse, error) {
	result := GitHubV3RESTAPIClientBillingGetSharedStorageBillingUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CombinedBillingUsage); err != nil {
		return GitHubV3RESTAPIClientBillingGetSharedStorageBillingUserResponse{}, err
	}
	return result, nil
}

// ChecksCreate - Note: The Checks API only looks for pushes in the repository where the check suite or check run were created.
// Pushes to a branch in a forked repository are not detected and return an empty
// pull_requests array.
// Creates a new check run for a specific commit in a repository. Your GitHub App must have the checks:write permission to
// create check runs.
// In a check suite, GitHub limits the number of check runs with the same name to 1000. Once these check runs exceed 1000,
// GitHub will start to automatically delete older check runs.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientChecksCreateOptions contains the optional parameters for the GitHubV3RESTAPIClient.ChecksCreate
//     method.
func (client *GitHubV3RESTAPIClient) ChecksCreate(ctx context.Context, body Paths1Vfi8L3ReposOwnerRepoCheckRunsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientChecksCreateOptions) (GitHubV3RESTAPIClientChecksCreateResponse, error) {
	req, err := client.checksCreateCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientChecksCreateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientChecksCreateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientChecksCreateResponse{}, runtime.NewResponseError(resp)
	}
	return client.checksCreateHandleResponse(resp)
}

// checksCreateCreateRequest creates the ChecksCreate request.
func (client *GitHubV3RESTAPIClient) checksCreateCreateRequest(ctx context.Context, body Paths1Vfi8L3ReposOwnerRepoCheckRunsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientChecksCreateOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/check-runs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// checksCreateHandleResponse handles the ChecksCreate response.
func (client *GitHubV3RESTAPIClient) checksCreateHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientChecksCreateResponse, error) {
	result := GitHubV3RESTAPIClientChecksCreateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CheckRun); err != nil {
		return GitHubV3RESTAPIClientChecksCreateResponse{}, err
	}
	return result, nil
}

// ChecksCreateSuite - Note: The Checks API only looks for pushes in the repository where the check suite or check run were
// created. Pushes to a branch in a forked repository are not detected and return an empty pull
// requests array and a null value for headbranch.
// By default, check suites are automatically created when you create a check run [https://docs.github.com/rest/reference/checks#check-runs].
// You only need to use this endpoint for manually creating
// check suites when you've disabled automatic creation using "Update repository preferences for check suites
// [https://docs.github.com/rest/reference/checks#update-repository-preferences-for-check-suites]". Your GitHub App must have
// the checks:write permission to create check suites.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientChecksCreateSuiteOptions contains the optional parameters for the GitHubV3RESTAPIClient.ChecksCreateSuite
//     method.
func (client *GitHubV3RESTAPIClient) ChecksCreateSuite(ctx context.Context, body Paths1Qus9PuReposOwnerRepoCheckSuitesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientChecksCreateSuiteOptions) (GitHubV3RESTAPIClientChecksCreateSuiteResponse, error) {
	req, err := client.checksCreateSuiteCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientChecksCreateSuiteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientChecksCreateSuiteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return GitHubV3RESTAPIClientChecksCreateSuiteResponse{}, runtime.NewResponseError(resp)
	}
	return client.checksCreateSuiteHandleResponse(resp)
}

// checksCreateSuiteCreateRequest creates the ChecksCreateSuite request.
func (client *GitHubV3RESTAPIClient) checksCreateSuiteCreateRequest(ctx context.Context, body Paths1Qus9PuReposOwnerRepoCheckSuitesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientChecksCreateSuiteOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/check-suites"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// checksCreateSuiteHandleResponse handles the ChecksCreateSuite response.
func (client *GitHubV3RESTAPIClient) checksCreateSuiteHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientChecksCreateSuiteResponse, error) {
	result := GitHubV3RESTAPIClientChecksCreateSuiteResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CheckSuite); err != nil {
		return GitHubV3RESTAPIClientChecksCreateSuiteResponse{}, err
	}
	return result, nil
}

// ChecksGet - Note: The Checks API only looks for pushes in the repository where the check suite or check run were created.
// Pushes to a branch in a forked repository are not detected and return an empty
// pull_requests array.
// Gets a single check run using its id. GitHub Apps must have the checks:read permission on a private repository or pull
// access to a public repository to get check runs. OAuth Apps and authenticated
// users must have the repo scope to get check runs in a private repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientChecksGetOptions contains the optional parameters for the GitHubV3RESTAPIClient.ChecksGet
//     method.
func (client *GitHubV3RESTAPIClient) ChecksGet(ctx context.Context, options *GitHubV3RESTAPIClientChecksGetOptions) (GitHubV3RESTAPIClientChecksGetResponse, error) {
	req, err := client.checksGetCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientChecksGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientChecksGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientChecksGetResponse{}, runtime.NewResponseError(resp)
	}
	return client.checksGetHandleResponse(resp)
}

// checksGetCreateRequest creates the ChecksGet request.
func (client *GitHubV3RESTAPIClient) checksGetCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientChecksGetOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/check-runs/{check_run_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{check_run_id}", url.PathEscape(strconv.FormatInt(int64(client.checkRunID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// checksGetHandleResponse handles the ChecksGet response.
func (client *GitHubV3RESTAPIClient) checksGetHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientChecksGetResponse, error) {
	result := GitHubV3RESTAPIClientChecksGetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CheckRun); err != nil {
		return GitHubV3RESTAPIClientChecksGetResponse{}, err
	}
	return result, nil
}

// ChecksGetSuite - Note: The Checks API only looks for pushes in the repository where the check suite or check run were created.
// Pushes to a branch in a forked repository are not detected and return an empty pull
// requests array and a null value for headbranch.
// Gets a single check suite using its id. GitHub Apps must have the checks:read permission on a private repository or pull
// access to a public repository to get check suites. OAuth Apps and authenticated
// users must have the repo scope to get check suites in a private repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientChecksGetSuiteOptions contains the optional parameters for the GitHubV3RESTAPIClient.ChecksGetSuite
//     method.
func (client *GitHubV3RESTAPIClient) ChecksGetSuite(ctx context.Context, options *GitHubV3RESTAPIClientChecksGetSuiteOptions) (GitHubV3RESTAPIClientChecksGetSuiteResponse, error) {
	req, err := client.checksGetSuiteCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientChecksGetSuiteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientChecksGetSuiteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientChecksGetSuiteResponse{}, runtime.NewResponseError(resp)
	}
	return client.checksGetSuiteHandleResponse(resp)
}

// checksGetSuiteCreateRequest creates the ChecksGetSuite request.
func (client *GitHubV3RESTAPIClient) checksGetSuiteCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientChecksGetSuiteOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/check-suites/{check_suite_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.checkSuiteID != nil {
		reqQP.Set("check_suite_id", strconv.FormatInt(int64(*client.checkSuiteID), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// checksGetSuiteHandleResponse handles the ChecksGetSuite response.
func (client *GitHubV3RESTAPIClient) checksGetSuiteHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientChecksGetSuiteResponse, error) {
	result := GitHubV3RESTAPIClientChecksGetSuiteResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CheckSuite); err != nil {
		return GitHubV3RESTAPIClientChecksGetSuiteResponse{}, err
	}
	return result, nil
}

// ChecksListAnnotations - Lists annotations for a check run using the annotation id. GitHub Apps must have the checks:read
// permission on a private repository or pull access to a public repository to get annotations for a check
// run. OAuth Apps and authenticated users must have the repo scope to get annotations for a check run in a private repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientChecksListAnnotationsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ChecksListAnnotations
//     method.
func (client *GitHubV3RESTAPIClient) ChecksListAnnotations(ctx context.Context, options *GitHubV3RESTAPIClientChecksListAnnotationsOptions) (GitHubV3RESTAPIClientChecksListAnnotationsResponse, error) {
	req, err := client.checksListAnnotationsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientChecksListAnnotationsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientChecksListAnnotationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientChecksListAnnotationsResponse{}, runtime.NewResponseError(resp)
	}
	return client.checksListAnnotationsHandleResponse(resp)
}

// checksListAnnotationsCreateRequest creates the ChecksListAnnotations request.
func (client *GitHubV3RESTAPIClient) checksListAnnotationsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientChecksListAnnotationsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{check_run_id}", url.PathEscape(strconv.FormatInt(int64(client.checkRunID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// checksListAnnotationsHandleResponse handles the ChecksListAnnotations response.
func (client *GitHubV3RESTAPIClient) checksListAnnotationsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientChecksListAnnotationsResponse, error) {
	result := GitHubV3RESTAPIClientChecksListAnnotationsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.CheckAnnotationArray); err != nil {
		return GitHubV3RESTAPIClientChecksListAnnotationsResponse{}, err
	}
	return result, nil
}

// ChecksListForRef - Note: The Checks API only looks for pushes in the repository where the check suite or check run were
// created. Pushes to a branch in a forked repository are not detected and return an empty
// pull_requests array.
// Lists check runs for a commit ref. The ref can be a SHA, branch name, or a tag name. GitHub Apps must have the checks:read
// permission on a private repository or pull access to a public repository to
// get check runs. OAuth Apps and authenticated users must have the repo scope to get check runs in a private repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - ref - ref parameter
//   - options - GitHubV3RESTAPIClientChecksListForRefOptions contains the optional parameters for the GitHubV3RESTAPIClient.ChecksListForRef
//     method.
func (client *GitHubV3RESTAPIClient) ChecksListForRef(ctx context.Context, ref string, options *GitHubV3RESTAPIClientChecksListForRefOptions) (GitHubV3RESTAPIClientChecksListForRefResponse, error) {
	req, err := client.checksListForRefCreateRequest(ctx, ref, options)
	if err != nil {
		return GitHubV3RESTAPIClientChecksListForRefResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientChecksListForRefResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientChecksListForRefResponse{}, runtime.NewResponseError(resp)
	}
	return client.checksListForRefHandleResponse(resp)
}

// checksListForRefCreateRequest creates the ChecksListForRef request.
func (client *GitHubV3RESTAPIClient) checksListForRefCreateRequest(ctx context.Context, ref string, options *GitHubV3RESTAPIClientChecksListForRefOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/commits/{ref}/check-runs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if ref == "" {
		return nil, errors.New("parameter ref cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{ref}", url.PathEscape(ref))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.checkName != nil {
		reqQP.Set("check_name", *client.checkName)
	}
	if client.status != nil {
		reqQP.Set("status", string(*client.status))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", string(*options.Filter))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if options != nil && options.AppID != nil {
		reqQP.Set("app_id", strconv.FormatInt(int64(*options.AppID), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// checksListForRefHandleResponse handles the ChecksListForRef response.
func (client *GitHubV3RESTAPIClient) checksListForRefHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientChecksListForRefResponse, error) {
	result := GitHubV3RESTAPIClientChecksListForRefResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsFla86QReposOwnerRepoCommitsRefCheckRunsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientChecksListForRefResponse{}, err
	}
	return result, nil
}

// ChecksListForSuite - Note: The Checks API only looks for pushes in the repository where the check suite or check run were
// created. Pushes to a branch in a forked repository are not detected and return an empty
// pull_requests array.
// Lists check runs for a check suite using its id. GitHub Apps must have the checks:read permission on a private repository
// or pull access to a public repository to get check runs. OAuth Apps and
// authenticated users must have the repo scope to get check runs in a private repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientChecksListForSuiteOptions contains the optional parameters for the GitHubV3RESTAPIClient.ChecksListForSuite
//     method.
func (client *GitHubV3RESTAPIClient) ChecksListForSuite(ctx context.Context, options *GitHubV3RESTAPIClientChecksListForSuiteOptions) (GitHubV3RESTAPIClientChecksListForSuiteResponse, error) {
	req, err := client.checksListForSuiteCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientChecksListForSuiteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientChecksListForSuiteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientChecksListForSuiteResponse{}, runtime.NewResponseError(resp)
	}
	return client.checksListForSuiteHandleResponse(resp)
}

// checksListForSuiteCreateRequest creates the ChecksListForSuite request.
func (client *GitHubV3RESTAPIClient) checksListForSuiteCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientChecksListForSuiteOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.checkSuiteID != nil {
		reqQP.Set("check_suite_id", strconv.FormatInt(int64(*client.checkSuiteID), 10))
	}
	if client.checkName != nil {
		reqQP.Set("check_name", *client.checkName)
	}
	if client.status != nil {
		reqQP.Set("status", string(*client.status))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", string(*options.Filter))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// checksListForSuiteHandleResponse handles the ChecksListForSuite response.
func (client *GitHubV3RESTAPIClient) checksListForSuiteHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientChecksListForSuiteResponse, error) {
	result := GitHubV3RESTAPIClientChecksListForSuiteResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths3Snn0EReposOwnerRepoCheckSuitesCheckSuiteIDCheckRunsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientChecksListForSuiteResponse{}, err
	}
	return result, nil
}

// ChecksListSuitesForRef - Note: The Checks API only looks for pushes in the repository where the check suite or check run
// were created. Pushes to a branch in a forked repository are not detected and return an empty pull
// requests array and a null value for headbranch.
// Lists check suites for a commit ref. The ref can be a SHA, branch name, or a tag name. GitHub Apps must have the checks:read
// permission on a private repository or pull access to a public repository to
// list check suites. OAuth Apps and authenticated users must have the repo scope to get check suites in a private repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - ref - ref parameter
//   - options - GitHubV3RESTAPIClientChecksListSuitesForRefOptions contains the optional parameters for the GitHubV3RESTAPIClient.ChecksListSuitesForRef
//     method.
func (client *GitHubV3RESTAPIClient) ChecksListSuitesForRef(ctx context.Context, ref string, options *GitHubV3RESTAPIClientChecksListSuitesForRefOptions) (GitHubV3RESTAPIClientChecksListSuitesForRefResponse, error) {
	req, err := client.checksListSuitesForRefCreateRequest(ctx, ref, options)
	if err != nil {
		return GitHubV3RESTAPIClientChecksListSuitesForRefResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientChecksListSuitesForRefResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientChecksListSuitesForRefResponse{}, runtime.NewResponseError(resp)
	}
	return client.checksListSuitesForRefHandleResponse(resp)
}

// checksListSuitesForRefCreateRequest creates the ChecksListSuitesForRef request.
func (client *GitHubV3RESTAPIClient) checksListSuitesForRefCreateRequest(ctx context.Context, ref string, options *GitHubV3RESTAPIClientChecksListSuitesForRefOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/commits/{ref}/check-suites"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if ref == "" {
		return nil, errors.New("parameter ref cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{ref}", url.PathEscape(ref))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.AppID != nil {
		reqQP.Set("app_id", strconv.FormatInt(int64(*options.AppID), 10))
	}
	if client.checkName != nil {
		reqQP.Set("check_name", *client.checkName)
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// checksListSuitesForRefHandleResponse handles the ChecksListSuitesForRef response.
func (client *GitHubV3RESTAPIClient) checksListSuitesForRefHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientChecksListSuitesForRefResponse, error) {
	result := GitHubV3RESTAPIClientChecksListSuitesForRefResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1728M1FReposOwnerRepoCommitsRefCheckSuitesGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientChecksListSuitesForRefResponse{}, err
	}
	return result, nil
}

// ChecksRerequestRun - Triggers GitHub to rerequest an existing check run, without pushing new code to a repository. This
// endpoint will trigger the checkrun webhook [https://docs.github.com/webhooks/event-payloads/#check
// run] event with the action rerequested. When a check run is rerequested, its status is reset to queued and the conclusion
// is cleared.
// To rerequest a check run, your GitHub App must have the checks:read permission on a private repository or pull access to
// a public repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientChecksRerequestRunOptions contains the optional parameters for the GitHubV3RESTAPIClient.ChecksRerequestRun
//     method.
func (client *GitHubV3RESTAPIClient) ChecksRerequestRun(ctx context.Context, options *GitHubV3RESTAPIClientChecksRerequestRunOptions) (GitHubV3RESTAPIClientChecksRerequestRunResponse, error) {
	req, err := client.checksRerequestRunCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientChecksRerequestRunResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientChecksRerequestRunResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientChecksRerequestRunResponse{}, runtime.NewResponseError(resp)
	}
	return client.checksRerequestRunHandleResponse(resp)
}

// checksRerequestRunCreateRequest creates the ChecksRerequestRun request.
func (client *GitHubV3RESTAPIClient) checksRerequestRunCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientChecksRerequestRunOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{check_run_id}", url.PathEscape(strconv.FormatInt(int64(client.checkRunID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// checksRerequestRunHandleResponse handles the ChecksRerequestRun response.
func (client *GitHubV3RESTAPIClient) checksRerequestRunHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientChecksRerequestRunResponse, error) {
	result := GitHubV3RESTAPIClientChecksRerequestRunResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientChecksRerequestRunResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientChecksRerequestRunResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientChecksRerequestRunResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientChecksRerequestRunResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientChecksRerequestRunResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ChecksRerequestSuite - Triggers GitHub to rerequest an existing check suite, without pushing new code to a repository.
// This endpoint will trigger the checksuite webhook
// [https://docs.github.com/webhooks/event-payloads/#checksuite] event with the action rerequested. When a check suite is
// rerequested, its status is reset to queued and the conclusion is cleared.
// To rerequest a check suite, your GitHub App must have the checks:read permission on a private repository or pull access
// to a public repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientChecksRerequestSuiteOptions contains the optional parameters for the GitHubV3RESTAPIClient.ChecksRerequestSuite
//     method.
func (client *GitHubV3RESTAPIClient) ChecksRerequestSuite(ctx context.Context, options *GitHubV3RESTAPIClientChecksRerequestSuiteOptions) (GitHubV3RESTAPIClientChecksRerequestSuiteResponse, error) {
	req, err := client.checksRerequestSuiteCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientChecksRerequestSuiteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientChecksRerequestSuiteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientChecksRerequestSuiteResponse{}, runtime.NewResponseError(resp)
	}
	return client.checksRerequestSuiteHandleResponse(resp)
}

// checksRerequestSuiteCreateRequest creates the ChecksRerequestSuite request.
func (client *GitHubV3RESTAPIClient) checksRerequestSuiteCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientChecksRerequestSuiteOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.checkSuiteID != nil {
		reqQP.Set("check_suite_id", strconv.FormatInt(int64(*client.checkSuiteID), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// checksRerequestSuiteHandleResponse handles the ChecksRerequestSuite response.
func (client *GitHubV3RESTAPIClient) checksRerequestSuiteHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientChecksRerequestSuiteResponse, error) {
	result := GitHubV3RESTAPIClientChecksRerequestSuiteResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return GitHubV3RESTAPIClientChecksRerequestSuiteResponse{}, err
	}
	return result, nil
}

// ChecksSetSuitesPreferences - Changes the default automatic flow when creating check suites. By default, a check suite is
// automatically created each time code is pushed to a repository. When you disable the automatic creation of
// check suites, you can manually Create a check suite [https://docs.github.com/rest/reference/checks#create-a-check-suite].
// You must have admin permissions in the repository to set preferences for check
// suites.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientChecksSetSuitesPreferencesOptions contains the optional parameters for the GitHubV3RESTAPIClient.ChecksSetSuitesPreferences
//     method.
func (client *GitHubV3RESTAPIClient) ChecksSetSuitesPreferences(ctx context.Context, body PathsUwcgvaReposOwnerRepoCheckSuitesPreferencesPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientChecksSetSuitesPreferencesOptions) (GitHubV3RESTAPIClientChecksSetSuitesPreferencesResponse, error) {
	req, err := client.checksSetSuitesPreferencesCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientChecksSetSuitesPreferencesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientChecksSetSuitesPreferencesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientChecksSetSuitesPreferencesResponse{}, runtime.NewResponseError(resp)
	}
	return client.checksSetSuitesPreferencesHandleResponse(resp)
}

// checksSetSuitesPreferencesCreateRequest creates the ChecksSetSuitesPreferences request.
func (client *GitHubV3RESTAPIClient) checksSetSuitesPreferencesCreateRequest(ctx context.Context, body PathsUwcgvaReposOwnerRepoCheckSuitesPreferencesPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientChecksSetSuitesPreferencesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/check-suites/preferences"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// checksSetSuitesPreferencesHandleResponse handles the ChecksSetSuitesPreferences response.
func (client *GitHubV3RESTAPIClient) checksSetSuitesPreferencesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientChecksSetSuitesPreferencesResponse, error) {
	result := GitHubV3RESTAPIClientChecksSetSuitesPreferencesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CheckSuitePreference); err != nil {
		return GitHubV3RESTAPIClientChecksSetSuitesPreferencesResponse{}, err
	}
	return result, nil
}

// ChecksUpdate - Note: The Checks API only looks for pushes in the repository where the check suite or check run were created.
// Pushes to a branch in a forked repository are not detected and return an empty
// pull_requests array.
// Updates a check run for a specific commit in a repository. Your GitHub App must have the checks:write permission to edit
// check runs.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientChecksUpdateOptions contains the optional parameters for the GitHubV3RESTAPIClient.ChecksUpdate
//     method.
func (client *GitHubV3RESTAPIClient) ChecksUpdate(ctx context.Context, body PathsN3A1M6ReposOwnerRepoCheckRunsCheckRunIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientChecksUpdateOptions) (GitHubV3RESTAPIClientChecksUpdateResponse, error) {
	req, err := client.checksUpdateCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientChecksUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientChecksUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientChecksUpdateResponse{}, runtime.NewResponseError(resp)
	}
	return client.checksUpdateHandleResponse(resp)
}

// checksUpdateCreateRequest creates the ChecksUpdate request.
func (client *GitHubV3RESTAPIClient) checksUpdateCreateRequest(ctx context.Context, body PathsN3A1M6ReposOwnerRepoCheckRunsCheckRunIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientChecksUpdateOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/check-runs/{check_run_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{check_run_id}", url.PathEscape(strconv.FormatInt(int64(client.checkRunID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// checksUpdateHandleResponse handles the ChecksUpdate response.
func (client *GitHubV3RESTAPIClient) checksUpdateHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientChecksUpdateResponse, error) {
	result := GitHubV3RESTAPIClientChecksUpdateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CheckRun); err != nil {
		return GitHubV3RESTAPIClientChecksUpdateResponse{}, err
	}
	return result, nil
}

// CodeScanningDeleteAnalysis - Deletes a specified code scanning analysis from a repository. For private repositories, you
// must use an access token with the repo scope. For public repositories, you must use an access token with
// publicrepo scope. GitHub Apps must have the securityevents write permission to use this endpoint.
// You can delete one analysis at a time. To delete a series of analyses, start with the most recent analysis and work backwards.
// Conceptually, the process is similar to the undo function in a text
// editor.
// When you list the analyses for a repository, one or more will be identified as deletable in the response:
// "deletable": true
// An analysis is deletable when it's the most recent in a set of analyses. Typically, a repository will have multiple sets
// of analyses for each enabled code scanning tool, where a set is determined by a
// unique combination of analysis values:
// * ref
// * tool
// * category
// If you attempt to delete an analysis that is not the most recent in a set, you'll get a 400 response with the message:
// Analysis specified is not deletable.
// The response from a successful DELETE operation provides you with two alternative URLs for deleting the next analysis in
// the set:nextanalysisurl and confirmdeleteurl. Use the nextanalysisurl URL if
// you want to avoid accidentally deleting the final analysis in a set. This is a useful option if you want to preserve at
// least one analysis for the specified tool in your repository. Use the confirm
// deleteurl URL if you are content to remove all analyses for a tool. When you delete the last analysis in a set, the value
// of nextanalysisurl and confirmdeleteurlin the 200 response is null.
// As an example of the deletion process, let's imagine that you added a workflow that configured a particular code scanning
// tool to analyze the code in a repository. This tool has added 15 analyses: 10
// on the default branch, and another 5 on a topic branch. You therefore have two separate sets of analyses for this tool.
// You've now decided that you want to remove all of the analyses for the tool. To
// do this you must make 15 separate deletion requests. To start, you must find an analysis that's identified as deletable.
// Each set of analyses always has one that's identified as deletable. Having
// found the deletable analysis for one of the two sets, delete this analysis and then continue deleting the next analysis
// in the set until they're all deleted. Then repeat the process for the second
// set. The procedure therefore consists of a nested loop:
// Outer loop:
// * List the analyses for the repository, filtered by tool.
//
//
// * Parse this list to find a deletable analysis. If found:
//
// Inner loop:
//
//
// * Delete the identified analysis.
//
//
// * Parse the response for the value of confirmdeleteurl and, if found, use this in the next iteration.
//
//
// The above process assumes that you want to remove all trace of the tool's analyses from the GitHub user interface, for
// the specified repository, and it therefore uses the confirmdeleteurl value.
// Alternatively, you could use the nextanalysisurl value, which would leave the last analysis in each set undeleted to avoid
// removing a tool's analysis entirely.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - analysisID - The ID of the analysis, as returned from the GET /repos/{owner}/{repo}/code-scanning/analyses operation.
//   - options - GitHubV3RESTAPIClientCodeScanningDeleteAnalysisOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodeScanningDeleteAnalysis
//     method.
func (client *GitHubV3RESTAPIClient) CodeScanningDeleteAnalysis(ctx context.Context, analysisID int32, options *GitHubV3RESTAPIClientCodeScanningDeleteAnalysisOptions) (GitHubV3RESTAPIClientCodeScanningDeleteAnalysisResponse, error) {
	req, err := client.codeScanningDeleteAnalysisCreateRequest(ctx, analysisID, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningDeleteAnalysisResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningDeleteAnalysisResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusForbidden, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientCodeScanningDeleteAnalysisResponse{}, runtime.NewResponseError(resp)
	}
	return client.codeScanningDeleteAnalysisHandleResponse(resp)
}

// codeScanningDeleteAnalysisCreateRequest creates the CodeScanningDeleteAnalysis request.
func (client *GitHubV3RESTAPIClient) codeScanningDeleteAnalysisCreateRequest(ctx context.Context, analysisID int32, options *GitHubV3RESTAPIClientCodeScanningDeleteAnalysisOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{analysis_id}", url.PathEscape(strconv.FormatInt(int64(analysisID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ConfirmDelete != nil {
		reqQP.Set("confirm_delete", *options.ConfirmDelete)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// codeScanningDeleteAnalysisHandleResponse handles the CodeScanningDeleteAnalysis response.
func (client *GitHubV3RESTAPIClient) codeScanningDeleteAnalysisHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodeScanningDeleteAnalysisResponse, error) {
	result := GitHubV3RESTAPIClientCodeScanningDeleteAnalysisResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val CodeScanningAnalysisDeletion
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningDeleteAnalysisResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningDeleteAnalysisResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningDeleteAnalysisResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningDeleteAnalysisResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningDeleteAnalysisResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodeScanningDeleteAnalysisResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodeScanningGetAlert - Gets a single code scanning alert. You must use an access token with the securityevents scope to
// use this endpoint with private repos, the publicrepo scope also grants permission to read security
// events on public repos only. GitHub Apps must have the security_events read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodeScanningGetAlertOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodeScanningGetAlert
//     method.
func (client *GitHubV3RESTAPIClient) CodeScanningGetAlert(ctx context.Context, options *GitHubV3RESTAPIClientCodeScanningGetAlertOptions) (GitHubV3RESTAPIClientCodeScanningGetAlertResponse, error) {
	req, err := client.codeScanningGetAlertCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetAlertResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetAlertResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientCodeScanningGetAlertResponse{}, runtime.NewResponseError(resp)
	}
	return client.codeScanningGetAlertHandleResponse(resp)
}

// codeScanningGetAlertCreateRequest creates the CodeScanningGetAlert request.
func (client *GitHubV3RESTAPIClient) codeScanningGetAlertCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodeScanningGetAlertOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{alert_number}", url.PathEscape(strconv.FormatInt(int64(client.alertNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codeScanningGetAlertHandleResponse handles the CodeScanningGetAlert response.
func (client *GitHubV3RESTAPIClient) codeScanningGetAlertHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodeScanningGetAlertResponse, error) {
	result := GitHubV3RESTAPIClientCodeScanningGetAlertResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val CodeScanningAlert
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetAlertResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetAlertResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetAlertResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetAlertResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodeScanningGetAlertResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodeScanningGetAnalysis - Gets a specified code scanning analysis for a repository. You must use an access token with the
// securityevents scope to use this endpoint with private repos, the publicrepo scope also grants
// permission to read security events on public repos only. GitHub Apps must have the security_events read permission to use
// this endpoint.
// The default JSON response contains fields that describe the analysis. This includes the Git reference and commit SHA to
// which the analysis relates, the datetime of the analysis, the name of the code
// scanning tool, and the number of alerts.
// The rules_count field in the default response give the number of rules that were run in the analysis. For very old analyses
// this data is not available, and 0 is returned in this field.
// If you use the Accept header application/sarif+json, the response contains the analysis data that was uploaded. This is
// formatted asSARIF version 2.1.0
// [https://docs.oasis-open.org/sarif/sarif/v2.1.0/cs01/sarif-v2.1.0-cs01.html].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - analysisID - The ID of the analysis, as returned from the GET /repos/{owner}/{repo}/code-scanning/analyses operation.
//   - options - GitHubV3RESTAPIClientCodeScanningGetAnalysisOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodeScanningGetAnalysis
//     method.
func (client *GitHubV3RESTAPIClient) CodeScanningGetAnalysis(ctx context.Context, analysisID int32, options *GitHubV3RESTAPIClientCodeScanningGetAnalysisOptions) (GitHubV3RESTAPIClientCodeScanningGetAnalysisResponse, error) {
	req, err := client.codeScanningGetAnalysisCreateRequest(ctx, analysisID, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetAnalysisResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetAnalysisResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientCodeScanningGetAnalysisResponse{}, runtime.NewResponseError(resp)
	}
	return client.codeScanningGetAnalysisHandleResponse(resp)
}

// codeScanningGetAnalysisCreateRequest creates the CodeScanningGetAnalysis request.
func (client *GitHubV3RESTAPIClient) codeScanningGetAnalysisCreateRequest(ctx context.Context, analysisID int32, options *GitHubV3RESTAPIClientCodeScanningGetAnalysisOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{analysis_id}", url.PathEscape(strconv.FormatInt(int64(analysisID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json, application/json+sarif"}
	return req, nil
}

// codeScanningGetAnalysisHandleResponse handles the CodeScanningGetAnalysis response.
func (client *GitHubV3RESTAPIClient) codeScanningGetAnalysisHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodeScanningGetAnalysisResponse, error) {
	result := GitHubV3RESTAPIClientCodeScanningGetAnalysisResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val CodeScanningAnalysis
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetAnalysisResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetAnalysisResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetAnalysisResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetAnalysisResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodeScanningGetAnalysisResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodeScanningGetCodeqlDatabase - Gets a CodeQL database for a language in a repository.
// By default this endpoint returns JSON metadata about the CodeQL database. To download the CodeQL database binary content,
// set the Accept header of the request to application/zip
// [https://docs.github.com/rest/overview/media-types], and make sure your HTTP client is configured to follow redirects or
// use the Location header to make a second request to get the redirect URL.
// For private repositories, you must use an access token with the securityevents scope. For public repositories, you can
// use tokens with the securityevents or public_repo scope. GitHub Apps must have
// the contents read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - language - The language of the CodeQL database.
//   - options - GitHubV3RESTAPIClientCodeScanningGetCodeqlDatabaseOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodeScanningGetCodeqlDatabase
//     method.
func (client *GitHubV3RESTAPIClient) CodeScanningGetCodeqlDatabase(ctx context.Context, language string, options *GitHubV3RESTAPIClientCodeScanningGetCodeqlDatabaseOptions) (GitHubV3RESTAPIClientCodeScanningGetCodeqlDatabaseResponse, error) {
	req, err := client.codeScanningGetCodeqlDatabaseCreateRequest(ctx, language, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetCodeqlDatabaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetCodeqlDatabaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientCodeScanningGetCodeqlDatabaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.codeScanningGetCodeqlDatabaseHandleResponse(resp)
}

// codeScanningGetCodeqlDatabaseCreateRequest creates the CodeScanningGetCodeqlDatabase request.
func (client *GitHubV3RESTAPIClient) codeScanningGetCodeqlDatabaseCreateRequest(ctx context.Context, language string, options *GitHubV3RESTAPIClientCodeScanningGetCodeqlDatabaseOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if language == "" {
		return nil, errors.New("parameter language cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{language}", url.PathEscape(language))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codeScanningGetCodeqlDatabaseHandleResponse handles the CodeScanningGetCodeqlDatabase response.
func (client *GitHubV3RESTAPIClient) codeScanningGetCodeqlDatabaseHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodeScanningGetCodeqlDatabaseResponse, error) {
	result := GitHubV3RESTAPIClientCodeScanningGetCodeqlDatabaseResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val CodeScanningCodeqlDatabase
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetCodeqlDatabaseResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetCodeqlDatabaseResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetCodeqlDatabaseResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetCodeqlDatabaseResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodeScanningGetCodeqlDatabaseResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodeScanningGetSarif - Gets information about a SARIF upload, including the status and the URL of the analysis that was
// uploaded so that you can retrieve details of the analysis. For more information, see "Get a code
// scanning analysis for a repository [/rest/reference/code-scanning#get-a-code-scanning-analysis-for-a-repository]." You
// must use an access token with the securityevents scope to use this endpoint with
// private repos, the publicrepo scope also grants permission to read security events on public repos only. GitHub Apps must
// have the security_events read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - sarifID - The SARIF ID obtained after uploading.
//   - options - GitHubV3RESTAPIClientCodeScanningGetSarifOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodeScanningGetSarif
//     method.
func (client *GitHubV3RESTAPIClient) CodeScanningGetSarif(ctx context.Context, sarifID string, options *GitHubV3RESTAPIClientCodeScanningGetSarifOptions) (GitHubV3RESTAPIClientCodeScanningGetSarifResponse, error) {
	req, err := client.codeScanningGetSarifCreateRequest(ctx, sarifID, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetSarifResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetSarifResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientCodeScanningGetSarifResponse{}, runtime.NewResponseError(resp)
	}
	return client.codeScanningGetSarifHandleResponse(resp)
}

// codeScanningGetSarifCreateRequest creates the CodeScanningGetSarif request.
func (client *GitHubV3RESTAPIClient) codeScanningGetSarifCreateRequest(ctx context.Context, sarifID string, options *GitHubV3RESTAPIClientCodeScanningGetSarifOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if sarifID == "" {
		return nil, errors.New("parameter sarifID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sarif_id}", url.PathEscape(sarifID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codeScanningGetSarifHandleResponse handles the CodeScanningGetSarif response.
func (client *GitHubV3RESTAPIClient) codeScanningGetSarifHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodeScanningGetSarifResponse, error) {
	result := GitHubV3RESTAPIClientCodeScanningGetSarifResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val CodeScanningSarifsStatus
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetSarifResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetSarifResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningGetSarifResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodeScanningGetSarifResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodeScanningListAlertInstances - Lists all instances of the specified code scanning alert. You must use an access token
// with the securityevents scope to use this endpoint with private repos, the publicrepo scope also grants
// permission to read security events on public repos only. GitHub Apps must have the security_events read permission to use
// this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodeScanningListAlertInstancesOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodeScanningListAlertInstances
//     method.
func (client *GitHubV3RESTAPIClient) CodeScanningListAlertInstances(ctx context.Context, options *GitHubV3RESTAPIClientCodeScanningListAlertInstancesOptions) (GitHubV3RESTAPIClientCodeScanningListAlertInstancesResponse, error) {
	req, err := client.codeScanningListAlertInstancesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertInstancesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertInstancesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientCodeScanningListAlertInstancesResponse{}, runtime.NewResponseError(resp)
	}
	return client.codeScanningListAlertInstancesHandleResponse(resp)
}

// codeScanningListAlertInstancesCreateRequest creates the CodeScanningListAlertInstances request.
func (client *GitHubV3RESTAPIClient) codeScanningListAlertInstancesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodeScanningListAlertInstancesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{alert_number}", url.PathEscape(strconv.FormatInt(int64(client.alertNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.ref != nil {
		reqQP.Set("ref", *client.ref)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codeScanningListAlertInstancesHandleResponse handles the CodeScanningListAlertInstances response.
func (client *GitHubV3RESTAPIClient) codeScanningListAlertInstancesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodeScanningListAlertInstancesResponse, error) {
	result := GitHubV3RESTAPIClientCodeScanningListAlertInstancesResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*CodeScanningAlertInstance
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertInstancesResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertInstancesResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertInstancesResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertInstancesResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodeScanningListAlertInstancesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodeScanningListAlertsForOrg - Lists code scanning alerts for the default branch for all eligible repositories in an organization.
// Eligible repositories are repositories that are owned by organizations that you own or for which you
// are a security manager. For more information, see "Managing security managers in your organization
// [https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization]."
// To use this endpoint, you must be an owner or security manager for the organization, and you must use an access token with
// the repo scope or security_events scope.
// For public repositories, you may instead use the public_repo scope.
// GitHub Apps must have the security_events read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodeScanningListAlertsForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodeScanningListAlertsForOrg
//     method.
func (client *GitHubV3RESTAPIClient) CodeScanningListAlertsForOrg(ctx context.Context, options *GitHubV3RESTAPIClientCodeScanningListAlertsForOrgOptions) (GitHubV3RESTAPIClientCodeScanningListAlertsForOrgResponse, error) {
	req, err := client.codeScanningListAlertsForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertsForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertsForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientCodeScanningListAlertsForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.codeScanningListAlertsForOrgHandleResponse(resp)
}

// codeScanningListAlertsForOrgCreateRequest creates the CodeScanningListAlertsForOrg request.
func (client *GitHubV3RESTAPIClient) codeScanningListAlertsForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodeScanningListAlertsForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/code-scanning/alerts"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.toolName != nil {
		reqQP.Set("tool_name", *client.toolName)
	}
	if client.toolGUID != nil {
		reqQP.Set("tool_guid", *client.toolGUID)
	}
	if client.before != nil {
		reqQP.Set("before", *client.before)
	}
	if client.after != nil {
		reqQP.Set("after", *client.after)
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if options != nil && options.State != nil {
		reqQP.Set("state", string(*options.State))
	}
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if options != nil && options.Severity != nil {
		reqQP.Set("severity", string(*options.Severity))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codeScanningListAlertsForOrgHandleResponse handles the CodeScanningListAlertsForOrg response.
func (client *GitHubV3RESTAPIClient) codeScanningListAlertsForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodeScanningListAlertsForOrgResponse, error) {
	result := GitHubV3RESTAPIClientCodeScanningListAlertsForOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*CodeScanningOrganizationAlertItems
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertsForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertsForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertsForOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodeScanningListAlertsForOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodeScanningListAlertsForRepo - Lists code scanning alerts.
// To use this endpoint, you must use an access token with the securityevents scope or, for alerts from public repositories
// only, an access token with the publicrepo scope.
// GitHub Apps must have the security_events read permission to use this endpoint.
// The response includes a mostrecentinstance object. This provides details of the most recent instance of this alert for
// the default branch (or for the specified Git reference if you used ref in the
// request).
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodeScanningListAlertsForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodeScanningListAlertsForRepo
//     method.
func (client *GitHubV3RESTAPIClient) CodeScanningListAlertsForRepo(ctx context.Context, options *GitHubV3RESTAPIClientCodeScanningListAlertsForRepoOptions) (GitHubV3RESTAPIClientCodeScanningListAlertsForRepoResponse, error) {
	req, err := client.codeScanningListAlertsForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertsForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertsForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientCodeScanningListAlertsForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.codeScanningListAlertsForRepoHandleResponse(resp)
}

// codeScanningListAlertsForRepoCreateRequest creates the CodeScanningListAlertsForRepo request.
func (client *GitHubV3RESTAPIClient) codeScanningListAlertsForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodeScanningListAlertsForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/code-scanning/alerts"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.toolName != nil {
		reqQP.Set("tool_name", *client.toolName)
	}
	if client.toolGUID != nil {
		reqQP.Set("tool_guid", *client.toolGUID)
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.ref != nil {
		reqQP.Set("ref", *client.ref)
	}
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if options != nil && options.State != nil {
		reqQP.Set("state", string(*options.State))
	}
	if options != nil && options.Severity != nil {
		reqQP.Set("severity", string(*options.Severity))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codeScanningListAlertsForRepoHandleResponse handles the CodeScanningListAlertsForRepo response.
func (client *GitHubV3RESTAPIClient) codeScanningListAlertsForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodeScanningListAlertsForRepoResponse, error) {
	result := GitHubV3RESTAPIClientCodeScanningListAlertsForRepoResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*CodeScanningAlertItems
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertsForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertsForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertsForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListAlertsForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodeScanningListAlertsForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodeScanningListCodeqlDatabases - Lists the CodeQL databases that are available in a repository.
// For private repositories, you must use an access token with the securityevents scope. For public repositories, you can
// use tokens with the securityevents or public_repo scope. GitHub Apps must have
// the contents read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodeScanningListCodeqlDatabasesOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodeScanningListCodeqlDatabases
//     method.
func (client *GitHubV3RESTAPIClient) CodeScanningListCodeqlDatabases(ctx context.Context, options *GitHubV3RESTAPIClientCodeScanningListCodeqlDatabasesOptions) (GitHubV3RESTAPIClientCodeScanningListCodeqlDatabasesResponse, error) {
	req, err := client.codeScanningListCodeqlDatabasesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningListCodeqlDatabasesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningListCodeqlDatabasesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientCodeScanningListCodeqlDatabasesResponse{}, runtime.NewResponseError(resp)
	}
	return client.codeScanningListCodeqlDatabasesHandleResponse(resp)
}

// codeScanningListCodeqlDatabasesCreateRequest creates the CodeScanningListCodeqlDatabases request.
func (client *GitHubV3RESTAPIClient) codeScanningListCodeqlDatabasesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodeScanningListCodeqlDatabasesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/code-scanning/codeql/databases"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codeScanningListCodeqlDatabasesHandleResponse handles the CodeScanningListCodeqlDatabases response.
func (client *GitHubV3RESTAPIClient) codeScanningListCodeqlDatabasesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodeScanningListCodeqlDatabasesResponse, error) {
	result := GitHubV3RESTAPIClientCodeScanningListCodeqlDatabasesResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*CodeScanningCodeqlDatabase
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListCodeqlDatabasesResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListCodeqlDatabasesResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListCodeqlDatabasesResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListCodeqlDatabasesResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodeScanningListCodeqlDatabasesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodeScanningListRecentAnalyses - Lists the details of all code scanning analyses for a repository, starting with the most
// recent. The response is paginated and you can use the page and per_page parameters to list the analyses you're
// interested in. By default 30 analyses are listed per page.
// The rules_count field in the response give the number of rules that were run in the analysis. For very old analyses this
// data is not available, and 0 is returned in this field.
// You must use an access token with the securityevents scope to use this endpoint with private repos, the publicrepo scope
// also grants permission to read security events on public repos only. GitHub
// Apps must have the security_events read permission to use this endpoint.
// Deprecation notice: The tool_name field is deprecated and will, in future, not be included in the response for this endpoint.
// The example response reflects this change. The tool name can now be found
// inside the tool field.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodeScanningListRecentAnalysesOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodeScanningListRecentAnalyses
//     method.
func (client *GitHubV3RESTAPIClient) CodeScanningListRecentAnalyses(ctx context.Context, options *GitHubV3RESTAPIClientCodeScanningListRecentAnalysesOptions) (GitHubV3RESTAPIClientCodeScanningListRecentAnalysesResponse, error) {
	req, err := client.codeScanningListRecentAnalysesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningListRecentAnalysesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningListRecentAnalysesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientCodeScanningListRecentAnalysesResponse{}, runtime.NewResponseError(resp)
	}
	return client.codeScanningListRecentAnalysesHandleResponse(resp)
}

// codeScanningListRecentAnalysesCreateRequest creates the CodeScanningListRecentAnalyses request.
func (client *GitHubV3RESTAPIClient) codeScanningListRecentAnalysesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodeScanningListRecentAnalysesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/code-scanning/analyses"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.toolName != nil {
		reqQP.Set("tool_name", *client.toolName)
	}
	if client.toolGUID != nil {
		reqQP.Set("tool_guid", *client.toolGUID)
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if options != nil && options.Ref != nil {
		reqQP.Set("ref", *options.Ref)
	}
	if options != nil && options.SarifID != nil {
		reqQP.Set("sarif_id", *options.SarifID)
	}
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codeScanningListRecentAnalysesHandleResponse handles the CodeScanningListRecentAnalyses response.
func (client *GitHubV3RESTAPIClient) codeScanningListRecentAnalysesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodeScanningListRecentAnalysesResponse, error) {
	result := GitHubV3RESTAPIClientCodeScanningListRecentAnalysesResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*CodeScanningAnalysis
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListRecentAnalysesResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListRecentAnalysesResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListRecentAnalysesResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningListRecentAnalysesResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodeScanningListRecentAnalysesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodeScanningUpdateAlert - Updates the status of a single code scanning alert. You must use an access token with the securityevents
// scope to use this endpoint with private repositories. You can also use tokens with the public
// repo scope for public repositories only. GitHub Apps must have the security_events write permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodeScanningUpdateAlertOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodeScanningUpdateAlert
//     method.
func (client *GitHubV3RESTAPIClient) CodeScanningUpdateAlert(ctx context.Context, body PathsKf3Zv8ReposOwnerRepoCodeScanningAlertsAlertNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodeScanningUpdateAlertOptions) (GitHubV3RESTAPIClientCodeScanningUpdateAlertResponse, error) {
	req, err := client.codeScanningUpdateAlertCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningUpdateAlertResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningUpdateAlertResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientCodeScanningUpdateAlertResponse{}, runtime.NewResponseError(resp)
	}
	return client.codeScanningUpdateAlertHandleResponse(resp)
}

// codeScanningUpdateAlertCreateRequest creates the CodeScanningUpdateAlert request.
func (client *GitHubV3RESTAPIClient) codeScanningUpdateAlertCreateRequest(ctx context.Context, body PathsKf3Zv8ReposOwnerRepoCodeScanningAlertsAlertNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodeScanningUpdateAlertOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{alert_number}", url.PathEscape(strconv.FormatInt(int64(client.alertNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// codeScanningUpdateAlertHandleResponse handles the CodeScanningUpdateAlert response.
func (client *GitHubV3RESTAPIClient) codeScanningUpdateAlertHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodeScanningUpdateAlertResponse, error) {
	result := GitHubV3RESTAPIClientCodeScanningUpdateAlertResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val CodeScanningAlert
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningUpdateAlertResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningUpdateAlertResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningUpdateAlertResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningUpdateAlertResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodeScanningUpdateAlertResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodeScanningUploadSarif - Uploads SARIF data containing the results of a code scanning analysis to make the results available
// in a repository. You must use an access token with the securityevents scope to use this endpoint for
// private repositories. You can also use tokens with the publicrepo scope for public repositories only. GitHub Apps must
// have the security_events write permission to use this endpoint.
// There are two places where you can upload code scanning results.
// * If you upload to a pull request, for example --ref refs/pull/42/merge or --ref refs/pull/42/head, then the results appear
// as alerts in a pull request check. For more information, see "Triaging code
// scanning alerts in pull requests [/code-security/secure-coding/triaging-code-scanning-alerts-in-pull-requests]."
// * If you upload to a branch, for example --ref refs/heads/my-branch, then the results appear in the Security tab for your
// repository. For more information, see "Managing code scanning alerts for your
// repository [/code-security/secure-coding/managing-code-scanning-alerts-for-your-repository#viewing-the-alerts-for-a-repository]."
// You must compress the SARIF-formatted analysis data that you want to upload, using gzip, and then encode it as a Base64
// format string. For example:
// gzip -c analysis-data.sarif | base64 -w0
// SARIF upload supports a maximum number of entries per the following data objects, and an analysis will be rejected if any
// of these objects is above its maximum value. For some objects, there are
// additional values over which the entries will be ignored while keeping the most important entries whenever applicable.
// To get the most out of your analysis when it includes data above the supported
// limits, try to optimize the analysis configuration. For example, for the CodeQL tool, identify and remove the most noisy
// queries.
// SARIF DATA MAXIMUM VALUES ADDITIONAL LIMITS
// Runs per file 20
// Results per run 25,000 Only the top 5,000 results will be included, prioritized by severity.
// Rules per run 25,000
// Tool extensions per run 100
// Thread Flow Locations per result 10,000 Only the top 1,000 Thread Flow Locations will be included, using prioritization.
// Location per result 1,000 Only 100 locations will be included.
// Tags per rule 20 Only 10 tags will be included.
// The 202 Accepted response includes an id value. You can use this ID to check the status of the upload by using it in the
// /sarifs/{sarif_id} endpoint. For more information, see "Get information about a
// SARIF upload [/rest/reference/code-scanning#get-information-about-a-sarif-upload]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodeScanningUploadSarifOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodeScanningUploadSarif
//     method.
func (client *GitHubV3RESTAPIClient) CodeScanningUploadSarif(ctx context.Context, body Paths1Vr95C8ReposOwnerRepoCodeScanningSarifsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodeScanningUploadSarifOptions) (GitHubV3RESTAPIClientCodeScanningUploadSarifResponse, error) {
	req, err := client.codeScanningUploadSarifCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningUploadSarifResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodeScanningUploadSarifResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusBadRequest, http.StatusForbidden, http.StatusNotFound, http.StatusRequestEntityTooLarge, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientCodeScanningUploadSarifResponse{}, runtime.NewResponseError(resp)
	}
	return client.codeScanningUploadSarifHandleResponse(resp)
}

// codeScanningUploadSarifCreateRequest creates the CodeScanningUploadSarif request.
func (client *GitHubV3RESTAPIClient) codeScanningUploadSarifCreateRequest(ctx context.Context, body Paths1Vr95C8ReposOwnerRepoCodeScanningSarifsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodeScanningUploadSarifOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/code-scanning/sarifs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// codeScanningUploadSarifHandleResponse handles the CodeScanningUploadSarif response.
func (client *GitHubV3RESTAPIClient) codeScanningUploadSarifHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodeScanningUploadSarifResponse, error) {
	result := GitHubV3RESTAPIClientCodeScanningUploadSarifResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val CodeScanningSarifsReceipt
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningUploadSarifResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningUploadSarifResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningUploadSarifResponse{}, err
	}
	result.Value = val
	case http.StatusRequestEntityTooLarge:
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodeScanningUploadSarifResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodeScanningUploadSarifResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodesOfConductGetAllCodesOfConduct - Get all codes of conduct
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodesOfConductGetAllCodesOfConductOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodesOfConductGetAllCodesOfConduct
//     method.
func (client *GitHubV3RESTAPIClient) CodesOfConductGetAllCodesOfConduct(ctx context.Context, options *GitHubV3RESTAPIClientCodesOfConductGetAllCodesOfConductOptions) (GitHubV3RESTAPIClientCodesOfConductGetAllCodesOfConductResponse, error) {
	req, err := client.codesOfConductGetAllCodesOfConductCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodesOfConductGetAllCodesOfConductResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodesOfConductGetAllCodesOfConductResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified) {
		return GitHubV3RESTAPIClientCodesOfConductGetAllCodesOfConductResponse{}, runtime.NewResponseError(resp)
	}
	return client.codesOfConductGetAllCodesOfConductHandleResponse(resp)
}

// codesOfConductGetAllCodesOfConductCreateRequest creates the CodesOfConductGetAllCodesOfConduct request.
func (client *GitHubV3RESTAPIClient) codesOfConductGetAllCodesOfConductCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodesOfConductGetAllCodesOfConductOptions) (*policy.Request, error) {
	urlPath := "/codes_of_conduct"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codesOfConductGetAllCodesOfConductHandleResponse handles the CodesOfConductGetAllCodesOfConduct response.
func (client *GitHubV3RESTAPIClient) codesOfConductGetAllCodesOfConductHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodesOfConductGetAllCodesOfConductResponse, error) {
	result := GitHubV3RESTAPIClientCodesOfConductGetAllCodesOfConductResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CodeOfConductArray); err != nil {
		return GitHubV3RESTAPIClientCodesOfConductGetAllCodesOfConductResponse{}, err
	}
	return result, nil
}

// CodesOfConductGetConductCode - Get a code of conduct
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodesOfConductGetConductCodeOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodesOfConductGetConductCode
//     method.
func (client *GitHubV3RESTAPIClient) CodesOfConductGetConductCode(ctx context.Context, key string, options *GitHubV3RESTAPIClientCodesOfConductGetConductCodeOptions) (GitHubV3RESTAPIClientCodesOfConductGetConductCodeResponse, error) {
	req, err := client.codesOfConductGetConductCodeCreateRequest(ctx, key, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodesOfConductGetConductCodeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodesOfConductGetConductCodeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusNotFound) {
		return GitHubV3RESTAPIClientCodesOfConductGetConductCodeResponse{}, runtime.NewResponseError(resp)
	}
	return client.codesOfConductGetConductCodeHandleResponse(resp)
}

// codesOfConductGetConductCodeCreateRequest creates the CodesOfConductGetConductCode request.
func (client *GitHubV3RESTAPIClient) codesOfConductGetConductCodeCreateRequest(ctx context.Context, key string, options *GitHubV3RESTAPIClientCodesOfConductGetConductCodeOptions) (*policy.Request, error) {
	urlPath := "/codes_of_conduct/{key}"
	if key == "" {
		return nil, errors.New("parameter key cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key}", url.PathEscape(key))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codesOfConductGetConductCodeHandleResponse handles the CodesOfConductGetConductCode response.
func (client *GitHubV3RESTAPIClient) codesOfConductGetConductCodeHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodesOfConductGetConductCodeResponse, error) {
	result := GitHubV3RESTAPIClientCodesOfConductGetConductCodeResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val CodeOfConduct
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodesOfConductGetConductCodeResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodesOfConductGetConductCodeResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodesOfConductGetConductCodeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesAddRepositoryForSecretForAuthenticatedUser - Adds a repository to the selected repositories for a user's codespace
// secret. You must authenticate using an access token with the codespace or codespace:secrets scope to use this endpoint.
// User must
// have Codespaces access to use this endpoint. GitHub Apps must have write access to the codespacesusersecrets user permission
// and write access to the codespaces_secrets repository permission on the
// referenced repository to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesAddRepositoryForSecretForAuthenticatedUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.CodespacesAddRepositoryForSecretForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesAddRepositoryForSecretForAuthenticatedUser(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientCodespacesAddRepositoryForSecretForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesAddRepositoryForSecretForAuthenticatedUserResponse, error) {
	req, err := client.codespacesAddRepositoryForSecretForAuthenticatedUserCreateRequest(ctx, repositoryID, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesAddRepositoryForSecretForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesAddRepositoryForSecretForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesAddRepositoryForSecretForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesAddRepositoryForSecretForAuthenticatedUserHandleResponse(resp)
}

// codespacesAddRepositoryForSecretForAuthenticatedUserCreateRequest creates the CodespacesAddRepositoryForSecretForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesAddRepositoryForSecretForAuthenticatedUserCreateRequest(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientCodespacesAddRepositoryForSecretForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesAddRepositoryForSecretForAuthenticatedUserHandleResponse handles the CodespacesAddRepositoryForSecretForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesAddRepositoryForSecretForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesAddRepositoryForSecretForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesAddRepositoryForSecretForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientCodespacesAddRepositoryForSecretForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// CodespacesAddSelectedRepoToOrgSecret - Adds a repository to an organization secret when the visibility for repository access
// is set to selected. The visibility is set when you Create or update an organization secret
// [https://docs.github.com/rest/reference/codespaces#create-or-update-an-organization-secret]. You must authenticate using
// an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesAddSelectedRepoToOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesAddSelectedRepoToOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesAddSelectedRepoToOrgSecret(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientCodespacesAddSelectedRepoToOrgSecretOptions) (GitHubV3RESTAPIClientCodespacesAddSelectedRepoToOrgSecretResponse, error) {
	req, err := client.codespacesAddSelectedRepoToOrgSecretCreateRequest(ctx, repositoryID, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesAddSelectedRepoToOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesAddSelectedRepoToOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound, http.StatusConflict, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientCodespacesAddSelectedRepoToOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesAddSelectedRepoToOrgSecretHandleResponse(resp)
}

// codespacesAddSelectedRepoToOrgSecretCreateRequest creates the CodespacesAddSelectedRepoToOrgSecret request.
func (client *GitHubV3RESTAPIClient) codespacesAddSelectedRepoToOrgSecretCreateRequest(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientCodespacesAddSelectedRepoToOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesAddSelectedRepoToOrgSecretHandleResponse handles the CodespacesAddSelectedRepoToOrgSecret response.
func (client *GitHubV3RESTAPIClient) codespacesAddSelectedRepoToOrgSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesAddSelectedRepoToOrgSecretResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesAddSelectedRepoToOrgSecretResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesAddSelectedRepoToOrgSecretResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesAddSelectedRepoToOrgSecretResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesAddSelectedRepoToOrgSecretResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesCodespaceMachinesForAuthenticatedUser - List the machine types a codespace can transition to use.
// You must authenticate using an access token with the codespace scope to use this endpoint.
// GitHub Apps must have read access to the codespaces_metadata repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesCodespaceMachinesForAuthenticatedUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.CodespacesCodespaceMachinesForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesCodespaceMachinesForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesCodespaceMachinesForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesCodespaceMachinesForAuthenticatedUserResponse, error) {
	req, err := client.codespacesCodespaceMachinesForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesCodespaceMachinesForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesCodespaceMachinesForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesCodespaceMachinesForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesCodespaceMachinesForAuthenticatedUserHandleResponse(resp)
}

// codespacesCodespaceMachinesForAuthenticatedUserCreateRequest creates the CodespacesCodespaceMachinesForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesCodespaceMachinesForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesCodespaceMachinesForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/{codespace_name}/machines"
	if client.codespaceName == "" {
		return nil, errors.New("parameter client.codespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{codespace_name}", url.PathEscape(client.codespaceName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesCodespaceMachinesForAuthenticatedUserHandleResponse handles the CodespacesCodespaceMachinesForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesCodespaceMachinesForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesCodespaceMachinesForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesCodespaceMachinesForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PathsYc7S5OUserCodespacesCodespaceNameMachinesGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCodespaceMachinesForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCodespaceMachinesForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCodespaceMachinesForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCodespaceMachinesForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCodespaceMachinesForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesCodespaceMachinesForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesCreateForAuthenticatedUser - Creates a new codespace, owned by the authenticated user.
// This endpoint requires either a repositoryid OR a pullrequest but not both.
// You must authenticate using an access token with the codespace scope to use this endpoint.
// GitHub Apps must have write access to the codespaces repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesCreateForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesCreateForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesCreateForAuthenticatedUser(ctx context.Context, body PathsNf1T5SUserCodespacesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesCreateForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesCreateForAuthenticatedUserResponse, error) {
	req, err := client.codespacesCreateForAuthenticatedUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusAccepted, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientCodespacesCreateForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesCreateForAuthenticatedUserHandleResponse(resp)
}

// codespacesCreateForAuthenticatedUserCreateRequest creates the CodespacesCreateForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesCreateForAuthenticatedUserCreateRequest(ctx context.Context, body PathsNf1T5SUserCodespacesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesCreateForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// codespacesCreateForAuthenticatedUserHandleResponse handles the CodespacesCreateForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesCreateForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesCreateForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesCreateForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Codespace
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val Codespace
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesCreateForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesCreateOrUpdateOrgSecret - Creates or updates an organization secret with an encrypted value. Encrypt your secret
// usingLibSodium [https://libsodium.gitbook.io/doc/bindingsforother_languages]. You must authenticate using an
// access token with the admin:org scope to use this endpoint.
// EXAMPLE ENCRYPTING A SECRET USING NODE.JS Encrypt your secret using the libsodium-wrappers [https://www.npmjs.com/package/libsodium-wrappers]
// library.
// const sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the secret you want to
// encrypt const key = 'base64-encoded-public-key' // replace with the Base64
// encoded public key
// //Check if libsodium is ready and then proceed. sodium.ready.then(() => { // Convert Secret & Base64 key to Uint8Array.
// let binkey = sodium.frombase64(key, sodium.base64variants.ORIGINAL) let binsec =
// sodium.from_string(secret)
// //Encrypt the secret using LibSodium let encBytes = sodium.cryptoboxseal(binsec, binkey)
// // Convert encrypted Uint8Array to Base64 let output = sodium.tobase64(encBytes, sodium.base64variants.ORIGINAL)
// console.log(output) });
// EXAMPLE ENCRYPTING A SECRET USING PYTHON Encrypt your secret using pynacl [https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox]
// with Python 3.
// from base64 import b64encode from nacl import encoding, public
// def encrypt(publickey: str, secretvalue: str) -> str: """Encrypt a Unicode string using the public key.""" publickey =
// public.PublicKey(publickey.encode("utf-8"), encoding.Base64Encoder()) sealedbox =
// public.SealedBox(publickey) encrypted = sealedbox.encrypt(secretvalue.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
// EXAMPLE ENCRYPTING A SECRET USING C Encrypt your secret using the Sodium.Core [https://www.nuget.org/packages/Sodium.Core/]
// package.
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// EXAMPLE ENCRYPTING A SECRET USING RUBY Encrypt your secret using the rbnacl [https://github.com/RubyCrypto/rbnacl] gem.
// require "rbnacl" require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.frompublickey(publickey) encryptedsecret = box.encrypt("my_secret")
// PRINT THE BASE64 ENCODED SECRET
// puts Base64.strictencode64(encryptedsecret)
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesCreateOrUpdateOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesCreateOrUpdateOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesCreateOrUpdateOrgSecret(ctx context.Context, body Paths1VqqqwaOrgsOrgCodespacesSecretsSecretNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesCreateOrUpdateOrgSecretOptions) (GitHubV3RESTAPIClientCodespacesCreateOrUpdateOrgSecretResponse, error) {
	req, err := client.codespacesCreateOrUpdateOrgSecretCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNoContent, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesCreateOrUpdateOrgSecretHandleResponse(resp)
}

// codespacesCreateOrUpdateOrgSecretCreateRequest creates the CodespacesCreateOrUpdateOrgSecret request.
func (client *GitHubV3RESTAPIClient) codespacesCreateOrUpdateOrgSecretCreateRequest(ctx context.Context, body Paths1VqqqwaOrgsOrgCodespacesSecretsSecretNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesCreateOrUpdateOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/codespaces/secrets/{secret_name}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// codespacesCreateOrUpdateOrgSecretHandleResponse handles the CodespacesCreateOrUpdateOrgSecret response.
func (client *GitHubV3RESTAPIClient) codespacesCreateOrUpdateOrgSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesCreateOrUpdateOrgSecretResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesCreateOrUpdateOrgSecretResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateOrgSecretResponse{}, err
	}
	result.Value = val
	case http.StatusNoContent:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateOrgSecretResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateOrgSecretResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateOrgSecretResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesCreateOrUpdateRepoSecret - Creates or updates a repository secret with an encrypted value. Encrypt your secret
// usingLibSodium [https://libsodium.gitbook.io/doc/bindingsforotherlanguages]. You must authenticate using an access
// token with the repo scope to use this endpoint. GitHub Apps must have write access to the codespacessecretsrepository permission
// to use this endpoint.
// EXAMPLE OF ENCRYPTING A SECRET USING NODE.JS Encrypt your secret using the libsodium-wrappers [https://www.npmjs.com/package/libsodium-wrappers]
// library.
// const sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the secret you want to
// encrypt const key = 'base64-encoded-public-key' // replace with the Base64
// encoded public key
// //Check if libsodium is ready and then proceed. sodium.ready.then(() => { // Convert Secret & Base64 key to Uint8Array.
// let binkey = sodium.frombase64(key, sodium.base64variants.ORIGINAL) let binsec =
// sodium.from_string(secret)
// //Encrypt the secret using LibSodium let encBytes = sodium.cryptoboxseal(binsec, binkey)
// // Convert encrypted Uint8Array to Base64 let output = sodium.tobase64(encBytes, sodium.base64variants.ORIGINAL)
// console.log(output) });
// EXAMPLE OF ENCRYPTING A SECRET USING PYTHON Encrypt your secret using pynacl [https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox]
// with Python 3.
// from base64 import b64encode from nacl import encoding, public
// def encrypt(publickey: str, secretvalue: str) -> str: """Encrypt a Unicode string using the public key.""" publickey =
// public.PublicKey(publickey.encode("utf-8"), encoding.Base64Encoder()) sealedbox =
// public.SealedBox(publickey) encrypted = sealedbox.encrypt(secretvalue.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
// EXAMPLE OF ENCRYPTING A SECRET USING C Encrypt your secret using the Sodium.Core [https://www.nuget.org/packages/Sodium.Core/]
// package.
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// EXAMPLE OF ENCRYPTING A SECRET USING RUBY Encrypt your secret using the rbnacl [https://github.com/RubyCrypto/rbnacl] gem.
// require "rbnacl" require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.frompublickey(publickey) encryptedsecret = box.encrypt("my_secret")
// PRINT THE BASE64 ENCODED SECRET
// puts Base64.strictencode64(encryptedsecret)
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesCreateOrUpdateRepoSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesCreateOrUpdateRepoSecret
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesCreateOrUpdateRepoSecret(ctx context.Context, body PathsVeqlyiReposOwnerRepoCodespacesSecretsSecretNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesCreateOrUpdateRepoSecretOptions) (GitHubV3RESTAPIClientCodespacesCreateOrUpdateRepoSecretResponse, error) {
	req, err := client.codespacesCreateOrUpdateRepoSecretCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateRepoSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateRepoSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNoContent) {
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateRepoSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesCreateOrUpdateRepoSecretHandleResponse(resp)
}

// codespacesCreateOrUpdateRepoSecretCreateRequest creates the CodespacesCreateOrUpdateRepoSecret request.
func (client *GitHubV3RESTAPIClient) codespacesCreateOrUpdateRepoSecretCreateRequest(ctx context.Context, body PathsVeqlyiReposOwnerRepoCodespacesSecretsSecretNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesCreateOrUpdateRepoSecretOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// codespacesCreateOrUpdateRepoSecretHandleResponse handles the CodespacesCreateOrUpdateRepoSecret response.
func (client *GitHubV3RESTAPIClient) codespacesCreateOrUpdateRepoSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesCreateOrUpdateRepoSecretResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesCreateOrUpdateRepoSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateRepoSecretResponse{}, err
	}
	return result, nil
}

// CodespacesCreateOrUpdateSecretForAuthenticatedUser - Creates or updates a secret for a user's codespace with an encrypted
// value. Encrypt your secret usingLibSodium [https://libsodium.gitbook.io/doc/bindingsforother_languages].
// You must authenticate using an access token with the codespace or codespace:secrets scope to use this endpoint. User must
// also have Codespaces access to use this endpoint.
// GitHub Apps must have write access to the codespacesusersecrets user permission and codespaces_secrets repository permission
// on all referenced repositories to use this endpoint.
// EXAMPLE ENCRYPTING A SECRET USING NODE.JS Encrypt your secret using the libsodium-wrappers [https://www.npmjs.com/package/libsodium-wrappers]
// library.
// const sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the secret you want to
// encrypt const key = 'base64-encoded-public-key' // replace with the Base64
// encoded public key
// //Check if libsodium is ready and then proceed. sodium.ready.then(() => { // Convert Secret & Base64 key to Uint8Array.
// let binkey = sodium.frombase64(key, sodium.base64variants.ORIGINAL) let binsec =
// sodium.from_string(secret)
// //Encrypt the secret using LibSodium let encBytes = sodium.cryptoboxseal(binsec, binkey)
// // Convert encrypted Uint8Array to Base64 let output = sodium.tobase64(encBytes, sodium.base64variants.ORIGINAL)
// console.log(output) });
// EXAMPLE ENCRYPTING A SECRET USING PYTHON Encrypt your secret using pynacl [https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox]
// with Python 3.
// from base64 import b64encode from nacl import encoding, public
// def encrypt(publickey: str, secretvalue: str) -> str: """Encrypt a Unicode string using the public key.""" publickey =
// public.PublicKey(publickey.encode("utf-8"), encoding.Base64Encoder()) sealedbox =
// public.SealedBox(publickey) encrypted = sealedbox.encrypt(secretvalue.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
// EXAMPLE ENCRYPTING A SECRET USING C Encrypt your secret using the Sodium.Core [https://www.nuget.org/packages/Sodium.Core/]
// package.
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// EXAMPLE ENCRYPTING A SECRET USING RUBY Encrypt your secret using the rbnacl [https://github.com/RubyCrypto/rbnacl] gem.
// require "rbnacl" require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.frompublickey(publickey) encryptedsecret = box.encrypt("my_secret")
// PRINT THE BASE64 ENCODED SECRET
// puts Base64.strictencode64(encryptedsecret)
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesCreateOrUpdateSecretForAuthenticatedUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.CodespacesCreateOrUpdateSecretForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesCreateOrUpdateSecretForAuthenticatedUser(ctx context.Context, body Paths13ZchtlUserCodespacesSecretsSecretNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesCreateOrUpdateSecretForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesCreateOrUpdateSecretForAuthenticatedUserResponse, error) {
	req, err := client.codespacesCreateOrUpdateSecretForAuthenticatedUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateSecretForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateSecretForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNoContent, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateSecretForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesCreateOrUpdateSecretForAuthenticatedUserHandleResponse(resp)
}

// codespacesCreateOrUpdateSecretForAuthenticatedUserCreateRequest creates the CodespacesCreateOrUpdateSecretForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesCreateOrUpdateSecretForAuthenticatedUserCreateRequest(ctx context.Context, body Paths13ZchtlUserCodespacesSecretsSecretNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesCreateOrUpdateSecretForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/secrets/{secret_name}"
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// codespacesCreateOrUpdateSecretForAuthenticatedUserHandleResponse handles the CodespacesCreateOrUpdateSecretForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesCreateOrUpdateSecretForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesCreateOrUpdateSecretForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesCreateOrUpdateSecretForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateSecretForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNoContent:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateSecretForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateSecretForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesCreateOrUpdateSecretForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesCreateWithPrForAuthenticatedUser - Creates a codespace owned by the authenticated user for the specified pull
// request.
// You must authenticate using an access token with the codespace scope to use this endpoint.
// GitHub Apps must have write access to the codespaces repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesCreateWithPrForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.CodespacesCreateWithPrForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesCreateWithPrForAuthenticatedUser(ctx context.Context, body Paths11Kn4B9ReposOwnerRepoPullsPullNumberCodespacesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesCreateWithPrForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesCreateWithPrForAuthenticatedUserResponse, error) {
	req, err := client.codespacesCreateWithPrForAuthenticatedUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithPrForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithPrForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusAccepted, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientCodespacesCreateWithPrForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesCreateWithPrForAuthenticatedUserHandleResponse(resp)
}

// codespacesCreateWithPrForAuthenticatedUserCreateRequest creates the CodespacesCreateWithPrForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesCreateWithPrForAuthenticatedUserCreateRequest(ctx context.Context, body Paths11Kn4B9ReposOwnerRepoPullsPullNumberCodespacesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesCreateWithPrForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// codespacesCreateWithPrForAuthenticatedUserHandleResponse handles the CodespacesCreateWithPrForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesCreateWithPrForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesCreateWithPrForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesCreateWithPrForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Codespace
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithPrForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val Codespace
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithPrForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithPrForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithPrForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithPrForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithPrForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesCreateWithPrForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesCreateWithRepoForAuthenticatedUser - Creates a codespace owned by the authenticated user in the specified repository.
// You must authenticate using an access token with the codespace scope to use this endpoint.
// GitHub Apps must have write access to the codespaces repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.CodespacesCreateWithRepoForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesCreateWithRepoForAuthenticatedUser(ctx context.Context, body PathsCojm5BReposOwnerRepoCodespacesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserResponse, error) {
	req, err := client.codespacesCreateWithRepoForAuthenticatedUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesCreateWithRepoForAuthenticatedUserHandleResponse(resp)
}

// codespacesCreateWithRepoForAuthenticatedUserCreateRequest creates the CodespacesCreateWithRepoForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesCreateWithRepoForAuthenticatedUserCreateRequest(ctx context.Context, body PathsCojm5BReposOwnerRepoCodespacesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/codespaces"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// codespacesCreateWithRepoForAuthenticatedUserHandleResponse handles the CodespacesCreateWithRepoForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesCreateWithRepoForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Codespace
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val Codespace
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesCreateWithRepoForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesDeleteCodespacesBillingUsers - Codespaces for the specified users will no longer be billed to the organization.
// To use this endpoint, the billing settings for the organization must be set to selected_members. For information on how
// to change this setting please see [these docs].(https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces)
// You must authenticate using an access token
// with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesDeleteCodespacesBillingUsersOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesDeleteCodespacesBillingUsers
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesDeleteCodespacesBillingUsers(ctx context.Context, body Paths1Qu3T7FOrgsOrgCodespacesBillingSelectedUsersDeleteRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesDeleteCodespacesBillingUsersOptions) (GitHubV3RESTAPIClientCodespacesDeleteCodespacesBillingUsersResponse, error) {
	req, err := client.codespacesDeleteCodespacesBillingUsersCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteCodespacesBillingUsersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteCodespacesBillingUsersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusBadRequest, http.StatusNotFound, http.StatusUnprocessableEntity, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesDeleteCodespacesBillingUsersResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesDeleteCodespacesBillingUsersHandleResponse(resp)
}

// codespacesDeleteCodespacesBillingUsersCreateRequest creates the CodespacesDeleteCodespacesBillingUsers request.
func (client *GitHubV3RESTAPIClient) codespacesDeleteCodespacesBillingUsersCreateRequest(ctx context.Context, body Paths1Qu3T7FOrgsOrgCodespacesBillingSelectedUsersDeleteRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesDeleteCodespacesBillingUsersOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/codespaces/billing/selected_users"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// codespacesDeleteCodespacesBillingUsersHandleResponse handles the CodespacesDeleteCodespacesBillingUsers response.
func (client *GitHubV3RESTAPIClient) codespacesDeleteCodespacesBillingUsersHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesDeleteCodespacesBillingUsersResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesDeleteCodespacesBillingUsersResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotModified:
	case http.StatusBadRequest:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteCodespacesBillingUsersResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteCodespacesBillingUsersResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteCodespacesBillingUsersResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesDeleteCodespacesBillingUsersResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesDeleteForAuthenticatedUser - Deletes a user's codespace.
// You must authenticate using an access token with the codespace scope to use this endpoint.
// GitHub Apps must have write access to the codespaces repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesDeleteForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesDeleteForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesDeleteForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesDeleteForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesDeleteForAuthenticatedUserResponse, error) {
	req, err := client.codespacesDeleteForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesDeleteForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesDeleteForAuthenticatedUserHandleResponse(resp)
}

// codespacesDeleteForAuthenticatedUserCreateRequest creates the CodespacesDeleteForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesDeleteForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesDeleteForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/{codespace_name}"
	if client.codespaceName == "" {
		return nil, errors.New("parameter client.codespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{codespace_name}", url.PathEscape(client.codespaceName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesDeleteForAuthenticatedUserHandleResponse handles the CodespacesDeleteForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesDeleteForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesDeleteForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesDeleteForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesDeleteForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesDeleteFromOrganization - Deletes a user's codespace.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesDeleteFromOrganizationOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesDeleteFromOrganization
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesDeleteFromOrganization(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesDeleteFromOrganizationOptions) (GitHubV3RESTAPIClientCodespacesDeleteFromOrganizationResponse, error) {
	req, err := client.codespacesDeleteFromOrganizationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteFromOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteFromOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesDeleteFromOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesDeleteFromOrganizationHandleResponse(resp)
}

// codespacesDeleteFromOrganizationCreateRequest creates the CodespacesDeleteFromOrganization request.
func (client *GitHubV3RESTAPIClient) codespacesDeleteFromOrganizationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesDeleteFromOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/members/{username}/codespaces/{codespace_name}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	if client.codespaceName == "" {
		return nil, errors.New("parameter client.codespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{codespace_name}", url.PathEscape(client.codespaceName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesDeleteFromOrganizationHandleResponse handles the CodespacesDeleteFromOrganization response.
func (client *GitHubV3RESTAPIClient) codespacesDeleteFromOrganizationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesDeleteFromOrganizationResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesDeleteFromOrganizationResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteFromOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteFromOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteFromOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteFromOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteFromOrganizationResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesDeleteFromOrganizationResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesDeleteOrgSecret - Deletes an organization secret using the secret name. You must authenticate using an access
// token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesDeleteOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesDeleteOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesDeleteOrgSecret(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesDeleteOrgSecretOptions) (GitHubV3RESTAPIClientCodespacesDeleteOrgSecretResponse, error) {
	req, err := client.codespacesDeleteOrgSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientCodespacesDeleteOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesDeleteOrgSecretHandleResponse(resp)
}

// codespacesDeleteOrgSecretCreateRequest creates the CodespacesDeleteOrgSecret request.
func (client *GitHubV3RESTAPIClient) codespacesDeleteOrgSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesDeleteOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/codespaces/secrets/{secret_name}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesDeleteOrgSecretHandleResponse handles the CodespacesDeleteOrgSecret response.
func (client *GitHubV3RESTAPIClient) codespacesDeleteOrgSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesDeleteOrgSecretResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesDeleteOrgSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteOrgSecretResponse{}, err
	}
	return result, nil
}

// CodespacesDeleteRepoSecret - Deletes a secret in a repository using the secret name. You must authenticate using an access
// token with the repo scope to use this endpoint. GitHub Apps must have write access to the
// codespaces_secrets repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesDeleteRepoSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesDeleteRepoSecret
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesDeleteRepoSecret(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesDeleteRepoSecretOptions) (GitHubV3RESTAPIClientCodespacesDeleteRepoSecretResponse, error) {
	req, err := client.codespacesDeleteRepoSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteRepoSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteRepoSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientCodespacesDeleteRepoSecretResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientCodespacesDeleteRepoSecretResponse{}, nil
}

// codespacesDeleteRepoSecretCreateRequest creates the CodespacesDeleteRepoSecret request.
func (client *GitHubV3RESTAPIClient) codespacesDeleteRepoSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesDeleteRepoSecretOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// CodespacesDeleteSecretForAuthenticatedUser - Deletes a secret from a user's codespaces using the secret name. Deleting
// the secret will remove access from all codespaces that were allowed to access the secret.
// You must authenticate using an access token with the codespace or codespace:secrets scope to use this endpoint. User must
// have Codespaces access to use this endpoint.
// GitHub Apps must have write access to the codespacesusersecrets user permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesDeleteSecretForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.CodespacesDeleteSecretForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesDeleteSecretForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesDeleteSecretForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesDeleteSecretForAuthenticatedUserResponse, error) {
	req, err := client.codespacesDeleteSecretForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteSecretForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesDeleteSecretForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientCodespacesDeleteSecretForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientCodespacesDeleteSecretForAuthenticatedUserResponse{}, nil
}

// codespacesDeleteSecretForAuthenticatedUserCreateRequest creates the CodespacesDeleteSecretForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesDeleteSecretForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesDeleteSecretForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/secrets/{secret_name}"
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// CodespacesExportForAuthenticatedUser - Triggers an export of the specified codespace and returns a URL and ID where the
// status of the export can be monitored.
// If changes cannot be pushed to the codespace's repository, they will be pushed to a new or previously-existing fork instead.
// You must authenticate using a personal access token with the codespace scope to use this endpoint.
// GitHub Apps must have write access to the codespaceslifecycleadmin repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesExportForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesExportForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesExportForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesExportForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesExportForAuthenticatedUserResponse, error) {
	req, err := client.codespacesExportForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesExportForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesExportForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesExportForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesExportForAuthenticatedUserHandleResponse(resp)
}

// codespacesExportForAuthenticatedUserCreateRequest creates the CodespacesExportForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesExportForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesExportForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/{codespace_name}/exports"
	if client.codespaceName == "" {
		return nil, errors.New("parameter client.codespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{codespace_name}", url.PathEscape(client.codespaceName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesExportForAuthenticatedUserHandleResponse handles the CodespacesExportForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesExportForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesExportForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesExportForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val CodespaceExportDetails
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesExportForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesExportForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesExportForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesExportForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesExportForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesExportForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesExportForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesGetCodespacesForUserInOrg - Lists the codespaces that a member of an organization has for repositories in that
// organization.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesGetCodespacesForUserInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesGetCodespacesForUserInOrg
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesGetCodespacesForUserInOrg(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetCodespacesForUserInOrgOptions) (GitHubV3RESTAPIClientCodespacesGetCodespacesForUserInOrgResponse, error) {
	req, err := client.codespacesGetCodespacesForUserInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetCodespacesForUserInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetCodespacesForUserInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesGetCodespacesForUserInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesGetCodespacesForUserInOrgHandleResponse(resp)
}

// codespacesGetCodespacesForUserInOrgCreateRequest creates the CodespacesGetCodespacesForUserInOrg request.
func (client *GitHubV3RESTAPIClient) codespacesGetCodespacesForUserInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetCodespacesForUserInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/members/{username}/codespaces"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesGetCodespacesForUserInOrgHandleResponse handles the CodespacesGetCodespacesForUserInOrg response.
func (client *GitHubV3RESTAPIClient) codespacesGetCodespacesForUserInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesGetCodespacesForUserInOrgResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesGetCodespacesForUserInOrgResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Paths196BhohOrgsOrgMembersUsernameCodespacesGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetCodespacesForUserInOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetCodespacesForUserInOrgResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetCodespacesForUserInOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetCodespacesForUserInOrgResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetCodespacesForUserInOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesGetCodespacesForUserInOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesGetExportDetailsForAuthenticatedUser - Gets information about an export of a codespace.
// You must authenticate using a personal access token with the codespace scope to use this endpoint.
// GitHub Apps must have read access to the codespaceslifecycleadmin repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesGetExportDetailsForAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.CodespacesGetExportDetailsForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesGetExportDetailsForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetExportDetailsForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesGetExportDetailsForAuthenticatedUserResponse, error) {
	req, err := client.codespacesGetExportDetailsForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetExportDetailsForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetExportDetailsForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientCodespacesGetExportDetailsForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesGetExportDetailsForAuthenticatedUserHandleResponse(resp)
}

// codespacesGetExportDetailsForAuthenticatedUserCreateRequest creates the CodespacesGetExportDetailsForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesGetExportDetailsForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetExportDetailsForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/{codespace_name}/exports/{export_id}"
	if client.codespaceName == "" {
		return nil, errors.New("parameter client.codespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{codespace_name}", url.PathEscape(client.codespaceName))
	if client.exportID == "" {
		return nil, errors.New("parameter client.exportID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{export_id}", url.PathEscape(client.exportID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesGetExportDetailsForAuthenticatedUserHandleResponse handles the CodespacesGetExportDetailsForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesGetExportDetailsForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesGetExportDetailsForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesGetExportDetailsForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val CodespaceExportDetails
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetExportDetailsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetExportDetailsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesGetExportDetailsForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesGetForAuthenticatedUser - Gets information about a user's codespace.
// You must authenticate using an access token with the codespace scope to use this endpoint.
// GitHub Apps must have read access to the codespaces repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesGetForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesGetForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesGetForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesGetForAuthenticatedUserResponse, error) {
	req, err := client.codespacesGetForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesGetForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesGetForAuthenticatedUserHandleResponse(resp)
}

// codespacesGetForAuthenticatedUserCreateRequest creates the CodespacesGetForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesGetForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/{codespace_name}"
	if client.codespaceName == "" {
		return nil, errors.New("parameter client.codespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{codespace_name}", url.PathEscape(client.codespaceName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesGetForAuthenticatedUserHandleResponse handles the CodespacesGetForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesGetForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesGetForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesGetForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Codespace
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesGetForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesGetOrgPublicKey - Gets a public key for an organization, which is required in order to encrypt secrets. You need
// to encrypt the value of a secret before you can create or update secrets. You must authenticate using an
// access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesGetOrgPublicKeyOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesGetOrgPublicKey
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesGetOrgPublicKey(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetOrgPublicKeyOptions) (GitHubV3RESTAPIClientCodespacesGetOrgPublicKeyResponse, error) {
	req, err := client.codespacesGetOrgPublicKeyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetOrgPublicKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetOrgPublicKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientCodespacesGetOrgPublicKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesGetOrgPublicKeyHandleResponse(resp)
}

// codespacesGetOrgPublicKeyCreateRequest creates the CodespacesGetOrgPublicKey request.
func (client *GitHubV3RESTAPIClient) codespacesGetOrgPublicKeyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetOrgPublicKeyOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/codespaces/secrets/public-key"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesGetOrgPublicKeyHandleResponse handles the CodespacesGetOrgPublicKey response.
func (client *GitHubV3RESTAPIClient) codespacesGetOrgPublicKeyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesGetOrgPublicKeyResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesGetOrgPublicKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CodespacesPublicKey); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetOrgPublicKeyResponse{}, err
	}
	return result, nil
}

// CodespacesGetOrgSecret - Gets an organization secret without revealing its encrypted value. You must authenticate using
// an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesGetOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesGetOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesGetOrgSecret(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetOrgSecretOptions) (GitHubV3RESTAPIClientCodespacesGetOrgSecretResponse, error) {
	req, err := client.codespacesGetOrgSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientCodespacesGetOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesGetOrgSecretHandleResponse(resp)
}

// codespacesGetOrgSecretCreateRequest creates the CodespacesGetOrgSecret request.
func (client *GitHubV3RESTAPIClient) codespacesGetOrgSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/codespaces/secrets/{secret_name}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesGetOrgSecretHandleResponse handles the CodespacesGetOrgSecret response.
func (client *GitHubV3RESTAPIClient) codespacesGetOrgSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesGetOrgSecretResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesGetOrgSecretResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.CodespacesOrgSecret); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetOrgSecretResponse{}, err
	}
	return result, nil
}

// CodespacesGetPublicKeyForAuthenticatedUser - Gets your public key, which you need to encrypt secrets. You need to encrypt
// a secret before you can create or update secrets.
// You must authenticate using an access token with the codespace or codespace:secrets scope to use this endpoint. User must
// have Codespaces access to use this endpoint.
// GitHub Apps must have read access to the codespacesusersecrets user permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesGetPublicKeyForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.CodespacesGetPublicKeyForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesGetPublicKeyForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetPublicKeyForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesGetPublicKeyForAuthenticatedUserResponse, error) {
	req, err := client.codespacesGetPublicKeyForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetPublicKeyForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetPublicKeyForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientCodespacesGetPublicKeyForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesGetPublicKeyForAuthenticatedUserHandleResponse(resp)
}

// codespacesGetPublicKeyForAuthenticatedUserCreateRequest creates the CodespacesGetPublicKeyForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesGetPublicKeyForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetPublicKeyForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/secrets/public-key"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesGetPublicKeyForAuthenticatedUserHandleResponse handles the CodespacesGetPublicKeyForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesGetPublicKeyForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesGetPublicKeyForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesGetPublicKeyForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CodespacesUserPublicKey); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetPublicKeyForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// CodespacesGetRepoPublicKey - Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before
// you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the
// repository is private you must use an access token with the repo scope. GitHub Apps must have write access to the codespaces_secrets
// repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesGetRepoPublicKeyOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesGetRepoPublicKey
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesGetRepoPublicKey(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetRepoPublicKeyOptions) (GitHubV3RESTAPIClientCodespacesGetRepoPublicKeyResponse, error) {
	req, err := client.codespacesGetRepoPublicKeyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetRepoPublicKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetRepoPublicKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientCodespacesGetRepoPublicKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesGetRepoPublicKeyHandleResponse(resp)
}

// codespacesGetRepoPublicKeyCreateRequest creates the CodespacesGetRepoPublicKey request.
func (client *GitHubV3RESTAPIClient) codespacesGetRepoPublicKeyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetRepoPublicKeyOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/codespaces/secrets/public-key"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesGetRepoPublicKeyHandleResponse handles the CodespacesGetRepoPublicKey response.
func (client *GitHubV3RESTAPIClient) codespacesGetRepoPublicKeyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesGetRepoPublicKeyResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesGetRepoPublicKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CodespacesPublicKey); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetRepoPublicKeyResponse{}, err
	}
	return result, nil
}

// CodespacesGetRepoSecret - Gets a single repository secret without revealing its encrypted value. You must authenticate
// using an access token with the repo scope to use this endpoint. GitHub Apps must have write access to the
// codespaces_secrets repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesGetRepoSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesGetRepoSecret
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesGetRepoSecret(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetRepoSecretOptions) (GitHubV3RESTAPIClientCodespacesGetRepoSecretResponse, error) {
	req, err := client.codespacesGetRepoSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetRepoSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetRepoSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientCodespacesGetRepoSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesGetRepoSecretHandleResponse(resp)
}

// codespacesGetRepoSecretCreateRequest creates the CodespacesGetRepoSecret request.
func (client *GitHubV3RESTAPIClient) codespacesGetRepoSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetRepoSecretOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesGetRepoSecretHandleResponse handles the CodespacesGetRepoSecret response.
func (client *GitHubV3RESTAPIClient) codespacesGetRepoSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesGetRepoSecretResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesGetRepoSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RepoCodespacesSecret); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetRepoSecretResponse{}, err
	}
	return result, nil
}

// CodespacesGetSecretForAuthenticatedUser - Gets a secret available to a user's codespaces without revealing its encrypted
// value.
// You must authenticate using an access token with the codespace or codespace:secrets scope to use this endpoint. User must
// have Codespaces access to use this endpoint.
// GitHub Apps must have read access to the codespacesusersecrets user permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesGetSecretForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.CodespacesGetSecretForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesGetSecretForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetSecretForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesGetSecretForAuthenticatedUserResponse, error) {
	req, err := client.codespacesGetSecretForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetSecretForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesGetSecretForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientCodespacesGetSecretForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesGetSecretForAuthenticatedUserHandleResponse(resp)
}

// codespacesGetSecretForAuthenticatedUserCreateRequest creates the CodespacesGetSecretForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesGetSecretForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesGetSecretForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/secrets/{secret_name}"
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesGetSecretForAuthenticatedUserHandleResponse handles the CodespacesGetSecretForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesGetSecretForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesGetSecretForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesGetSecretForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CodespacesSecret); err != nil {
		return GitHubV3RESTAPIClientCodespacesGetSecretForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// CodespacesListDevcontainersInRepositoryForAuthenticatedUser - Lists the devcontainer.json files associated with a specified
// repository and the authenticated user. These files specify launchpoint configurations for codespaces created within the
// repository.
// You must authenticate using an access token with the codespace scope to use this endpoint.
// GitHub Apps must have read access to the codespaces_metadata repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesListDevcontainersInRepositoryForAuthenticatedUserOptions contains the optional
//     parameters for the GitHubV3RESTAPIClient.CodespacesListDevcontainersInRepositoryForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesListDevcontainersInRepositoryForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListDevcontainersInRepositoryForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse, error) {
	req, err := client.codespacesListDevcontainersInRepositoryForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesListDevcontainersInRepositoryForAuthenticatedUserHandleResponse(resp)
}

// codespacesListDevcontainersInRepositoryForAuthenticatedUserCreateRequest creates the CodespacesListDevcontainersInRepositoryForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesListDevcontainersInRepositoryForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListDevcontainersInRepositoryForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/codespaces/devcontainers"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// codespacesListDevcontainersInRepositoryForAuthenticatedUserHandleResponse handles the CodespacesListDevcontainersInRepositoryForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesListDevcontainersInRepositoryForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PathsStw7QyReposOwnerRepoCodespacesDevcontainersGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesListForAuthenticatedUser - Lists the authenticated user's codespaces.
// You must authenticate using an access token with the codespace scope to use this endpoint.
// GitHub Apps must have read access to the codespaces repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesListForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesListForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesListForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesListForAuthenticatedUserResponse, error) {
	req, err := client.codespacesListForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesListForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesListForAuthenticatedUserHandleResponse(resp)
}

// codespacesListForAuthenticatedUserCreateRequest creates the CodespacesListForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesListForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces"
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(client.repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesListForAuthenticatedUserHandleResponse handles the CodespacesListForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesListForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesListForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesListForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Paths1Pqtc48UserCodespacesGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesListForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesListInOrganization - Lists the codespaces associated to a specified organization.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesListInOrganizationOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesListInOrganization
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesListInOrganization(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListInOrganizationOptions) (GitHubV3RESTAPIClientCodespacesListInOrganizationResponse, error) {
	req, err := client.codespacesListInOrganizationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListInOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListInOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesListInOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesListInOrganizationHandleResponse(resp)
}

// codespacesListInOrganizationCreateRequest creates the CodespacesListInOrganization request.
func (client *GitHubV3RESTAPIClient) codespacesListInOrganizationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListInOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/codespaces"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesListInOrganizationHandleResponse handles the CodespacesListInOrganization response.
func (client *GitHubV3RESTAPIClient) codespacesListInOrganizationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesListInOrganizationResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesListInOrganizationResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Paths19XtxndOrgsOrgCodespacesGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListInOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListInOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListInOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListInOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListInOrganizationResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesListInOrganizationResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesListInRepositoryForAuthenticatedUser - Lists the codespaces associated to a specified repository and the authenticated
// user.
// You must authenticate using an access token with the codespace scope to use this endpoint.
// GitHub Apps must have read access to the codespaces repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesListInRepositoryForAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.CodespacesListInRepositoryForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesListInRepositoryForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListInRepositoryForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesListInRepositoryForAuthenticatedUserResponse, error) {
	req, err := client.codespacesListInRepositoryForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListInRepositoryForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListInRepositoryForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesListInRepositoryForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesListInRepositoryForAuthenticatedUserHandleResponse(resp)
}

// codespacesListInRepositoryForAuthenticatedUserCreateRequest creates the CodespacesListInRepositoryForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesListInRepositoryForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListInRepositoryForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/codespaces"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesListInRepositoryForAuthenticatedUserHandleResponse handles the CodespacesListInRepositoryForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesListInRepositoryForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesListInRepositoryForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesListInRepositoryForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Paths1Nlo92OReposOwnerRepoCodespacesGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListInRepositoryForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListInRepositoryForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListInRepositoryForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListInRepositoryForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListInRepositoryForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesListInRepositoryForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesListOrgSecrets - Lists all Codespaces secrets available at the organization-level without revealing their encrypted
// values. You must authenticate using an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesListOrgSecretsOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesListOrgSecrets
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesListOrgSecrets(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListOrgSecretsOptions) (GitHubV3RESTAPIClientCodespacesListOrgSecretsResponse, error) {
	req, err := client.codespacesListOrgSecretsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListOrgSecretsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListOrgSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientCodespacesListOrgSecretsResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesListOrgSecretsHandleResponse(resp)
}

// codespacesListOrgSecretsCreateRequest creates the CodespacesListOrgSecrets request.
func (client *GitHubV3RESTAPIClient) codespacesListOrgSecretsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListOrgSecretsOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/codespaces/secrets"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesListOrgSecretsHandleResponse handles the CodespacesListOrgSecrets response.
func (client *GitHubV3RESTAPIClient) codespacesListOrgSecretsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesListOrgSecretsResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesListOrgSecretsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsNfvr3JOrgsOrgCodespacesSecretsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientCodespacesListOrgSecretsResponse{}, err
	}
	return result, nil
}

// CodespacesListRepoSecrets - Lists all secrets available in a repository without revealing their encrypted values. You must
// authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have write
// access to the codespaces_secrets repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesListRepoSecretsOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesListRepoSecrets
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesListRepoSecrets(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListRepoSecretsOptions) (GitHubV3RESTAPIClientCodespacesListRepoSecretsResponse, error) {
	req, err := client.codespacesListRepoSecretsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListRepoSecretsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListRepoSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientCodespacesListRepoSecretsResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesListRepoSecretsHandleResponse(resp)
}

// codespacesListRepoSecretsCreateRequest creates the CodespacesListRepoSecrets request.
func (client *GitHubV3RESTAPIClient) codespacesListRepoSecretsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListRepoSecretsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/codespaces/secrets"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesListRepoSecretsHandleResponse handles the CodespacesListRepoSecrets response.
func (client *GitHubV3RESTAPIClient) codespacesListRepoSecretsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesListRepoSecretsResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesListRepoSecretsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsSuadw4ReposOwnerRepoCodespacesSecretsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientCodespacesListRepoSecretsResponse{}, err
	}
	return result, nil
}

// CodespacesListRepositoriesForSecretForAuthenticatedUser - List the repositories that have been granted the ability to use
// a user's codespace secret.
// You must authenticate using an access token with the codespace or codespace:secrets scope to use this endpoint. User must
// have Codespaces access to use this endpoint.
// GitHub Apps must have read access to the codespacesusersecrets user permission and write access to the codespaces_secrets
// repository permission on all referenced repositories to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesListRepositoriesForSecretForAuthenticatedUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.CodespacesListRepositoriesForSecretForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesListRepositoriesForSecretForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListRepositoriesForSecretForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesListRepositoriesForSecretForAuthenticatedUserResponse, error) {
	req, err := client.codespacesListRepositoriesForSecretForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListRepositoriesForSecretForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListRepositoriesForSecretForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesListRepositoriesForSecretForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesListRepositoriesForSecretForAuthenticatedUserHandleResponse(resp)
}

// codespacesListRepositoriesForSecretForAuthenticatedUserCreateRequest creates the CodespacesListRepositoriesForSecretForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesListRepositoriesForSecretForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListRepositoriesForSecretForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/secrets/{secret_name}/repositories"
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesListRepositoriesForSecretForAuthenticatedUserHandleResponse handles the CodespacesListRepositoriesForSecretForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesListRepositoriesForSecretForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesListRepositoriesForSecretForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesListRepositoriesForSecretForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Paths19V5QwfUserCodespacesSecretsSecretNameRepositoriesGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListRepositoriesForSecretForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListRepositoriesForSecretForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListRepositoriesForSecretForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListRepositoriesForSecretForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListRepositoriesForSecretForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesListRepositoriesForSecretForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesListSecretsForAuthenticatedUser - Lists all secrets available for a user's Codespaces without revealing their
// encrypted values.
// You must authenticate using an access token with the codespace or codespace:secrets scope to use this endpoint. User must
// have Codespaces access to use this endpoint.
// GitHub Apps must have read access to the codespacesusersecrets user permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesListSecretsForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.CodespacesListSecretsForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesListSecretsForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListSecretsForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesListSecretsForAuthenticatedUserResponse, error) {
	req, err := client.codespacesListSecretsForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListSecretsForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListSecretsForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientCodespacesListSecretsForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesListSecretsForAuthenticatedUserHandleResponse(resp)
}

// codespacesListSecretsForAuthenticatedUserCreateRequest creates the CodespacesListSecretsForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesListSecretsForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListSecretsForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/secrets"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesListSecretsForAuthenticatedUserHandleResponse handles the CodespacesListSecretsForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesListSecretsForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesListSecretsForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesListSecretsForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1Fq4VdfUserCodespacesSecretsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientCodespacesListSecretsForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// CodespacesListSelectedReposForOrgSecret - Lists all repositories that have been selected when the visibility for repository
// access to a secret is set to selected. You must authenticate using an access token with the admin:org scope to use
// this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesListSelectedReposForOrgSecretOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.CodespacesListSelectedReposForOrgSecret method.
func (client *GitHubV3RESTAPIClient) CodespacesListSelectedReposForOrgSecret(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListSelectedReposForOrgSecretOptions) (GitHubV3RESTAPIClientCodespacesListSelectedReposForOrgSecretResponse, error) {
	req, err := client.codespacesListSelectedReposForOrgSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListSelectedReposForOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesListSelectedReposForOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientCodespacesListSelectedReposForOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesListSelectedReposForOrgSecretHandleResponse(resp)
}

// codespacesListSelectedReposForOrgSecretCreateRequest creates the CodespacesListSelectedReposForOrgSecret request.
func (client *GitHubV3RESTAPIClient) codespacesListSelectedReposForOrgSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesListSelectedReposForOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/codespaces/secrets/{secret_name}/repositories"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesListSelectedReposForOrgSecretHandleResponse handles the CodespacesListSelectedReposForOrgSecret response.
func (client *GitHubV3RESTAPIClient) codespacesListSelectedReposForOrgSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesListSelectedReposForOrgSecretResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesListSelectedReposForOrgSecretResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Paths115B0B9OrgsOrgCodespacesSecretsSecretNameRepositoriesGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListSelectedReposForOrgSecretResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesListSelectedReposForOrgSecretResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesListSelectedReposForOrgSecretResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesPreFlightWithRepoForAuthenticatedUser - Gets the default attributes for codespaces created by the user with the
// repository.
// You must authenticate using an access token with the codespace scope to use this endpoint.
// GitHub Apps must have write access to the codespaces repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesPreFlightWithRepoForAuthenticatedUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.CodespacesPreFlightWithRepoForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesPreFlightWithRepoForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesPreFlightWithRepoForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesPreFlightWithRepoForAuthenticatedUserResponse, error) {
	req, err := client.codespacesPreFlightWithRepoForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesPreFlightWithRepoForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesPreFlightWithRepoForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientCodespacesPreFlightWithRepoForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesPreFlightWithRepoForAuthenticatedUserHandleResponse(resp)
}

// codespacesPreFlightWithRepoForAuthenticatedUserCreateRequest creates the CodespacesPreFlightWithRepoForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesPreFlightWithRepoForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesPreFlightWithRepoForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/codespaces/new"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Ref != nil {
		reqQP.Set("ref", *options.Ref)
	}
	if options != nil && options.ClientIP != nil {
		reqQP.Set("client_ip", *options.ClientIP)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesPreFlightWithRepoForAuthenticatedUserHandleResponse handles the CodespacesPreFlightWithRepoForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesPreFlightWithRepoForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesPreFlightWithRepoForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesPreFlightWithRepoForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PathsImvyfvReposOwnerRepoCodespacesNewGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesPreFlightWithRepoForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesPreFlightWithRepoForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesPreFlightWithRepoForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesPreFlightWithRepoForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesPreFlightWithRepoForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesPublishForAuthenticatedUser - Publishes an unpublished codespace, creating a new repository and assigning it
// to the codespace.
// The codespace's token is granted write permissions to the repository, allowing the user to push their changes.
// This will fail for a codespace that is already published, meaning it has an associated repository.
// You must authenticate using a personal access token with the codespace scope to use this endpoint.
// GitHub Apps must have write access to the codespaces repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesPublishForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesPublishForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesPublishForAuthenticatedUser(ctx context.Context, body PathsJ4PjknUserCodespacesCodespaceNamePublishPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesPublishForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesPublishForAuthenticatedUserResponse, error) {
	req, err := client.codespacesPublishForAuthenticatedUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesPublishForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesPublishForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientCodespacesPublishForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesPublishForAuthenticatedUserHandleResponse(resp)
}

// codespacesPublishForAuthenticatedUserCreateRequest creates the CodespacesPublishForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesPublishForAuthenticatedUserCreateRequest(ctx context.Context, body PathsJ4PjknUserCodespacesCodespaceNamePublishPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesPublishForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/{codespace_name}/publish"
	if client.codespaceName == "" {
		return nil, errors.New("parameter client.codespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{codespace_name}", url.PathEscape(client.codespaceName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// codespacesPublishForAuthenticatedUserHandleResponse handles the CodespacesPublishForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesPublishForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesPublishForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesPublishForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val CodespaceWithFullRepository
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesPublishForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesPublishForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesPublishForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesPublishForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesPublishForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesPublishForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesRemoveRepositoryForSecretForAuthenticatedUser - Removes a repository from the selected repositories for a user's
// codespace secret. You must authenticate using an access token with the codespace or codespace:secrets scope to use this
// endpoint. User
// must have Codespaces access to use this endpoint. GitHub Apps must have write access to the codespacesusersecrets user
// permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesRemoveRepositoryForSecretForAuthenticatedUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.CodespacesRemoveRepositoryForSecretForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesRemoveRepositoryForSecretForAuthenticatedUser(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientCodespacesRemoveRepositoryForSecretForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse, error) {
	req, err := client.codespacesRemoveRepositoryForSecretForAuthenticatedUserCreateRequest(ctx, repositoryID, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesRemoveRepositoryForSecretForAuthenticatedUserHandleResponse(resp)
}

// codespacesRemoveRepositoryForSecretForAuthenticatedUserCreateRequest creates the CodespacesRemoveRepositoryForSecretForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesRemoveRepositoryForSecretForAuthenticatedUserCreateRequest(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientCodespacesRemoveRepositoryForSecretForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesRemoveRepositoryForSecretForAuthenticatedUserHandleResponse handles the CodespacesRemoveRepositoryForSecretForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesRemoveRepositoryForSecretForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientCodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// CodespacesRemoveSelectedRepoFromOrgSecret - Removes a repository from an organization secret when the visibility for repository
// access is set to selected. The visibility is set when you Create or update an organization secret
// [https://docs.github.com/rest/reference/codespaces#create-or-update-an-organization-secret]. You must authenticate using
// an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesRemoveSelectedRepoFromOrgSecretOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.CodespacesRemoveSelectedRepoFromOrgSecret method.
func (client *GitHubV3RESTAPIClient) CodespacesRemoveSelectedRepoFromOrgSecret(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientCodespacesRemoveSelectedRepoFromOrgSecretOptions) (GitHubV3RESTAPIClientCodespacesRemoveSelectedRepoFromOrgSecretResponse, error) {
	req, err := client.codespacesRemoveSelectedRepoFromOrgSecretCreateRequest(ctx, repositoryID, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesRemoveSelectedRepoFromOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesRemoveSelectedRepoFromOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound, http.StatusConflict, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientCodespacesRemoveSelectedRepoFromOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesRemoveSelectedRepoFromOrgSecretHandleResponse(resp)
}

// codespacesRemoveSelectedRepoFromOrgSecretCreateRequest creates the CodespacesRemoveSelectedRepoFromOrgSecret request.
func (client *GitHubV3RESTAPIClient) codespacesRemoveSelectedRepoFromOrgSecretCreateRequest(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientCodespacesRemoveSelectedRepoFromOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesRemoveSelectedRepoFromOrgSecretHandleResponse handles the CodespacesRemoveSelectedRepoFromOrgSecret response.
func (client *GitHubV3RESTAPIClient) codespacesRemoveSelectedRepoFromOrgSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesRemoveSelectedRepoFromOrgSecretResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesRemoveSelectedRepoFromOrgSecretResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesRemoveSelectedRepoFromOrgSecretResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesRemoveSelectedRepoFromOrgSecretResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesRemoveSelectedRepoFromOrgSecretResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesRepoMachinesForAuthenticatedUser - List the machine types available for a given repository based on its configuration.
// You must authenticate using an access token with the codespace scope to use this endpoint.
// GitHub Apps must have write access to the codespaces_metadata repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesRepoMachinesForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.CodespacesRepoMachinesForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesRepoMachinesForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesRepoMachinesForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesRepoMachinesForAuthenticatedUserResponse, error) {
	req, err := client.codespacesRepoMachinesForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesRepoMachinesForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesRepoMachinesForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesRepoMachinesForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesRepoMachinesForAuthenticatedUserHandleResponse(resp)
}

// codespacesRepoMachinesForAuthenticatedUserCreateRequest creates the CodespacesRepoMachinesForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesRepoMachinesForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesRepoMachinesForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/codespaces/machines"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Location != nil {
		reqQP.Set("location", *options.Location)
	}
	if options != nil && options.ClientIP != nil {
		reqQP.Set("client_ip", *options.ClientIP)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesRepoMachinesForAuthenticatedUserHandleResponse handles the CodespacesRepoMachinesForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesRepoMachinesForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesRepoMachinesForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesRepoMachinesForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Paths1Mws92VReposOwnerRepoCodespacesMachinesGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesRepoMachinesForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesRepoMachinesForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesRepoMachinesForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesRepoMachinesForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesRepoMachinesForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesRepoMachinesForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesSetCodespacesBilling - Sets which users can access codespaces in an organization. This is synonymous with granting
// or revoking codespaces billing permissions for users according to the visibility. You must authenticate
// using an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesSetCodespacesBillingOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesSetCodespacesBilling
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesSetCodespacesBilling(ctx context.Context, body PathsGbyvoqOrgsOrgCodespacesBillingPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesSetCodespacesBillingOptions) (GitHubV3RESTAPIClientCodespacesSetCodespacesBillingResponse, error) {
	req, err := client.codespacesSetCodespacesBillingCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesSetCodespacesBillingResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesSetCodespacesBillingResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusBadRequest, http.StatusNotFound, http.StatusUnprocessableEntity, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesSetCodespacesBillingResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesSetCodespacesBillingHandleResponse(resp)
}

// codespacesSetCodespacesBillingCreateRequest creates the CodespacesSetCodespacesBilling request.
func (client *GitHubV3RESTAPIClient) codespacesSetCodespacesBillingCreateRequest(ctx context.Context, body PathsGbyvoqOrgsOrgCodespacesBillingPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesSetCodespacesBillingOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/codespaces/billing"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// codespacesSetCodespacesBillingHandleResponse handles the CodespacesSetCodespacesBilling response.
func (client *GitHubV3RESTAPIClient) codespacesSetCodespacesBillingHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesSetCodespacesBillingResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesSetCodespacesBillingResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotModified:
	case http.StatusBadRequest:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesSetCodespacesBillingResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesSetCodespacesBillingResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesSetCodespacesBillingResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesSetCodespacesBillingResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesSetCodespacesBillingUsers - Codespaces for the specified users will be billed to the organization. To use this
// endpoint, the billing settings for the organization must be set to selected_members. For information on how to change
// this setting please see [these docs].(https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces)
// You must authenticate using an access token with the
// admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesSetCodespacesBillingUsersOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesSetCodespacesBillingUsers
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesSetCodespacesBillingUsers(ctx context.Context, body Paths1EsnkluOrgsOrgCodespacesBillingSelectedUsersPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesSetCodespacesBillingUsersOptions) (GitHubV3RESTAPIClientCodespacesSetCodespacesBillingUsersResponse, error) {
	req, err := client.codespacesSetCodespacesBillingUsersCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesSetCodespacesBillingUsersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesSetCodespacesBillingUsersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusBadRequest, http.StatusNotFound, http.StatusUnprocessableEntity, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesSetCodespacesBillingUsersResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesSetCodespacesBillingUsersHandleResponse(resp)
}

// codespacesSetCodespacesBillingUsersCreateRequest creates the CodespacesSetCodespacesBillingUsers request.
func (client *GitHubV3RESTAPIClient) codespacesSetCodespacesBillingUsersCreateRequest(ctx context.Context, body Paths1EsnkluOrgsOrgCodespacesBillingSelectedUsersPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesSetCodespacesBillingUsersOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/codespaces/billing/selected_users"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// codespacesSetCodespacesBillingUsersHandleResponse handles the CodespacesSetCodespacesBillingUsers response.
func (client *GitHubV3RESTAPIClient) codespacesSetCodespacesBillingUsersHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesSetCodespacesBillingUsersResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesSetCodespacesBillingUsersResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotModified:
	case http.StatusBadRequest:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesSetCodespacesBillingUsersResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesSetCodespacesBillingUsersResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesSetCodespacesBillingUsersResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesSetCodespacesBillingUsersResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesSetRepositoriesForSecretForAuthenticatedUser - Select the repositories that will use a user's codespace secret.
// You must authenticate using an access token with the codespace or codespace:secrets scope to use this endpoint. User must
// have Codespaces access to use this endpoint.
// GitHub Apps must have write access to the codespacesusersecrets user permission and write access to the codespaces_secrets
// repository permission on all referenced repositories to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesSetRepositoriesForSecretForAuthenticatedUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.CodespacesSetRepositoriesForSecretForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) CodespacesSetRepositoriesForSecretForAuthenticatedUser(ctx context.Context, body PathsYbfggsUserCodespacesSecretsSecretNameRepositoriesPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesSetRepositoriesForSecretForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesSetRepositoriesForSecretForAuthenticatedUserResponse, error) {
	req, err := client.codespacesSetRepositoriesForSecretForAuthenticatedUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesSetRepositoriesForSecretForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesSetRepositoriesForSecretForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesSetRepositoriesForSecretForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesSetRepositoriesForSecretForAuthenticatedUserHandleResponse(resp)
}

// codespacesSetRepositoriesForSecretForAuthenticatedUserCreateRequest creates the CodespacesSetRepositoriesForSecretForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesSetRepositoriesForSecretForAuthenticatedUserCreateRequest(ctx context.Context, body PathsYbfggsUserCodespacesSecretsSecretNameRepositoriesPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesSetRepositoriesForSecretForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/secrets/{secret_name}/repositories"
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// codespacesSetRepositoriesForSecretForAuthenticatedUserHandleResponse handles the CodespacesSetRepositoriesForSecretForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesSetRepositoriesForSecretForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesSetRepositoriesForSecretForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesSetRepositoriesForSecretForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientCodespacesSetRepositoriesForSecretForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// CodespacesSetSelectedReposForOrgSecret - Replaces all repositories for an organization secret when the visibility for repository
// access is set to selected. The visibility is set when you Create or update an organization secret
// [https://docs.github.com/rest/reference/codespaces#create-or-update-an-organization-secret]. You must authenticate using
// an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesSetSelectedReposForOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesSetSelectedReposForOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesSetSelectedReposForOrgSecret(ctx context.Context, body Paths1Ey2W53OrgsOrgCodespacesSecretsSecretNameRepositoriesPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesSetSelectedReposForOrgSecretOptions) (GitHubV3RESTAPIClientCodespacesSetSelectedReposForOrgSecretResponse, error) {
	req, err := client.codespacesSetSelectedReposForOrgSecretCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesSetSelectedReposForOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesSetSelectedReposForOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound, http.StatusConflict) {
		return GitHubV3RESTAPIClientCodespacesSetSelectedReposForOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesSetSelectedReposForOrgSecretHandleResponse(resp)
}

// codespacesSetSelectedReposForOrgSecretCreateRequest creates the CodespacesSetSelectedReposForOrgSecret request.
func (client *GitHubV3RESTAPIClient) codespacesSetSelectedReposForOrgSecretCreateRequest(ctx context.Context, body Paths1Ey2W53OrgsOrgCodespacesSecretsSecretNameRepositoriesPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesSetSelectedReposForOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/codespaces/secrets/{secret_name}/repositories"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// codespacesSetSelectedReposForOrgSecretHandleResponse handles the CodespacesSetSelectedReposForOrgSecret response.
func (client *GitHubV3RESTAPIClient) codespacesSetSelectedReposForOrgSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesSetSelectedReposForOrgSecretResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesSetSelectedReposForOrgSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientCodespacesSetSelectedReposForOrgSecretResponse{}, err
	}
	return result, nil
}

// CodespacesStartForAuthenticatedUser - Starts a user's codespace.
// You must authenticate using an access token with the codespace scope to use this endpoint.
// GitHub Apps must have write access to the codespaceslifecycleadmin repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesStartForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesStartForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserResponse, error) {
	req, err := client.codespacesStartForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusBadRequest, http.StatusUnauthorized, http.StatusPaymentRequired, http.StatusForbidden, http.StatusNotFound, http.StatusConflict, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesStartForAuthenticatedUserHandleResponse(resp)
}

// codespacesStartForAuthenticatedUserCreateRequest creates the CodespacesStartForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesStartForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/{codespace_name}/start"
	if client.codespaceName == "" {
		return nil, errors.New("parameter client.codespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{codespace_name}", url.PathEscape(client.codespaceName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// codespacesStartForAuthenticatedUserHandleResponse handles the CodespacesStartForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesStartForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Codespace
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusPaymentRequired:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesStartForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesStopForAuthenticatedUser - Stops a user's codespace.
// You must authenticate using an access token with the codespace scope to use this endpoint.
// GitHub Apps must have write access to the codespaceslifecycleadmin repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesStopForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesStopForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesStopForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesStopForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesStopForAuthenticatedUserResponse, error) {
	req, err := client.codespacesStopForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesStopForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesStopForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesStopForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesStopForAuthenticatedUserHandleResponse(resp)
}

// codespacesStopForAuthenticatedUserCreateRequest creates the CodespacesStopForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesStopForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesStopForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/{codespace_name}/stop"
	if client.codespaceName == "" {
		return nil, errors.New("parameter client.codespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{codespace_name}", url.PathEscape(client.codespaceName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesStopForAuthenticatedUserHandleResponse handles the CodespacesStopForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesStopForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesStopForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesStopForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Codespace
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStopForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStopForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStopForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStopForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStopForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesStopForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesStopInOrganization - Stops a user's codespace.
// You must authenticate using an access token with the admin:org scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesStopInOrganizationOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesStopInOrganization
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesStopInOrganization(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesStopInOrganizationOptions) (GitHubV3RESTAPIClientCodespacesStopInOrganizationResponse, error) {
	req, err := client.codespacesStopInOrganizationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesStopInOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesStopInOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientCodespacesStopInOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesStopInOrganizationHandleResponse(resp)
}

// codespacesStopInOrganizationCreateRequest creates the CodespacesStopInOrganization request.
func (client *GitHubV3RESTAPIClient) codespacesStopInOrganizationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientCodespacesStopInOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	if client.codespaceName == "" {
		return nil, errors.New("parameter client.codespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{codespace_name}", url.PathEscape(client.codespaceName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// codespacesStopInOrganizationHandleResponse handles the CodespacesStopInOrganization response.
func (client *GitHubV3RESTAPIClient) codespacesStopInOrganizationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesStopInOrganizationResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesStopInOrganizationResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Codespace
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStopInOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStopInOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStopInOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStopInOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesStopInOrganizationResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesStopInOrganizationResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CodespacesUpdateForAuthenticatedUser - Updates a codespace owned by the authenticated user. Currently only the codespace's
// machine type and recent folders can be modified using this endpoint.
// If you specify a new machine type it will be applied the next time your codespace is started.
// You must authenticate using an access token with the codespace scope to use this endpoint.
// GitHub Apps must have write access to the codespaces repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientCodespacesUpdateForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.CodespacesUpdateForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) CodespacesUpdateForAuthenticatedUser(ctx context.Context, body Paths1Ky8NtUserCodespacesCodespaceNamePatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesUpdateForAuthenticatedUserOptions) (GitHubV3RESTAPIClientCodespacesUpdateForAuthenticatedUserResponse, error) {
	req, err := client.codespacesUpdateForAuthenticatedUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesUpdateForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientCodespacesUpdateForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientCodespacesUpdateForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.codespacesUpdateForAuthenticatedUserHandleResponse(resp)
}

// codespacesUpdateForAuthenticatedUserCreateRequest creates the CodespacesUpdateForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) codespacesUpdateForAuthenticatedUserCreateRequest(ctx context.Context, body Paths1Ky8NtUserCodespacesCodespaceNamePatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientCodespacesUpdateForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/codespaces/{codespace_name}"
	if client.codespaceName == "" {
		return nil, errors.New("parameter client.codespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{codespace_name}", url.PathEscape(client.codespaceName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// codespacesUpdateForAuthenticatedUserHandleResponse handles the CodespacesUpdateForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) codespacesUpdateForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientCodespacesUpdateForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientCodespacesUpdateForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Codespace
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesUpdateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesUpdateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesUpdateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientCodespacesUpdateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientCodespacesUpdateForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// DependabotAddSelectedRepoToOrgSecret - Adds a repository to an organization secret when the visibility for repository access
// is set to selected. The visibility is set when you Create or update an organization secret
// [https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret]. You must authenticate using
// an access token with the admin:org scope to use this endpoint. GitHub Apps must
// have the dependabot_secrets organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotAddSelectedRepoToOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotAddSelectedRepoToOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) DependabotAddSelectedRepoToOrgSecret(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientDependabotAddSelectedRepoToOrgSecretOptions) (GitHubV3RESTAPIClientDependabotAddSelectedRepoToOrgSecretResponse, error) {
	req, err := client.dependabotAddSelectedRepoToOrgSecretCreateRequest(ctx, repositoryID, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotAddSelectedRepoToOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotAddSelectedRepoToOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusConflict) {
		return GitHubV3RESTAPIClientDependabotAddSelectedRepoToOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientDependabotAddSelectedRepoToOrgSecretResponse{}, nil
}

// dependabotAddSelectedRepoToOrgSecretCreateRequest creates the DependabotAddSelectedRepoToOrgSecret request.
func (client *GitHubV3RESTAPIClient) dependabotAddSelectedRepoToOrgSecretCreateRequest(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientDependabotAddSelectedRepoToOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// DependabotCreateOrUpdateOrgSecret - Creates or updates an organization secret with an encrypted value. Encrypt your secret
// usingLibSodium [https://libsodium.gitbook.io/doc/bindingsforotherlanguages]. You must authenticate using an
// access token with the admin:org scope to use this endpoint. GitHub Apps must have the dependabotsecrets organization permission
// to use this endpoint.
// EXAMPLE ENCRYPTING A SECRET USING NODE.JS Encrypt your secret using the libsodium-wrappers [https://www.npmjs.com/package/libsodium-wrappers]
// library.
// const sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the secret you want to
// encrypt const key = 'base64-encoded-public-key' // replace with the Base64
// encoded public key
// //Check if libsodium is ready and then proceed. sodium.ready.then(() => { // Convert Secret & Base64 key to Uint8Array.
// let binkey = sodium.frombase64(key, sodium.base64variants.ORIGINAL) let binsec =
// sodium.from_string(secret)
// //Encrypt the secret using LibSodium let encBytes = sodium.cryptoboxseal(binsec, binkey)
// // Convert encrypted Uint8Array to Base64 let output = sodium.tobase64(encBytes, sodium.base64variants.ORIGINAL)
// console.log(output) });
// EXAMPLE ENCRYPTING A SECRET USING PYTHON Encrypt your secret using pynacl [https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox]
// with Python 3.
// from base64 import b64encode from nacl import encoding, public
// def encrypt(publickey: str, secretvalue: str) -> str: """Encrypt a Unicode string using the public key.""" publickey =
// public.PublicKey(publickey.encode("utf-8"), encoding.Base64Encoder()) sealedbox =
// public.SealedBox(publickey) encrypted = sealedbox.encrypt(secretvalue.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
// EXAMPLE ENCRYPTING A SECRET USING C Encrypt your secret using the Sodium.Core [https://www.nuget.org/packages/Sodium.Core/]
// package.
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// EXAMPLE ENCRYPTING A SECRET USING RUBY Encrypt your secret using the rbnacl [https://github.com/RubyCrypto/rbnacl] gem.
// require "rbnacl" require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.frompublickey(publickey) encryptedsecret = box.encrypt("my_secret")
// PRINT THE BASE64 ENCODED SECRET
// puts Base64.strictencode64(encryptedsecret)
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotCreateOrUpdateOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotCreateOrUpdateOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) DependabotCreateOrUpdateOrgSecret(ctx context.Context, body Paths1Bsn237OrgsOrgDependabotSecretsSecretNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientDependabotCreateOrUpdateOrgSecretOptions) (GitHubV3RESTAPIClientDependabotCreateOrUpdateOrgSecretResponse, error) {
	req, err := client.dependabotCreateOrUpdateOrgSecretCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotCreateOrUpdateOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotCreateOrUpdateOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNoContent) {
		return GitHubV3RESTAPIClientDependabotCreateOrUpdateOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.dependabotCreateOrUpdateOrgSecretHandleResponse(resp)
}

// dependabotCreateOrUpdateOrgSecretCreateRequest creates the DependabotCreateOrUpdateOrgSecret request.
func (client *GitHubV3RESTAPIClient) dependabotCreateOrUpdateOrgSecretCreateRequest(ctx context.Context, body Paths1Bsn237OrgsOrgDependabotSecretsSecretNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientDependabotCreateOrUpdateOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/dependabot/secrets/{secret_name}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// dependabotCreateOrUpdateOrgSecretHandleResponse handles the DependabotCreateOrUpdateOrgSecret response.
func (client *GitHubV3RESTAPIClient) dependabotCreateOrUpdateOrgSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientDependabotCreateOrUpdateOrgSecretResponse, error) {
	result := GitHubV3RESTAPIClientDependabotCreateOrUpdateOrgSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return GitHubV3RESTAPIClientDependabotCreateOrUpdateOrgSecretResponse{}, err
	}
	return result, nil
}

// DependabotCreateOrUpdateRepoSecret - Creates or updates a repository secret with an encrypted value. Encrypt your secret
// usingLibSodium [https://libsodium.gitbook.io/doc/bindingsforotherlanguages]. You must authenticate using an access
// token with the repo scope to use this endpoint. GitHub Apps must have the dependabotsecrets repository permission to use
// this endpoint.
// EXAMPLE ENCRYPTING A SECRET USING NODE.JS Encrypt your secret using the libsodium-wrappers [https://www.npmjs.com/package/libsodium-wrappers]
// library.
// const sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the secret you want to
// encrypt const key = 'base64-encoded-public-key' // replace with the Base64
// encoded public key
// //Check if libsodium is ready and then proceed. sodium.ready.then(() => { // Convert Secret & Base64 key to Uint8Array.
// let binkey = sodium.frombase64(key, sodium.base64variants.ORIGINAL) let binsec =
// sodium.from_string(secret)
// //Encrypt the secret using LibSodium let encBytes = sodium.cryptoboxseal(binsec, binkey)
// // Convert encrypted Uint8Array to Base64 let output = sodium.tobase64(encBytes, sodium.base64variants.ORIGINAL)
// console.log(output) });
// EXAMPLE ENCRYPTING A SECRET USING PYTHON Encrypt your secret using pynacl [https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox]
// with Python 3.
// from base64 import b64encode from nacl import encoding, public
// def encrypt(publickey: str, secretvalue: str) -> str: """Encrypt a Unicode string using the public key.""" publickey =
// public.PublicKey(publickey.encode("utf-8"), encoding.Base64Encoder()) sealedbox =
// public.SealedBox(publickey) encrypted = sealedbox.encrypt(secretvalue.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
// EXAMPLE ENCRYPTING A SECRET USING C Encrypt your secret using the Sodium.Core [https://www.nuget.org/packages/Sodium.Core/]
// package.
// var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
// var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
// Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
// EXAMPLE ENCRYPTING A SECRET USING RUBY Encrypt your secret using the rbnacl [https://github.com/RubyCrypto/rbnacl] gem.
// require "rbnacl" require "base64"
// key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key = RbNaCl::PublicKey.new(key)
// box = RbNaCl::Boxes::Sealed.frompublickey(publickey) encryptedsecret = box.encrypt("my_secret")
// PRINT THE BASE64 ENCODED SECRET
// puts Base64.strictencode64(encryptedsecret)
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotCreateOrUpdateRepoSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotCreateOrUpdateRepoSecret
//     method.
func (client *GitHubV3RESTAPIClient) DependabotCreateOrUpdateRepoSecret(ctx context.Context, body Paths10Tu0K6ReposOwnerRepoDependabotSecretsSecretNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientDependabotCreateOrUpdateRepoSecretOptions) (GitHubV3RESTAPIClientDependabotCreateOrUpdateRepoSecretResponse, error) {
	req, err := client.dependabotCreateOrUpdateRepoSecretCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotCreateOrUpdateRepoSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotCreateOrUpdateRepoSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNoContent) {
		return GitHubV3RESTAPIClientDependabotCreateOrUpdateRepoSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.dependabotCreateOrUpdateRepoSecretHandleResponse(resp)
}

// dependabotCreateOrUpdateRepoSecretCreateRequest creates the DependabotCreateOrUpdateRepoSecret request.
func (client *GitHubV3RESTAPIClient) dependabotCreateOrUpdateRepoSecretCreateRequest(ctx context.Context, body Paths10Tu0K6ReposOwnerRepoDependabotSecretsSecretNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientDependabotCreateOrUpdateRepoSecretOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// dependabotCreateOrUpdateRepoSecretHandleResponse handles the DependabotCreateOrUpdateRepoSecret response.
func (client *GitHubV3RESTAPIClient) dependabotCreateOrUpdateRepoSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientDependabotCreateOrUpdateRepoSecretResponse, error) {
	result := GitHubV3RESTAPIClientDependabotCreateOrUpdateRepoSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return GitHubV3RESTAPIClientDependabotCreateOrUpdateRepoSecretResponse{}, err
	}
	return result, nil
}

// DependabotDeleteOrgSecret - Deletes a secret in an organization using the secret name. You must authenticate using an access
// token with the admin:org scope to use this endpoint. GitHub Apps must have the dependabot_secrets
// organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotDeleteOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotDeleteOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) DependabotDeleteOrgSecret(ctx context.Context, options *GitHubV3RESTAPIClientDependabotDeleteOrgSecretOptions) (GitHubV3RESTAPIClientDependabotDeleteOrgSecretResponse, error) {
	req, err := client.dependabotDeleteOrgSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotDeleteOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotDeleteOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientDependabotDeleteOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientDependabotDeleteOrgSecretResponse{}, nil
}

// dependabotDeleteOrgSecretCreateRequest creates the DependabotDeleteOrgSecret request.
func (client *GitHubV3RESTAPIClient) dependabotDeleteOrgSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientDependabotDeleteOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/dependabot/secrets/{secret_name}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// DependabotDeleteRepoSecret - Deletes a secret in a repository using the secret name. You must authenticate using an access
// token with the repo scope to use this endpoint. GitHub Apps must have the dependabot_secrets repository
// permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotDeleteRepoSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotDeleteRepoSecret
//     method.
func (client *GitHubV3RESTAPIClient) DependabotDeleteRepoSecret(ctx context.Context, options *GitHubV3RESTAPIClientDependabotDeleteRepoSecretOptions) (GitHubV3RESTAPIClientDependabotDeleteRepoSecretResponse, error) {
	req, err := client.dependabotDeleteRepoSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotDeleteRepoSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotDeleteRepoSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientDependabotDeleteRepoSecretResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientDependabotDeleteRepoSecretResponse{}, nil
}

// dependabotDeleteRepoSecretCreateRequest creates the DependabotDeleteRepoSecret request.
func (client *GitHubV3RESTAPIClient) dependabotDeleteRepoSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientDependabotDeleteRepoSecretOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// DependabotGetAlert - You must use an access token with the securityevents scope to use this endpoint with private repositories.
// You can also use tokens with the publicrepo scope for public repositories only. GitHub Apps
// must have Dependabot alerts read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotGetAlertOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotGetAlert
//     method.
func (client *GitHubV3RESTAPIClient) DependabotGetAlert(ctx context.Context, options *GitHubV3RESTAPIClientDependabotGetAlertOptions) (GitHubV3RESTAPIClientDependabotGetAlertResponse, error) {
	req, err := client.dependabotGetAlertCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotGetAlertResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotGetAlertResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientDependabotGetAlertResponse{}, runtime.NewResponseError(resp)
	}
	return client.dependabotGetAlertHandleResponse(resp)
}

// dependabotGetAlertCreateRequest creates the DependabotGetAlert request.
func (client *GitHubV3RESTAPIClient) dependabotGetAlertCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientDependabotGetAlertOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{alert_number}", url.PathEscape(strconv.FormatInt(int64(client.alertNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// dependabotGetAlertHandleResponse handles the DependabotGetAlert response.
func (client *GitHubV3RESTAPIClient) dependabotGetAlertHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientDependabotGetAlertResponse, error) {
	result := GitHubV3RESTAPIClientDependabotGetAlertResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val DependabotAlert
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotGetAlertResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotGetAlertResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotGetAlertResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientDependabotGetAlertResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// DependabotGetOrgPublicKey - Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before
// you can create or update secrets. You must authenticate using an access token with the admin:org scope to
// use this endpoint. GitHub Apps must have the dependabot_secrets organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotGetOrgPublicKeyOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotGetOrgPublicKey
//     method.
func (client *GitHubV3RESTAPIClient) DependabotGetOrgPublicKey(ctx context.Context, options *GitHubV3RESTAPIClientDependabotGetOrgPublicKeyOptions) (GitHubV3RESTAPIClientDependabotGetOrgPublicKeyResponse, error) {
	req, err := client.dependabotGetOrgPublicKeyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotGetOrgPublicKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotGetOrgPublicKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientDependabotGetOrgPublicKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.dependabotGetOrgPublicKeyHandleResponse(resp)
}

// dependabotGetOrgPublicKeyCreateRequest creates the DependabotGetOrgPublicKey request.
func (client *GitHubV3RESTAPIClient) dependabotGetOrgPublicKeyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientDependabotGetOrgPublicKeyOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/dependabot/secrets/public-key"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// dependabotGetOrgPublicKeyHandleResponse handles the DependabotGetOrgPublicKey response.
func (client *GitHubV3RESTAPIClient) dependabotGetOrgPublicKeyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientDependabotGetOrgPublicKeyResponse, error) {
	result := GitHubV3RESTAPIClientDependabotGetOrgPublicKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DependabotPublicKey); err != nil {
		return GitHubV3RESTAPIClientDependabotGetOrgPublicKeyResponse{}, err
	}
	return result, nil
}

// DependabotGetOrgSecret - Gets a single organization secret without revealing its encrypted value. You must authenticate
// using an access token with the admin:org scope to use this endpoint. GitHub Apps must have the
// dependabot_secrets organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotGetOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotGetOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) DependabotGetOrgSecret(ctx context.Context, options *GitHubV3RESTAPIClientDependabotGetOrgSecretOptions) (GitHubV3RESTAPIClientDependabotGetOrgSecretResponse, error) {
	req, err := client.dependabotGetOrgSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotGetOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotGetOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientDependabotGetOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.dependabotGetOrgSecretHandleResponse(resp)
}

// dependabotGetOrgSecretCreateRequest creates the DependabotGetOrgSecret request.
func (client *GitHubV3RESTAPIClient) dependabotGetOrgSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientDependabotGetOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/dependabot/secrets/{secret_name}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// dependabotGetOrgSecretHandleResponse handles the DependabotGetOrgSecret response.
func (client *GitHubV3RESTAPIClient) dependabotGetOrgSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientDependabotGetOrgSecretResponse, error) {
	result := GitHubV3RESTAPIClientDependabotGetOrgSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.OrganizationDependabotSecret); err != nil {
		return GitHubV3RESTAPIClientDependabotGetOrgSecretResponse{}, err
	}
	return result, nil
}

// DependabotGetRepoPublicKey - Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before
// you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the
// repository is private you must use an access token with the repo scope. GitHub Apps must have the dependabot_secrets repository
// permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotGetRepoPublicKeyOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotGetRepoPublicKey
//     method.
func (client *GitHubV3RESTAPIClient) DependabotGetRepoPublicKey(ctx context.Context, options *GitHubV3RESTAPIClientDependabotGetRepoPublicKeyOptions) (GitHubV3RESTAPIClientDependabotGetRepoPublicKeyResponse, error) {
	req, err := client.dependabotGetRepoPublicKeyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotGetRepoPublicKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotGetRepoPublicKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientDependabotGetRepoPublicKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.dependabotGetRepoPublicKeyHandleResponse(resp)
}

// dependabotGetRepoPublicKeyCreateRequest creates the DependabotGetRepoPublicKey request.
func (client *GitHubV3RESTAPIClient) dependabotGetRepoPublicKeyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientDependabotGetRepoPublicKeyOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/dependabot/secrets/public-key"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// dependabotGetRepoPublicKeyHandleResponse handles the DependabotGetRepoPublicKey response.
func (client *GitHubV3RESTAPIClient) dependabotGetRepoPublicKeyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientDependabotGetRepoPublicKeyResponse, error) {
	result := GitHubV3RESTAPIClientDependabotGetRepoPublicKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DependabotPublicKey); err != nil {
		return GitHubV3RESTAPIClientDependabotGetRepoPublicKeyResponse{}, err
	}
	return result, nil
}

// DependabotGetRepoSecret - Gets a single repository secret without revealing its encrypted value. You must authenticate
// using an access token with the repo scope to use this endpoint. GitHub Apps must have the
// dependabot_secrets repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotGetRepoSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotGetRepoSecret
//     method.
func (client *GitHubV3RESTAPIClient) DependabotGetRepoSecret(ctx context.Context, options *GitHubV3RESTAPIClientDependabotGetRepoSecretOptions) (GitHubV3RESTAPIClientDependabotGetRepoSecretResponse, error) {
	req, err := client.dependabotGetRepoSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotGetRepoSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotGetRepoSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientDependabotGetRepoSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.dependabotGetRepoSecretHandleResponse(resp)
}

// dependabotGetRepoSecretCreateRequest creates the DependabotGetRepoSecret request.
func (client *GitHubV3RESTAPIClient) dependabotGetRepoSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientDependabotGetRepoSecretOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// dependabotGetRepoSecretHandleResponse handles the DependabotGetRepoSecret response.
func (client *GitHubV3RESTAPIClient) dependabotGetRepoSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientDependabotGetRepoSecretResponse, error) {
	result := GitHubV3RESTAPIClientDependabotGetRepoSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DependabotSecret); err != nil {
		return GitHubV3RESTAPIClientDependabotGetRepoSecretResponse{}, err
	}
	return result, nil
}

// DependabotListAlertsForEnterprise - Lists Dependabot alerts for repositories that are owned by the specified enterprise.
// To use this endpoint, you must be a member of the enterprise, and you must use an access token with the repo scope
// or security_events scope. Alerts are only returned for organizations in the enterprise for which you are an organization
// owner or a security manager. For more information about security managers, see
// "Managing security managers in your organization [https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotListAlertsForEnterpriseOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotListAlertsForEnterprise
//     method.
func (client *GitHubV3RESTAPIClient) DependabotListAlertsForEnterprise(ctx context.Context, options *GitHubV3RESTAPIClientDependabotListAlertsForEnterpriseOptions) (GitHubV3RESTAPIClientDependabotListAlertsForEnterpriseResponse, error) {
	req, err := client.dependabotListAlertsForEnterpriseCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForEnterpriseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForEnterpriseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientDependabotListAlertsForEnterpriseResponse{}, runtime.NewResponseError(resp)
	}
	return client.dependabotListAlertsForEnterpriseHandleResponse(resp)
}

// dependabotListAlertsForEnterpriseCreateRequest creates the DependabotListAlertsForEnterprise request.
func (client *GitHubV3RESTAPIClient) dependabotListAlertsForEnterpriseCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientDependabotListAlertsForEnterpriseOptions) (*policy.Request, error) {
	urlPath := "/enterprises/{enterprise}/dependabot/alerts"
	if client.enterprise == "" {
		return nil, errors.New("parameter client.enterprise cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{enterprise}", url.PathEscape(client.enterprise))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.state != nil {
		reqQP.Set("state", *client.state)
	}
	if client.severity != nil {
		reqQP.Set("severity", *client.severity)
	}
	if client.ecosystem != nil {
		reqQP.Set("ecosystem", *client.ecosystem)
	}
	if client.packageParam != nil {
		reqQP.Set("package", *client.packageParam)
	}
	if client.scope != nil {
		reqQP.Set("scope", string(*client.scope))
	}
	if client.sortParam != nil {
		reqQP.Set("sort", string(*client.sortParam))
	}
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if client.before != nil {
		reqQP.Set("before", *client.before)
	}
	if client.after != nil {
		reqQP.Set("after", *client.after)
	}
	if client.first != nil {
		reqQP.Set("first", strconv.FormatInt(int64(*client.first), 10))
	}
	if client.last != nil {
		reqQP.Set("last", strconv.FormatInt(int64(*client.last), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// dependabotListAlertsForEnterpriseHandleResponse handles the DependabotListAlertsForEnterprise response.
func (client *GitHubV3RESTAPIClient) dependabotListAlertsForEnterpriseHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientDependabotListAlertsForEnterpriseResponse, error) {
	result := GitHubV3RESTAPIClientDependabotListAlertsForEnterpriseResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*DependabotAlertWithRepository
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForEnterpriseResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForEnterpriseResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForEnterpriseResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForEnterpriseResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientDependabotListAlertsForEnterpriseResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// DependabotListAlertsForOrg - Lists Dependabot alerts for an organization.
// To use this endpoint, you must be an owner or security manager for the organization, and you must use an access token with
// the repo scope or security_events scope.
// For public repositories, you may instead use the public_repo scope.
// GitHub Apps must have Dependabot alerts read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotListAlertsForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotListAlertsForOrg
//     method.
func (client *GitHubV3RESTAPIClient) DependabotListAlertsForOrg(ctx context.Context, options *GitHubV3RESTAPIClientDependabotListAlertsForOrgOptions) (GitHubV3RESTAPIClientDependabotListAlertsForOrgResponse, error) {
	req, err := client.dependabotListAlertsForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusBadRequest, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientDependabotListAlertsForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.dependabotListAlertsForOrgHandleResponse(resp)
}

// dependabotListAlertsForOrgCreateRequest creates the DependabotListAlertsForOrg request.
func (client *GitHubV3RESTAPIClient) dependabotListAlertsForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientDependabotListAlertsForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/dependabot/alerts"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.state != nil {
		reqQP.Set("state", *client.state)
	}
	if client.severity != nil {
		reqQP.Set("severity", *client.severity)
	}
	if client.ecosystem != nil {
		reqQP.Set("ecosystem", *client.ecosystem)
	}
	if client.packageParam != nil {
		reqQP.Set("package", *client.packageParam)
	}
	if client.scope != nil {
		reqQP.Set("scope", string(*client.scope))
	}
	if client.sortParam != nil {
		reqQP.Set("sort", string(*client.sortParam))
	}
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if client.before != nil {
		reqQP.Set("before", *client.before)
	}
	if client.after != nil {
		reqQP.Set("after", *client.after)
	}
	if client.first != nil {
		reqQP.Set("first", strconv.FormatInt(int64(*client.first), 10))
	}
	if client.last != nil {
		reqQP.Set("last", strconv.FormatInt(int64(*client.last), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// dependabotListAlertsForOrgHandleResponse handles the DependabotListAlertsForOrg response.
func (client *GitHubV3RESTAPIClient) dependabotListAlertsForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientDependabotListAlertsForOrgResponse, error) {
	result := GitHubV3RESTAPIClientDependabotListAlertsForOrgResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*DependabotAlertWithRepository
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientDependabotListAlertsForOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// DependabotListAlertsForRepo - You must use an access token with the securityevents scope to use this endpoint with private
// repositories. You can also use tokens with the publicrepo scope for public repositories only. GitHub Apps
// must have Dependabot alerts read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotListAlertsForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotListAlertsForRepo
//     method.
func (client *GitHubV3RESTAPIClient) DependabotListAlertsForRepo(ctx context.Context, options *GitHubV3RESTAPIClientDependabotListAlertsForRepoOptions) (GitHubV3RESTAPIClientDependabotListAlertsForRepoResponse, error) {
	req, err := client.dependabotListAlertsForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusBadRequest, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientDependabotListAlertsForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.dependabotListAlertsForRepoHandleResponse(resp)
}

// dependabotListAlertsForRepoCreateRequest creates the DependabotListAlertsForRepo request.
func (client *GitHubV3RESTAPIClient) dependabotListAlertsForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientDependabotListAlertsForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/dependabot/alerts"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.state != nil {
		reqQP.Set("state", *client.state)
	}
	if client.severity != nil {
		reqQP.Set("severity", *client.severity)
	}
	if client.ecosystem != nil {
		reqQP.Set("ecosystem", *client.ecosystem)
	}
	if client.packageParam != nil {
		reqQP.Set("package", *client.packageParam)
	}
	if client.manifest != nil {
		reqQP.Set("manifest", *client.manifest)
	}
	if client.scope != nil {
		reqQP.Set("scope", string(*client.scope))
	}
	if client.sortParam != nil {
		reqQP.Set("sort", string(*client.sortParam))
	}
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if options != nil && options.Page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*options.Page), 10))
	}
	if options != nil && options.PerPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*options.PerPage), 10))
	}
	if client.before != nil {
		reqQP.Set("before", *client.before)
	}
	if client.after != nil {
		reqQP.Set("after", *client.after)
	}
	if client.first != nil {
		reqQP.Set("first", strconv.FormatInt(int64(*client.first), 10))
	}
	if client.last != nil {
		reqQP.Set("last", strconv.FormatInt(int64(*client.last), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// dependabotListAlertsForRepoHandleResponse handles the DependabotListAlertsForRepo response.
func (client *GitHubV3RESTAPIClient) dependabotListAlertsForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientDependabotListAlertsForRepoResponse, error) {
	result := GitHubV3RESTAPIClientDependabotListAlertsForRepoResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*DependabotAlert
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotListAlertsForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientDependabotListAlertsForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// DependabotListOrgSecrets - Lists all secrets available in an organization without revealing their encrypted values. You
// must authenticate using an access token with the admin:org scope to use this endpoint. GitHub Apps must
// have the dependabot_secrets organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotListOrgSecretsOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotListOrgSecrets
//     method.
func (client *GitHubV3RESTAPIClient) DependabotListOrgSecrets(ctx context.Context, options *GitHubV3RESTAPIClientDependabotListOrgSecretsOptions) (GitHubV3RESTAPIClientDependabotListOrgSecretsResponse, error) {
	req, err := client.dependabotListOrgSecretsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotListOrgSecretsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotListOrgSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientDependabotListOrgSecretsResponse{}, runtime.NewResponseError(resp)
	}
	return client.dependabotListOrgSecretsHandleResponse(resp)
}

// dependabotListOrgSecretsCreateRequest creates the DependabotListOrgSecrets request.
func (client *GitHubV3RESTAPIClient) dependabotListOrgSecretsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientDependabotListOrgSecretsOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/dependabot/secrets"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// dependabotListOrgSecretsHandleResponse handles the DependabotListOrgSecrets response.
func (client *GitHubV3RESTAPIClient) dependabotListOrgSecretsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientDependabotListOrgSecretsResponse, error) {
	result := GitHubV3RESTAPIClientDependabotListOrgSecretsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsD0PkzvOrgsOrgDependabotSecretsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientDependabotListOrgSecretsResponse{}, err
	}
	return result, nil
}

// DependabotListRepoSecrets - Lists all secrets available in a repository without revealing their encrypted values. You must
// authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the
// dependabot_secrets repository permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotListRepoSecretsOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotListRepoSecrets
//     method.
func (client *GitHubV3RESTAPIClient) DependabotListRepoSecrets(ctx context.Context, options *GitHubV3RESTAPIClientDependabotListRepoSecretsOptions) (GitHubV3RESTAPIClientDependabotListRepoSecretsResponse, error) {
	req, err := client.dependabotListRepoSecretsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotListRepoSecretsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotListRepoSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientDependabotListRepoSecretsResponse{}, runtime.NewResponseError(resp)
	}
	return client.dependabotListRepoSecretsHandleResponse(resp)
}

// dependabotListRepoSecretsCreateRequest creates the DependabotListRepoSecrets request.
func (client *GitHubV3RESTAPIClient) dependabotListRepoSecretsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientDependabotListRepoSecretsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/dependabot/secrets"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// dependabotListRepoSecretsHandleResponse handles the DependabotListRepoSecrets response.
func (client *GitHubV3RESTAPIClient) dependabotListRepoSecretsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientDependabotListRepoSecretsResponse, error) {
	result := GitHubV3RESTAPIClientDependabotListRepoSecretsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsW3Xg7UReposOwnerRepoDependabotSecretsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientDependabotListRepoSecretsResponse{}, err
	}
	return result, nil
}

// DependabotListSelectedReposForOrgSecret - Lists all repositories that have been selected when the visibility for repository
// access to a secret is set to selected. You must authenticate using an access token with the admin:org scope to use
// this endpoint. GitHub Apps must have the dependabot_secrets organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotListSelectedReposForOrgSecretOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.DependabotListSelectedReposForOrgSecret method.
func (client *GitHubV3RESTAPIClient) DependabotListSelectedReposForOrgSecret(ctx context.Context, options *GitHubV3RESTAPIClientDependabotListSelectedReposForOrgSecretOptions) (GitHubV3RESTAPIClientDependabotListSelectedReposForOrgSecretResponse, error) {
	req, err := client.dependabotListSelectedReposForOrgSecretCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotListSelectedReposForOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotListSelectedReposForOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientDependabotListSelectedReposForOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.dependabotListSelectedReposForOrgSecretHandleResponse(resp)
}

// dependabotListSelectedReposForOrgSecretCreateRequest creates the DependabotListSelectedReposForOrgSecret request.
func (client *GitHubV3RESTAPIClient) dependabotListSelectedReposForOrgSecretCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientDependabotListSelectedReposForOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/dependabot/secrets/{secret_name}/repositories"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// dependabotListSelectedReposForOrgSecretHandleResponse handles the DependabotListSelectedReposForOrgSecret response.
func (client *GitHubV3RESTAPIClient) dependabotListSelectedReposForOrgSecretHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientDependabotListSelectedReposForOrgSecretResponse, error) {
	result := GitHubV3RESTAPIClientDependabotListSelectedReposForOrgSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths6Hq2RjOrgsOrgDependabotSecretsSecretNameRepositoriesGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientDependabotListSelectedReposForOrgSecretResponse{}, err
	}
	return result, nil
}

// DependabotRemoveSelectedRepoFromOrgSecret - Removes a repository from an organization secret when the visibility for repository
// access is set to selected. The visibility is set when you Create or update an organization secret
// [https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret]. You must authenticate using
// an access token with the admin:org scope to use this endpoint. GitHub Apps must
// have the dependabot_secrets organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotRemoveSelectedRepoFromOrgSecretOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.DependabotRemoveSelectedRepoFromOrgSecret method.
func (client *GitHubV3RESTAPIClient) DependabotRemoveSelectedRepoFromOrgSecret(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientDependabotRemoveSelectedRepoFromOrgSecretOptions) (GitHubV3RESTAPIClientDependabotRemoveSelectedRepoFromOrgSecretResponse, error) {
	req, err := client.dependabotRemoveSelectedRepoFromOrgSecretCreateRequest(ctx, repositoryID, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotRemoveSelectedRepoFromOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotRemoveSelectedRepoFromOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusConflict) {
		return GitHubV3RESTAPIClientDependabotRemoveSelectedRepoFromOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientDependabotRemoveSelectedRepoFromOrgSecretResponse{}, nil
}

// dependabotRemoveSelectedRepoFromOrgSecretCreateRequest creates the DependabotRemoveSelectedRepoFromOrgSecret request.
func (client *GitHubV3RESTAPIClient) dependabotRemoveSelectedRepoFromOrgSecretCreateRequest(ctx context.Context, repositoryID int32, options *GitHubV3RESTAPIClientDependabotRemoveSelectedRepoFromOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	urlPath = strings.ReplaceAll(urlPath, "{repository_id}", url.PathEscape(strconv.FormatInt(int64(repositoryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// DependabotSetSelectedReposForOrgSecret - Replaces all repositories for an organization secret when the visibility for repository
// access is set to selected. The visibility is set when you Create or update an organization secret
// [https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret]. You must authenticate using
// an access token with the admin:org scope to use this endpoint. GitHub Apps must
// have the dependabot_secrets organization permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotSetSelectedReposForOrgSecretOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotSetSelectedReposForOrgSecret
//     method.
func (client *GitHubV3RESTAPIClient) DependabotSetSelectedReposForOrgSecret(ctx context.Context, body Paths1P6T5UkOrgsOrgDependabotSecretsSecretNameRepositoriesPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientDependabotSetSelectedReposForOrgSecretOptions) (GitHubV3RESTAPIClientDependabotSetSelectedReposForOrgSecretResponse, error) {
	req, err := client.dependabotSetSelectedReposForOrgSecretCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotSetSelectedReposForOrgSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotSetSelectedReposForOrgSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientDependabotSetSelectedReposForOrgSecretResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientDependabotSetSelectedReposForOrgSecretResponse{}, nil
}

// dependabotSetSelectedReposForOrgSecretCreateRequest creates the DependabotSetSelectedReposForOrgSecret request.
func (client *GitHubV3RESTAPIClient) dependabotSetSelectedReposForOrgSecretCreateRequest(ctx context.Context, body Paths1P6T5UkOrgsOrgDependabotSecretsSecretNameRepositoriesPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientDependabotSetSelectedReposForOrgSecretOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/dependabot/secrets/{secret_name}/repositories"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.secretName == "" {
		return nil, errors.New("parameter client.secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret_name}", url.PathEscape(client.secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// DependabotUpdateAlert - You must use an access token with the securityevents scope to use this endpoint with private repositories.
// You can also use tokens with the publicrepo scope for public repositories only. GitHub Apps
// must have Dependabot alerts write permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependabotUpdateAlertOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependabotUpdateAlert
//     method.
func (client *GitHubV3RESTAPIClient) DependabotUpdateAlert(ctx context.Context, body Paths12J662EReposOwnerRepoDependabotAlertsAlertNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientDependabotUpdateAlertOptions) (GitHubV3RESTAPIClientDependabotUpdateAlertResponse, error) {
	req, err := client.dependabotUpdateAlertCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotUpdateAlertResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependabotUpdateAlertResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusForbidden, http.StatusNotFound, http.StatusConflict, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientDependabotUpdateAlertResponse{}, runtime.NewResponseError(resp)
	}
	return client.dependabotUpdateAlertHandleResponse(resp)
}

// dependabotUpdateAlertCreateRequest creates the DependabotUpdateAlert request.
func (client *GitHubV3RESTAPIClient) dependabotUpdateAlertCreateRequest(ctx context.Context, body Paths12J662EReposOwnerRepoDependabotAlertsAlertNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientDependabotUpdateAlertOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{alert_number}", url.PathEscape(strconv.FormatInt(int64(client.alertNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// dependabotUpdateAlertHandleResponse handles the DependabotUpdateAlert response.
func (client *GitHubV3RESTAPIClient) dependabotUpdateAlertHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientDependabotUpdateAlertResponse, error) {
	result := GitHubV3RESTAPIClientDependabotUpdateAlertResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val DependabotAlert
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotUpdateAlertResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotUpdateAlertResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotUpdateAlertResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotUpdateAlertResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotUpdateAlertResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependabotUpdateAlertResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientDependabotUpdateAlertResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// DependencyGraphCreateRepositorySnapshot - Create a new snapshot of a repository's dependencies. You must authenticate using
// an access token with the repo scope to use this endpoint for a repository that the requesting user has access to.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientDependencyGraphCreateRepositorySnapshotOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.DependencyGraphCreateRepositorySnapshot method.
func (client *GitHubV3RESTAPIClient) DependencyGraphCreateRepositorySnapshot(ctx context.Context, body Snapshot, options *GitHubV3RESTAPIClientDependencyGraphCreateRepositorySnapshotOptions) (GitHubV3RESTAPIClientDependencyGraphCreateRepositorySnapshotResponse, error) {
	req, err := client.dependencyGraphCreateRepositorySnapshotCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependencyGraphCreateRepositorySnapshotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependencyGraphCreateRepositorySnapshotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientDependencyGraphCreateRepositorySnapshotResponse{}, runtime.NewResponseError(resp)
	}
	return client.dependencyGraphCreateRepositorySnapshotHandleResponse(resp)
}

// dependencyGraphCreateRepositorySnapshotCreateRequest creates the DependencyGraphCreateRepositorySnapshot request.
func (client *GitHubV3RESTAPIClient) dependencyGraphCreateRepositorySnapshotCreateRequest(ctx context.Context, body Snapshot, options *GitHubV3RESTAPIClientDependencyGraphCreateRepositorySnapshotOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/dependency-graph/snapshots"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// dependencyGraphCreateRepositorySnapshotHandleResponse handles the DependencyGraphCreateRepositorySnapshot response.
func (client *GitHubV3RESTAPIClient) dependencyGraphCreateRepositorySnapshotHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientDependencyGraphCreateRepositorySnapshotResponse, error) {
	result := GitHubV3RESTAPIClientDependencyGraphCreateRepositorySnapshotResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1Ncrc5ZReposOwnerRepoDependencyGraphSnapshotsPostResponses201ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientDependencyGraphCreateRepositorySnapshotResponse{}, err
	}
	return result, nil
}

// DependencyGraphDiffRange - Gets the diff of the dependency changes between two commits of a repository, based on the changes
// to the dependency manifests made in those commits.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - basehead - The base and head Git revisions to compare. The Git revisions will be resolved to commit SHAs. Named revisions
//     will be resolved to their corresponding HEAD commits, and an appropriate merge base will
//     be determined. This parameter expects the format {base}...{head}.
//   - options - GitHubV3RESTAPIClientDependencyGraphDiffRangeOptions contains the optional parameters for the GitHubV3RESTAPIClient.DependencyGraphDiffRange
//     method.
func (client *GitHubV3RESTAPIClient) DependencyGraphDiffRange(ctx context.Context, basehead string, options *GitHubV3RESTAPIClientDependencyGraphDiffRangeOptions) (GitHubV3RESTAPIClientDependencyGraphDiffRangeResponse, error) {
	req, err := client.dependencyGraphDiffRangeCreateRequest(ctx, basehead, options)
	if err != nil {
		return GitHubV3RESTAPIClientDependencyGraphDiffRangeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientDependencyGraphDiffRangeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientDependencyGraphDiffRangeResponse{}, runtime.NewResponseError(resp)
	}
	return client.dependencyGraphDiffRangeHandleResponse(resp)
}

// dependencyGraphDiffRangeCreateRequest creates the DependencyGraphDiffRange request.
func (client *GitHubV3RESTAPIClient) dependencyGraphDiffRangeCreateRequest(ctx context.Context, basehead string, options *GitHubV3RESTAPIClientDependencyGraphDiffRangeOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if basehead == "" {
		return nil, errors.New("parameter basehead cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{basehead}", url.PathEscape(basehead))
	if client.name == "" {
		return nil, errors.New("parameter client.name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(client.name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// dependencyGraphDiffRangeHandleResponse handles the DependencyGraphDiffRange response.
func (client *GitHubV3RESTAPIClient) dependencyGraphDiffRangeHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientDependencyGraphDiffRangeResponse, error) {
	result := GitHubV3RESTAPIClientDependencyGraphDiffRangeResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*DependencyGraphDiffItem
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependencyGraphDiffRangeResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependencyGraphDiffRangeResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientDependencyGraphDiffRangeResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientDependencyGraphDiffRangeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// EmojisGet - Lists all the emojis available to use on GitHub.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientEmojisGetOptions contains the optional parameters for the GitHubV3RESTAPIClient.EmojisGet
//     method.
func (client *GitHubV3RESTAPIClient) EmojisGet(ctx context.Context, options *GitHubV3RESTAPIClientEmojisGetOptions) (GitHubV3RESTAPIClientEmojisGetResponse, error) {
	req, err := client.emojisGetCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientEmojisGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientEmojisGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified) {
		return GitHubV3RESTAPIClientEmojisGetResponse{}, runtime.NewResponseError(resp)
	}
	return client.emojisGetHandleResponse(resp)
}

// emojisGetCreateRequest creates the EmojisGet request.
func (client *GitHubV3RESTAPIClient) emojisGetCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientEmojisGetOptions) (*policy.Request, error) {
	urlPath := "/emojis"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// emojisGetHandleResponse handles the EmojisGet response.
func (client *GitHubV3RESTAPIClient) emojisGetHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientEmojisGetResponse, error) {
	result := GitHubV3RESTAPIClientEmojisGetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return GitHubV3RESTAPIClientEmojisGetResponse{}, err
	}
	return result, nil
}

// GistsCheckIsStarred - Check if a gist is starred
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsCheckIsStarredOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsCheckIsStarred
//     method.
func (client *GitHubV3RESTAPIClient) GistsCheckIsStarred(ctx context.Context, options *GitHubV3RESTAPIClientGistsCheckIsStarredOptions) (GitHubV3RESTAPIClientGistsCheckIsStarredResponse, error) {
	req, err := client.gistsCheckIsStarredCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsCheckIsStarredResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsCheckIsStarredResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientGistsCheckIsStarredResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsCheckIsStarredHandleResponse(resp)
}

// gistsCheckIsStarredCreateRequest creates the GistsCheckIsStarred request.
func (client *GitHubV3RESTAPIClient) gistsCheckIsStarredCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGistsCheckIsStarredOptions) (*policy.Request, error) {
	urlPath := "/gists/{gist_id}/star"
	if client.gistID == "" {
		return nil, errors.New("parameter client.gistID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gist_id}", url.PathEscape(client.gistID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gistsCheckIsStarredHandleResponse handles the GistsCheckIsStarred response.
func (client *GitHubV3RESTAPIClient) gistsCheckIsStarredHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsCheckIsStarredResponse, error) {
	result := GitHubV3RESTAPIClientGistsCheckIsStarredResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsCheckIsStarredResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsCheckIsStarredResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGistsCheckIsStarredResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GistsCreate - Allows you to add a new gist with one or more files.
// Note: Don't name your files "gistfile" with a numerical suffix. This is the format of the automatic naming scheme that
// Gist uses internally.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsCreateOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsCreate
//     method.
func (client *GitHubV3RESTAPIClient) GistsCreate(ctx context.Context, body PathsJgnanxGistsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGistsCreateOptions) (GitHubV3RESTAPIClientGistsCreateResponse, error) {
	req, err := client.gistsCreateCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsCreateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsCreateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientGistsCreateResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsCreateHandleResponse(resp)
}

// gistsCreateCreateRequest creates the GistsCreate request.
func (client *GitHubV3RESTAPIClient) gistsCreateCreateRequest(ctx context.Context, body PathsJgnanxGistsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGistsCreateOptions) (*policy.Request, error) {
	urlPath := "/gists"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// gistsCreateHandleResponse handles the GistsCreate response.
func (client *GitHubV3RESTAPIClient) gistsCreateHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsCreateResponse, error) {
	result := GitHubV3RESTAPIClientGistsCreateResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val GistSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsCreateResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsCreateResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsCreateResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsCreateResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGistsCreateResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GistsCreateComment - Create a gist comment
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsCreateCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsCreateComment
//     method.
func (client *GitHubV3RESTAPIClient) GistsCreateComment(ctx context.Context, body Paths1De6ZrwGistsGistIDCommentsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGistsCreateCommentOptions) (GitHubV3RESTAPIClientGistsCreateCommentResponse, error) {
	req, err := client.gistsCreateCommentCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsCreateCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsCreateCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientGistsCreateCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsCreateCommentHandleResponse(resp)
}

// gistsCreateCommentCreateRequest creates the GistsCreateComment request.
func (client *GitHubV3RESTAPIClient) gistsCreateCommentCreateRequest(ctx context.Context, body Paths1De6ZrwGistsGistIDCommentsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGistsCreateCommentOptions) (*policy.Request, error) {
	urlPath := "/gists/{gist_id}/comments"
	if client.gistID == "" {
		return nil, errors.New("parameter client.gistID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gist_id}", url.PathEscape(client.gistID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// gistsCreateCommentHandleResponse handles the GistsCreateComment response.
func (client *GitHubV3RESTAPIClient) gistsCreateCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsCreateCommentResponse, error) {
	result := GitHubV3RESTAPIClientGistsCreateCommentResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val GistComment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsCreateCommentResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsCreateCommentResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsCreateCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGistsCreateCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GistsDelete - Delete a gist
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsDeleteOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsDelete
//     method.
func (client *GitHubV3RESTAPIClient) GistsDelete(ctx context.Context, options *GitHubV3RESTAPIClientGistsDeleteOptions) (GitHubV3RESTAPIClientGistsDeleteResponse, error) {
	req, err := client.gistsDeleteCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsDeleteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientGistsDeleteResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsDeleteHandleResponse(resp)
}

// gistsDeleteCreateRequest creates the GistsDelete request.
func (client *GitHubV3RESTAPIClient) gistsDeleteCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGistsDeleteOptions) (*policy.Request, error) {
	urlPath := "/gists/{gist_id}"
	if client.gistID == "" {
		return nil, errors.New("parameter client.gistID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gist_id}", url.PathEscape(client.gistID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gistsDeleteHandleResponse handles the GistsDelete response.
func (client *GitHubV3RESTAPIClient) gistsDeleteHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsDeleteResponse, error) {
	result := GitHubV3RESTAPIClientGistsDeleteResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientGistsDeleteResponse{}, err
	}
	return result, nil
}

// GistsDeleteComment - Delete a gist comment
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsDeleteCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsDeleteComment
//     method.
func (client *GitHubV3RESTAPIClient) GistsDeleteComment(ctx context.Context, options *GitHubV3RESTAPIClientGistsDeleteCommentOptions) (GitHubV3RESTAPIClientGistsDeleteCommentResponse, error) {
	req, err := client.gistsDeleteCommentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsDeleteCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsDeleteCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientGistsDeleteCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsDeleteCommentHandleResponse(resp)
}

// gistsDeleteCommentCreateRequest creates the GistsDeleteComment request.
func (client *GitHubV3RESTAPIClient) gistsDeleteCommentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGistsDeleteCommentOptions) (*policy.Request, error) {
	urlPath := "/gists/{gist_id}/comments/{comment_id}"
	if client.gistID == "" {
		return nil, errors.New("parameter client.gistID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gist_id}", url.PathEscape(client.gistID))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gistsDeleteCommentHandleResponse handles the GistsDeleteComment response.
func (client *GitHubV3RESTAPIClient) gistsDeleteCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsDeleteCommentResponse, error) {
	result := GitHubV3RESTAPIClientGistsDeleteCommentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientGistsDeleteCommentResponse{}, err
	}
	return result, nil
}

// GistsFork - Fork a gist
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsForkOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsFork
//     method.
func (client *GitHubV3RESTAPIClient) GistsFork(ctx context.Context, options *GitHubV3RESTAPIClientGistsForkOptions) (GitHubV3RESTAPIClientGistsForkResponse, error) {
	req, err := client.gistsForkCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsForkResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsForkResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientGistsForkResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsForkHandleResponse(resp)
}

// gistsForkCreateRequest creates the GistsFork request.
func (client *GitHubV3RESTAPIClient) gistsForkCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGistsForkOptions) (*policy.Request, error) {
	urlPath := "/gists/{gist_id}/forks"
	if client.gistID == "" {
		return nil, errors.New("parameter client.gistID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gist_id}", url.PathEscape(client.gistID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gistsForkHandleResponse handles the GistsFork response.
func (client *GitHubV3RESTAPIClient) gistsForkHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsForkResponse, error) {
	result := GitHubV3RESTAPIClientGistsForkResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val BaseGist
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsForkResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsForkResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsForkResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsForkResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGistsForkResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GistsGet - Get a gist
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsGetOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsGet
//     method.
func (client *GitHubV3RESTAPIClient) GistsGet(ctx context.Context, options *GitHubV3RESTAPIClientGistsGetOptions) (GitHubV3RESTAPIClientGistsGetResponse, error) {
	req, err := client.gistsGetCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientGistsGetResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsGetHandleResponse(resp)
}

// gistsGetCreateRequest creates the GistsGet request.
func (client *GitHubV3RESTAPIClient) gistsGetCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGistsGetOptions) (*policy.Request, error) {
	urlPath := "/gists/{gist_id}"
	if client.gistID == "" {
		return nil, errors.New("parameter client.gistID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gist_id}", url.PathEscape(client.gistID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gistsGetHandleResponse handles the GistsGet response.
func (client *GitHubV3RESTAPIClient) gistsGetHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsGetResponse, error) {
	result := GitHubV3RESTAPIClientGistsGetResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val GistSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsGetResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val Components16H9WqwResponsesForbiddenGistContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsGetResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsGetResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGistsGetResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GistsGetComment - Get a gist comment
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsGetCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsGetComment
//     method.
func (client *GitHubV3RESTAPIClient) GistsGetComment(ctx context.Context, options *GitHubV3RESTAPIClientGistsGetCommentOptions) (GitHubV3RESTAPIClientGistsGetCommentResponse, error) {
	req, err := client.gistsGetCommentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsGetCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsGetCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientGistsGetCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsGetCommentHandleResponse(resp)
}

// gistsGetCommentCreateRequest creates the GistsGetComment request.
func (client *GitHubV3RESTAPIClient) gistsGetCommentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGistsGetCommentOptions) (*policy.Request, error) {
	urlPath := "/gists/{gist_id}/comments/{comment_id}"
	if client.gistID == "" {
		return nil, errors.New("parameter client.gistID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gist_id}", url.PathEscape(client.gistID))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gistsGetCommentHandleResponse handles the GistsGetComment response.
func (client *GitHubV3RESTAPIClient) gistsGetCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsGetCommentResponse, error) {
	result := GitHubV3RESTAPIClientGistsGetCommentResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val GistComment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsGetCommentResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val Components16H9WqwResponsesForbiddenGistContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsGetCommentResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsGetCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGistsGetCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GistsGetRevision - Get a gist revision
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsGetRevisionOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsGetRevision
//     method.
func (client *GitHubV3RESTAPIClient) GistsGetRevision(ctx context.Context, sha string, options *GitHubV3RESTAPIClientGistsGetRevisionOptions) (GitHubV3RESTAPIClientGistsGetRevisionResponse, error) {
	req, err := client.gistsGetRevisionCreateRequest(ctx, sha, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsGetRevisionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsGetRevisionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientGistsGetRevisionResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsGetRevisionHandleResponse(resp)
}

// gistsGetRevisionCreateRequest creates the GistsGetRevision request.
func (client *GitHubV3RESTAPIClient) gistsGetRevisionCreateRequest(ctx context.Context, sha string, options *GitHubV3RESTAPIClientGistsGetRevisionOptions) (*policy.Request, error) {
	urlPath := "/gists/{gist_id}/{sha}"
	if client.gistID == "" {
		return nil, errors.New("parameter client.gistID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gist_id}", url.PathEscape(client.gistID))
	if sha == "" {
		return nil, errors.New("parameter sha cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sha}", url.PathEscape(sha))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gistsGetRevisionHandleResponse handles the GistsGetRevision response.
func (client *GitHubV3RESTAPIClient) gistsGetRevisionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsGetRevisionResponse, error) {
	result := GitHubV3RESTAPIClientGistsGetRevisionResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val GistSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsGetRevisionResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsGetRevisionResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsGetRevisionResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsGetRevisionResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGistsGetRevisionResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GistsList - Lists the authenticated user's gists or if called anonymously, this endpoint returns all public gists:
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsListOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsList
//     method.
func (client *GitHubV3RESTAPIClient) GistsList(ctx context.Context, options *GitHubV3RESTAPIClientGistsListOptions) (GitHubV3RESTAPIClientGistsListResponse, error) {
	req, err := client.gistsListCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden) {
		return GitHubV3RESTAPIClientGistsListResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsListHandleResponse(resp)
}

// gistsListCreateRequest creates the GistsList request.
func (client *GitHubV3RESTAPIClient) gistsListCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGistsListOptions) (*policy.Request, error) {
	urlPath := "/gists"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gistsListHandleResponse handles the GistsList response.
func (client *GitHubV3RESTAPIClient) gistsListHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsListResponse, error) {
	result := GitHubV3RESTAPIClientGistsListResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*BaseGist
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGistsListResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GistsListComments - List gist comments
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsListCommentsOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsListComments
//     method.
func (client *GitHubV3RESTAPIClient) GistsListComments(ctx context.Context, options *GitHubV3RESTAPIClientGistsListCommentsOptions) (GitHubV3RESTAPIClientGistsListCommentsResponse, error) {
	req, err := client.gistsListCommentsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsListCommentsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsListCommentsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientGistsListCommentsResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsListCommentsHandleResponse(resp)
}

// gistsListCommentsCreateRequest creates the GistsListComments request.
func (client *GitHubV3RESTAPIClient) gistsListCommentsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGistsListCommentsOptions) (*policy.Request, error) {
	urlPath := "/gists/{gist_id}/comments"
	if client.gistID == "" {
		return nil, errors.New("parameter client.gistID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gist_id}", url.PathEscape(client.gistID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gistsListCommentsHandleResponse handles the GistsListComments response.
func (client *GitHubV3RESTAPIClient) gistsListCommentsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsListCommentsResponse, error) {
	result := GitHubV3RESTAPIClientGistsListCommentsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*GistComment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListCommentsResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListCommentsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListCommentsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGistsListCommentsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GistsListCommits - List gist commits
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsListCommitsOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsListCommits
//     method.
func (client *GitHubV3RESTAPIClient) GistsListCommits(ctx context.Context, options *GitHubV3RESTAPIClientGistsListCommitsOptions) (GitHubV3RESTAPIClientGistsListCommitsResponse, error) {
	req, err := client.gistsListCommitsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsListCommitsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsListCommitsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientGistsListCommitsResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsListCommitsHandleResponse(resp)
}

// gistsListCommitsCreateRequest creates the GistsListCommits request.
func (client *GitHubV3RESTAPIClient) gistsListCommitsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGistsListCommitsOptions) (*policy.Request, error) {
	urlPath := "/gists/{gist_id}/commits"
	if client.gistID == "" {
		return nil, errors.New("parameter client.gistID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gist_id}", url.PathEscape(client.gistID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gistsListCommitsHandleResponse handles the GistsListCommits response.
func (client *GitHubV3RESTAPIClient) gistsListCommitsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsListCommitsResponse, error) {
	result := GitHubV3RESTAPIClientGistsListCommitsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*GistCommit
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListCommitsResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListCommitsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListCommitsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGistsListCommitsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GistsListForUser - Lists public gists for the specified user:
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsListForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsListForUser
//     method.
func (client *GitHubV3RESTAPIClient) GistsListForUser(ctx context.Context, options *GitHubV3RESTAPIClientGistsListForUserOptions) (GitHubV3RESTAPIClientGistsListForUserResponse, error) {
	req, err := client.gistsListForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsListForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsListForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientGistsListForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsListForUserHandleResponse(resp)
}

// gistsListForUserCreateRequest creates the GistsListForUser request.
func (client *GitHubV3RESTAPIClient) gistsListForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGistsListForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/gists"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gistsListForUserHandleResponse handles the GistsListForUser response.
func (client *GitHubV3RESTAPIClient) gistsListForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsListForUserResponse, error) {
	result := GitHubV3RESTAPIClientGistsListForUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*BaseGist
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListForUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListForUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGistsListForUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GistsListForks - List gist forks
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsListForksOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsListForks
//     method.
func (client *GitHubV3RESTAPIClient) GistsListForks(ctx context.Context, options *GitHubV3RESTAPIClientGistsListForksOptions) (GitHubV3RESTAPIClientGistsListForksResponse, error) {
	req, err := client.gistsListForksCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsListForksResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsListForksResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientGistsListForksResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsListForksHandleResponse(resp)
}

// gistsListForksCreateRequest creates the GistsListForks request.
func (client *GitHubV3RESTAPIClient) gistsListForksCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGistsListForksOptions) (*policy.Request, error) {
	urlPath := "/gists/{gist_id}/forks"
	if client.gistID == "" {
		return nil, errors.New("parameter client.gistID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gist_id}", url.PathEscape(client.gistID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gistsListForksHandleResponse handles the GistsListForks response.
func (client *GitHubV3RESTAPIClient) gistsListForksHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsListForksResponse, error) {
	result := GitHubV3RESTAPIClientGistsListForksResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*GistSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListForksResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListForksResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListForksResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGistsListForksResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GistsListPublic - List public gists sorted by most recently updated to least recently updated.
// Note: With pagination [https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination], you can fetch up to
// 3000 gists. For example, you can fetch 100 pages with 30 gists per page or 30
// pages with 100 gists per page.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsListPublicOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsListPublic
//     method.
func (client *GitHubV3RESTAPIClient) GistsListPublic(ctx context.Context, options *GitHubV3RESTAPIClientGistsListPublicOptions) (GitHubV3RESTAPIClientGistsListPublicResponse, error) {
	req, err := client.gistsListPublicCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsListPublicResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsListPublicResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientGistsListPublicResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsListPublicHandleResponse(resp)
}

// gistsListPublicCreateRequest creates the GistsListPublic request.
func (client *GitHubV3RESTAPIClient) gistsListPublicCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGistsListPublicOptions) (*policy.Request, error) {
	urlPath := "/gists/public"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gistsListPublicHandleResponse handles the GistsListPublic response.
func (client *GitHubV3RESTAPIClient) gistsListPublicHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsListPublicResponse, error) {
	result := GitHubV3RESTAPIClientGistsListPublicResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*BaseGist
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListPublicResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListPublicResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListPublicResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGistsListPublicResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GistsListStarred - List the authenticated user's starred gists:
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsListStarredOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsListStarred
//     method.
func (client *GitHubV3RESTAPIClient) GistsListStarred(ctx context.Context, options *GitHubV3RESTAPIClientGistsListStarredOptions) (GitHubV3RESTAPIClientGistsListStarredResponse, error) {
	req, err := client.gistsListStarredCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsListStarredResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsListStarredResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientGistsListStarredResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsListStarredHandleResponse(resp)
}

// gistsListStarredCreateRequest creates the GistsListStarred request.
func (client *GitHubV3RESTAPIClient) gistsListStarredCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGistsListStarredOptions) (*policy.Request, error) {
	urlPath := "/gists/starred"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gistsListStarredHandleResponse handles the GistsListStarred response.
func (client *GitHubV3RESTAPIClient) gistsListStarredHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsListStarredResponse, error) {
	result := GitHubV3RESTAPIClientGistsListStarredResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*BaseGist
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListStarredResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListStarredResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsListStarredResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGistsListStarredResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GistsStar - Note that you'll need to set Content-Length to zero when calling out to this endpoint. For more information,
// see "HTTP verbs
// [https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsStarOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsStar
//     method.
func (client *GitHubV3RESTAPIClient) GistsStar(ctx context.Context, options *GitHubV3RESTAPIClientGistsStarOptions) (GitHubV3RESTAPIClientGistsStarResponse, error) {
	req, err := client.gistsStarCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsStarResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsStarResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientGistsStarResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsStarHandleResponse(resp)
}

// gistsStarCreateRequest creates the GistsStar request.
func (client *GitHubV3RESTAPIClient) gistsStarCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGistsStarOptions) (*policy.Request, error) {
	urlPath := "/gists/{gist_id}/star"
	if client.gistID == "" {
		return nil, errors.New("parameter client.gistID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gist_id}", url.PathEscape(client.gistID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gistsStarHandleResponse handles the GistsStar response.
func (client *GitHubV3RESTAPIClient) gistsStarHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsStarResponse, error) {
	result := GitHubV3RESTAPIClientGistsStarResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientGistsStarResponse{}, err
	}
	return result, nil
}

// GistsUnstar - Unstar a gist
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsUnstarOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsUnstar
//     method.
func (client *GitHubV3RESTAPIClient) GistsUnstar(ctx context.Context, options *GitHubV3RESTAPIClientGistsUnstarOptions) (GitHubV3RESTAPIClientGistsUnstarResponse, error) {
	req, err := client.gistsUnstarCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsUnstarResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsUnstarResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientGistsUnstarResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsUnstarHandleResponse(resp)
}

// gistsUnstarCreateRequest creates the GistsUnstar request.
func (client *GitHubV3RESTAPIClient) gistsUnstarCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGistsUnstarOptions) (*policy.Request, error) {
	urlPath := "/gists/{gist_id}/star"
	if client.gistID == "" {
		return nil, errors.New("parameter client.gistID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gist_id}", url.PathEscape(client.gistID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gistsUnstarHandleResponse handles the GistsUnstar response.
func (client *GitHubV3RESTAPIClient) gistsUnstarHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsUnstarResponse, error) {
	result := GitHubV3RESTAPIClientGistsUnstarResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientGistsUnstarResponse{}, err
	}
	return result, nil
}

// GistsUpdate - Allows you to update a gist's description and to update, delete, or rename gist files. Files from the previous
// version of the gist that aren't explicitly changed during an edit are unchanged.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsUpdateOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsUpdate
//     method.
func (client *GitHubV3RESTAPIClient) GistsUpdate(ctx context.Context, body PathsK7L5CGistsGistIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGistsUpdateOptions) (GitHubV3RESTAPIClientGistsUpdateResponse, error) {
	req, err := client.gistsUpdateCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientGistsUpdateResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsUpdateHandleResponse(resp)
}

// gistsUpdateCreateRequest creates the GistsUpdate request.
func (client *GitHubV3RESTAPIClient) gistsUpdateCreateRequest(ctx context.Context, body PathsK7L5CGistsGistIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGistsUpdateOptions) (*policy.Request, error) {
	urlPath := "/gists/{gist_id}"
	if client.gistID == "" {
		return nil, errors.New("parameter client.gistID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gist_id}", url.PathEscape(client.gistID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// gistsUpdateHandleResponse handles the GistsUpdate response.
func (client *GitHubV3RESTAPIClient) gistsUpdateHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsUpdateResponse, error) {
	result := GitHubV3RESTAPIClientGistsUpdateResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val GistSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsUpdateResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGistsUpdateResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GistsUpdateComment - Update a gist comment
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGistsUpdateCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.GistsUpdateComment
//     method.
func (client *GitHubV3RESTAPIClient) GistsUpdateComment(ctx context.Context, body Paths1Uhydg4GistsGistIDCommentsCommentIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGistsUpdateCommentOptions) (GitHubV3RESTAPIClientGistsUpdateCommentResponse, error) {
	req, err := client.gistsUpdateCommentCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientGistsUpdateCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGistsUpdateCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientGistsUpdateCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.gistsUpdateCommentHandleResponse(resp)
}

// gistsUpdateCommentCreateRequest creates the GistsUpdateComment request.
func (client *GitHubV3RESTAPIClient) gistsUpdateCommentCreateRequest(ctx context.Context, body Paths1Uhydg4GistsGistIDCommentsCommentIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGistsUpdateCommentOptions) (*policy.Request, error) {
	urlPath := "/gists/{gist_id}/comments/{comment_id}"
	if client.gistID == "" {
		return nil, errors.New("parameter client.gistID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gist_id}", url.PathEscape(client.gistID))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// gistsUpdateCommentHandleResponse handles the GistsUpdateComment response.
func (client *GitHubV3RESTAPIClient) gistsUpdateCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGistsUpdateCommentResponse, error) {
	result := GitHubV3RESTAPIClientGistsUpdateCommentResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val GistComment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsUpdateCommentResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGistsUpdateCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGistsUpdateCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GitCreateBlob - Create a blob
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGitCreateBlobOptions contains the optional parameters for the GitHubV3RESTAPIClient.GitCreateBlob
//     method.
func (client *GitHubV3RESTAPIClient) GitCreateBlob(ctx context.Context, body PathsTxj2SfReposOwnerRepoGitBlobsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGitCreateBlobOptions) (GitHubV3RESTAPIClientGitCreateBlobResponse, error) {
	req, err := client.gitCreateBlobCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientGitCreateBlobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGitCreateBlobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden, http.StatusNotFound, http.StatusConflict, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientGitCreateBlobResponse{}, runtime.NewResponseError(resp)
	}
	return client.gitCreateBlobHandleResponse(resp)
}

// gitCreateBlobCreateRequest creates the GitCreateBlob request.
func (client *GitHubV3RESTAPIClient) gitCreateBlobCreateRequest(ctx context.Context, body PathsTxj2SfReposOwnerRepoGitBlobsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGitCreateBlobOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/git/blobs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// gitCreateBlobHandleResponse handles the GitCreateBlob response.
func (client *GitHubV3RESTAPIClient) gitCreateBlobHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGitCreateBlobResponse, error) {
	result := GitHubV3RESTAPIClientGitCreateBlobResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val ShortBlob
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitCreateBlobResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitCreateBlobResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitCreateBlobResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitCreateBlobResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitCreateBlobResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGitCreateBlobResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GitCreateCommit - Creates a new Git commit object [https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects].
// Signature verification object
// The response will include a verification object that describes the result of verifying the commit's signature. The following
// fields are included in the verification object:
// NAME TYPE DESCRIPTION
// verified boolean Indicates whether GitHub considers the signature in this commit to be verified.
// reason string The reason for verified value. Possible values and their meanings are enumerated in the table below.
// signature string The signature that was extracted from the commit.
// payload string The value that was signed.
// These are the possible values for reason in the verification object:
// VALUE DESCRIPTION
// expiredkey The key that made the signature is expired. notsigningkey The "signing" flag is not among the usage flags in
// the GPG key that made the signature. gpgverifyerror There was an error
// communicating with the signature verification service.
// gpgverifyunavailable The signature verification service is currently unavailable. unsigned The object does not include
// a signature. unknownsignaturetype A non-PGP signature was found in the commit. no
// user No user was associated with the committer email address in the commit.
// unverifiedemail The committer email address in the commit was associated with a user, but the email address is not verified
// on her/his account. bademail The committer email address in the commit is
// not included in the identities of the PGP key that made the signature.
// unknownkey The key that made the signature has not been registered with any user's account. malformedsignature There was
// an error parsing the signature.
// invalid The signature could not be cryptographically verified using the key whose key-id was found in the signature.
// valid None of the above errors applied, so the signature is considered to be verified.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGitCreateCommitOptions contains the optional parameters for the GitHubV3RESTAPIClient.GitCreateCommit
//     method.
func (client *GitHubV3RESTAPIClient) GitCreateCommit(ctx context.Context, body PathsY78IinReposOwnerRepoGitCommitsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGitCreateCommitOptions) (GitHubV3RESTAPIClientGitCreateCommitResponse, error) {
	req, err := client.gitCreateCommitCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientGitCreateCommitResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGitCreateCommitResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientGitCreateCommitResponse{}, runtime.NewResponseError(resp)
	}
	return client.gitCreateCommitHandleResponse(resp)
}

// gitCreateCommitCreateRequest creates the GitCreateCommit request.
func (client *GitHubV3RESTAPIClient) gitCreateCommitCreateRequest(ctx context.Context, body PathsY78IinReposOwnerRepoGitCommitsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGitCreateCommitOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/git/commits"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// gitCreateCommitHandleResponse handles the GitCreateCommit response.
func (client *GitHubV3RESTAPIClient) gitCreateCommitHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGitCreateCommitResponse, error) {
	result := GitHubV3RESTAPIClientGitCreateCommitResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val GitCommit
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitCreateCommitResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitCreateCommitResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitCreateCommitResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGitCreateCommitResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GitCreateRef - Creates a reference for your repository. You are unable to create new references for empty repositories,
// even if the commit SHA-1 hash used exists. Empty repositories are repositories without
// branches.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGitCreateRefOptions contains the optional parameters for the GitHubV3RESTAPIClient.GitCreateRef
//     method.
func (client *GitHubV3RESTAPIClient) GitCreateRef(ctx context.Context, body Paths12Md2AvReposOwnerRepoGitRefsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGitCreateRefOptions) (GitHubV3RESTAPIClientGitCreateRefResponse, error) {
	req, err := client.gitCreateRefCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientGitCreateRefResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGitCreateRefResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientGitCreateRefResponse{}, runtime.NewResponseError(resp)
	}
	return client.gitCreateRefHandleResponse(resp)
}

// gitCreateRefCreateRequest creates the GitCreateRef request.
func (client *GitHubV3RESTAPIClient) gitCreateRefCreateRequest(ctx context.Context, body Paths12Md2AvReposOwnerRepoGitRefsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGitCreateRefOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/git/refs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// gitCreateRefHandleResponse handles the GitCreateRef response.
func (client *GitHubV3RESTAPIClient) gitCreateRefHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGitCreateRefResponse, error) {
	result := GitHubV3RESTAPIClientGitCreateRefResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val GitRef
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitCreateRefResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitCreateRefResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGitCreateRefResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GitCreateTag - Note that creating a tag object does not create the reference that makes a tag in Git. If you want to create
// an annotated tag in Git, you have to do this call to create the tag object, and then create
// [https://docs.github.com/rest/reference/git#create-a-reference] the refs/tags/[tag] reference. If you want to create a
// lightweight tag, you only have to create
// [https://docs.github.com/rest/reference/git#create-a-reference] the tag reference - this call would be unnecessary.
// Signature verification object
// The response will include a verification object that describes the result of verifying the commit's signature. The following
// fields are included in the verification object:
// NAME TYPE DESCRIPTION
// verified boolean Indicates whether GitHub considers the signature in this commit to be verified.
// reason string The reason for verified value. Possible values and their meanings are enumerated in table below.
// signature string The signature that was extracted from the commit.
// payload string The value that was signed.
// These are the possible values for reason in the verification object:
// VALUE DESCRIPTION
// expiredkey The key that made the signature is expired. notsigningkey The "signing" flag is not among the usage flags in
// the GPG key that made the signature. gpgverifyerror There was an error
// communicating with the signature verification service.
// gpgverifyunavailable The signature verification service is currently unavailable. unsigned The object does not include
// a signature. unknownsignaturetype A non-PGP signature was found in the commit. no
// user No user was associated with the committer email address in the commit.
// unverifiedemail The committer email address in the commit was associated with a user, but the email address is not verified
// on her/his account. bademail The committer email address in the commit is
// not included in the identities of the PGP key that made the signature.
// unknownkey The key that made the signature has not been registered with any user's account. malformedsignature There was
// an error parsing the signature.
// invalid The signature could not be cryptographically verified using the key whose key-id was found in the signature.
// valid None of the above errors applied, so the signature is considered to be verified.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGitCreateTagOptions contains the optional parameters for the GitHubV3RESTAPIClient.GitCreateTag
//     method.
func (client *GitHubV3RESTAPIClient) GitCreateTag(ctx context.Context, body Paths14S7BrqReposOwnerRepoGitTagsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGitCreateTagOptions) (GitHubV3RESTAPIClientGitCreateTagResponse, error) {
	req, err := client.gitCreateTagCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientGitCreateTagResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGitCreateTagResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientGitCreateTagResponse{}, runtime.NewResponseError(resp)
	}
	return client.gitCreateTagHandleResponse(resp)
}

// gitCreateTagCreateRequest creates the GitCreateTag request.
func (client *GitHubV3RESTAPIClient) gitCreateTagCreateRequest(ctx context.Context, body Paths14S7BrqReposOwnerRepoGitTagsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGitCreateTagOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/git/tags"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// gitCreateTagHandleResponse handles the GitCreateTag response.
func (client *GitHubV3RESTAPIClient) gitCreateTagHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGitCreateTagResponse, error) {
	result := GitHubV3RESTAPIClientGitCreateTagResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val GitTag
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitCreateTagResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitCreateTagResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGitCreateTagResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GitCreateTree - The tree creation API accepts nested entries. If you specify both a tree and a nested path modifying that
// tree, this endpoint will overwrite the contents of the tree with the new path contents, and
// create a new tree structure.
// If you use this endpoint to add, delete, or modify the file contents in a tree, you will need to commit the tree and then
// update a branch to point to the commit. For more information see "Create a
// commit [https://docs.github.com/rest/reference/git#create-a-commit]" and "Update a reference [https://docs.github.com/rest/reference/git#update-a-reference]."
// Returns an error if you try to delete a file that does not exist.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGitCreateTreeOptions contains the optional parameters for the GitHubV3RESTAPIClient.GitCreateTree
//     method.
func (client *GitHubV3RESTAPIClient) GitCreateTree(ctx context.Context, body Paths105XfxzReposOwnerRepoGitTreesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGitCreateTreeOptions) (GitHubV3RESTAPIClientGitCreateTreeResponse, error) {
	req, err := client.gitCreateTreeCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientGitCreateTreeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGitCreateTreeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientGitCreateTreeResponse{}, runtime.NewResponseError(resp)
	}
	return client.gitCreateTreeHandleResponse(resp)
}

// gitCreateTreeCreateRequest creates the GitCreateTree request.
func (client *GitHubV3RESTAPIClient) gitCreateTreeCreateRequest(ctx context.Context, body Paths105XfxzReposOwnerRepoGitTreesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGitCreateTreeOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/git/trees"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// gitCreateTreeHandleResponse handles the GitCreateTree response.
func (client *GitHubV3RESTAPIClient) gitCreateTreeHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGitCreateTreeResponse, error) {
	result := GitHubV3RESTAPIClientGitCreateTreeResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val GitTree
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitCreateTreeResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitCreateTreeResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitCreateTreeResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitCreateTreeResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGitCreateTreeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GitDeleteRef - Delete a reference
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - ref - ref parameter
//   - options - GitHubV3RESTAPIClientGitDeleteRefOptions contains the optional parameters for the GitHubV3RESTAPIClient.GitDeleteRef
//     method.
func (client *GitHubV3RESTAPIClient) GitDeleteRef(ctx context.Context, ref string, options *GitHubV3RESTAPIClientGitDeleteRefOptions) (GitHubV3RESTAPIClientGitDeleteRefResponse, error) {
	req, err := client.gitDeleteRefCreateRequest(ctx, ref, options)
	if err != nil {
		return GitHubV3RESTAPIClientGitDeleteRefResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGitDeleteRefResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientGitDeleteRefResponse{}, runtime.NewResponseError(resp)
	}
	return client.gitDeleteRefHandleResponse(resp)
}

// gitDeleteRefCreateRequest creates the GitDeleteRef request.
func (client *GitHubV3RESTAPIClient) gitDeleteRefCreateRequest(ctx context.Context, ref string, options *GitHubV3RESTAPIClientGitDeleteRefOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/git/refs/{ref}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if ref == "" {
		return nil, errors.New("parameter ref cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{ref}", url.PathEscape(ref))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gitDeleteRefHandleResponse handles the GitDeleteRef response.
func (client *GitHubV3RESTAPIClient) gitDeleteRefHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGitDeleteRefResponse, error) {
	result := GitHubV3RESTAPIClientGitDeleteRefResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ValidationError); err != nil {
		return GitHubV3RESTAPIClientGitDeleteRefResponse{}, err
	}
	return result, nil
}

// GitGetBlob - The content in the response will always be Base64 encoded.
// Note: This API supports blobs up to 100 megabytes in size.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGitGetBlobOptions contains the optional parameters for the GitHubV3RESTAPIClient.GitGetBlob
//     method.
func (client *GitHubV3RESTAPIClient) GitGetBlob(ctx context.Context, fileSHA string, options *GitHubV3RESTAPIClientGitGetBlobOptions) (GitHubV3RESTAPIClientGitGetBlobResponse, error) {
	req, err := client.gitGetBlobCreateRequest(ctx, fileSHA, options)
	if err != nil {
		return GitHubV3RESTAPIClientGitGetBlobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGitGetBlobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientGitGetBlobResponse{}, runtime.NewResponseError(resp)
	}
	return client.gitGetBlobHandleResponse(resp)
}

// gitGetBlobCreateRequest creates the GitGetBlob request.
func (client *GitHubV3RESTAPIClient) gitGetBlobCreateRequest(ctx context.Context, fileSHA string, options *GitHubV3RESTAPIClientGitGetBlobOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/git/blobs/{file_sha}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if fileSHA == "" {
		return nil, errors.New("parameter fileSHA cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{file_sha}", url.PathEscape(fileSHA))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gitGetBlobHandleResponse handles the GitGetBlob response.
func (client *GitHubV3RESTAPIClient) gitGetBlobHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGitGetBlobResponse, error) {
	result := GitHubV3RESTAPIClientGitGetBlobResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Blob
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitGetBlobResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitGetBlobResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitGetBlobResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitGetBlobResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGitGetBlobResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GitGetCommit - Gets a Git commit object [https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects].
// Signature verification object
// The response will include a verification object that describes the result of verifying the commit's signature. The following
// fields are included in the verification object:
// NAME TYPE DESCRIPTION
// verified boolean Indicates whether GitHub considers the signature in this commit to be verified.
// reason string The reason for verified value. Possible values and their meanings are enumerated in the table below.
// signature string The signature that was extracted from the commit.
// payload string The value that was signed.
// These are the possible values for reason in the verification object:
// VALUE DESCRIPTION
// expiredkey The key that made the signature is expired. notsigningkey The "signing" flag is not among the usage flags in
// the GPG key that made the signature. gpgverifyerror There was an error
// communicating with the signature verification service.
// gpgverifyunavailable The signature verification service is currently unavailable. unsigned The object does not include
// a signature. unknownsignaturetype A non-PGP signature was found in the commit. no
// user No user was associated with the committer email address in the commit.
// unverifiedemail The committer email address in the commit was associated with a user, but the email address is not verified
// on her/his account. bademail The committer email address in the commit is
// not included in the identities of the PGP key that made the signature.
// unknownkey The key that made the signature has not been registered with any user's account. malformedsignature There was
// an error parsing the signature.
// invalid The signature could not be cryptographically verified using the key whose key-id was found in the signature.
// valid None of the above errors applied, so the signature is considered to be verified.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGitGetCommitOptions contains the optional parameters for the GitHubV3RESTAPIClient.GitGetCommit
//     method.
func (client *GitHubV3RESTAPIClient) GitGetCommit(ctx context.Context, options *GitHubV3RESTAPIClientGitGetCommitOptions) (GitHubV3RESTAPIClientGitGetCommitResponse, error) {
	req, err := client.gitGetCommitCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGitGetCommitResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGitGetCommitResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientGitGetCommitResponse{}, runtime.NewResponseError(resp)
	}
	return client.gitGetCommitHandleResponse(resp)
}

// gitGetCommitCreateRequest creates the GitGetCommit request.
func (client *GitHubV3RESTAPIClient) gitGetCommitCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGitGetCommitOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/git/commits/{commit_sha}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.commitSHA == "" {
		return nil, errors.New("parameter client.commitSHA cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{commit_sha}", url.PathEscape(client.commitSHA))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gitGetCommitHandleResponse handles the GitGetCommit response.
func (client *GitHubV3RESTAPIClient) gitGetCommitHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGitGetCommitResponse, error) {
	result := GitHubV3RESTAPIClientGitGetCommitResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val GitCommit
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitGetCommitResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitGetCommitResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGitGetCommitResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GitGetRef - Returns a single reference from your Git database. The :ref in the URL must be formatted as heads/ for branches
// and tags/ for tags. If the :ref doesn't match an existing ref, a 404 is returned.
// Note: You need to explicitly request a pull request [https://docs.github.com/rest/reference/pulls#get-a-pull-request] to
// trigger a test merge commit, which checks the mergeability of pull requests.
// For more information, see "Checking mergeability of pull requests [https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests]".
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - ref - ref parameter
//   - options - GitHubV3RESTAPIClientGitGetRefOptions contains the optional parameters for the GitHubV3RESTAPIClient.GitGetRef
//     method.
func (client *GitHubV3RESTAPIClient) GitGetRef(ctx context.Context, ref string, options *GitHubV3RESTAPIClientGitGetRefOptions) (GitHubV3RESTAPIClientGitGetRefResponse, error) {
	req, err := client.gitGetRefCreateRequest(ctx, ref, options)
	if err != nil {
		return GitHubV3RESTAPIClientGitGetRefResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGitGetRefResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientGitGetRefResponse{}, runtime.NewResponseError(resp)
	}
	return client.gitGetRefHandleResponse(resp)
}

// gitGetRefCreateRequest creates the GitGetRef request.
func (client *GitHubV3RESTAPIClient) gitGetRefCreateRequest(ctx context.Context, ref string, options *GitHubV3RESTAPIClientGitGetRefOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/git/ref/{ref}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if ref == "" {
		return nil, errors.New("parameter ref cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{ref}", url.PathEscape(ref))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gitGetRefHandleResponse handles the GitGetRef response.
func (client *GitHubV3RESTAPIClient) gitGetRefHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGitGetRefResponse, error) {
	result := GitHubV3RESTAPIClientGitGetRefResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val GitRef
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitGetRefResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitGetRefResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGitGetRefResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GitGetTag - Signature verification object
// The response will include a verification object that describes the result of verifying the commit's signature. The following
// fields are included in the verification object:
// NAME TYPE DESCRIPTION
// verified boolean Indicates whether GitHub considers the signature in this commit to be verified.
// reason string The reason for verified value. Possible values and their meanings are enumerated in table below.
// signature string The signature that was extracted from the commit.
// payload string The value that was signed.
// These are the possible values for reason in the verification object:
// VALUE DESCRIPTION
// expiredkey The key that made the signature is expired. notsigningkey The "signing" flag is not among the usage flags in
// the GPG key that made the signature. gpgverifyerror There was an error
// communicating with the signature verification service.
// gpgverifyunavailable The signature verification service is currently unavailable. unsigned The object does not include
// a signature. unknownsignaturetype A non-PGP signature was found in the commit. no
// user No user was associated with the committer email address in the commit.
// unverifiedemail The committer email address in the commit was associated with a user, but the email address is not verified
// on her/his account. bademail The committer email address in the commit is
// not included in the identities of the PGP key that made the signature.
// unknownkey The key that made the signature has not been registered with any user's account. malformedsignature There was
// an error parsing the signature.
// invalid The signature could not be cryptographically verified using the key whose key-id was found in the signature.
// valid None of the above errors applied, so the signature is considered to be verified.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGitGetTagOptions contains the optional parameters for the GitHubV3RESTAPIClient.GitGetTag
//     method.
func (client *GitHubV3RESTAPIClient) GitGetTag(ctx context.Context, tagSHA string, options *GitHubV3RESTAPIClientGitGetTagOptions) (GitHubV3RESTAPIClientGitGetTagResponse, error) {
	req, err := client.gitGetTagCreateRequest(ctx, tagSHA, options)
	if err != nil {
		return GitHubV3RESTAPIClientGitGetTagResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGitGetTagResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientGitGetTagResponse{}, runtime.NewResponseError(resp)
	}
	return client.gitGetTagHandleResponse(resp)
}

// gitGetTagCreateRequest creates the GitGetTag request.
func (client *GitHubV3RESTAPIClient) gitGetTagCreateRequest(ctx context.Context, tagSHA string, options *GitHubV3RESTAPIClientGitGetTagOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/git/tags/{tag_sha}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if tagSHA == "" {
		return nil, errors.New("parameter tagSHA cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{tag_sha}", url.PathEscape(tagSHA))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gitGetTagHandleResponse handles the GitGetTag response.
func (client *GitHubV3RESTAPIClient) gitGetTagHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGitGetTagResponse, error) {
	result := GitHubV3RESTAPIClientGitGetTagResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val GitTag
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitGetTagResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitGetTagResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGitGetTagResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GitGetTree - Returns a single tree using the SHA1 value for that tree.
// If truncated is true in the response then the number of items in the tree array exceeded our maximum limit. If you need
// to fetch more items, use the non-recursive method of fetching trees, and fetch
// one sub-tree at a time.
// Note: The limit for the tree array is 100,000 entries with a maximum size of 7 MB when using the recursive parameter.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGitGetTreeOptions contains the optional parameters for the GitHubV3RESTAPIClient.GitGetTree
//     method.
func (client *GitHubV3RESTAPIClient) GitGetTree(ctx context.Context, treeSHA string, options *GitHubV3RESTAPIClientGitGetTreeOptions) (GitHubV3RESTAPIClientGitGetTreeResponse, error) {
	req, err := client.gitGetTreeCreateRequest(ctx, treeSHA, options)
	if err != nil {
		return GitHubV3RESTAPIClientGitGetTreeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGitGetTreeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientGitGetTreeResponse{}, runtime.NewResponseError(resp)
	}
	return client.gitGetTreeHandleResponse(resp)
}

// gitGetTreeCreateRequest creates the GitGetTree request.
func (client *GitHubV3RESTAPIClient) gitGetTreeCreateRequest(ctx context.Context, treeSHA string, options *GitHubV3RESTAPIClientGitGetTreeOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/git/trees/{tree_sha}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if treeSHA == "" {
		return nil, errors.New("parameter treeSHA cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{tree_sha}", url.PathEscape(treeSHA))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Recursive != nil {
		reqQP.Set("recursive", *options.Recursive)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gitGetTreeHandleResponse handles the GitGetTree response.
func (client *GitHubV3RESTAPIClient) gitGetTreeHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGitGetTreeResponse, error) {
	result := GitHubV3RESTAPIClientGitGetTreeResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val GitTree
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitGetTreeResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitGetTreeResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitGetTreeResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGitGetTreeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GitListMatchingRefs - Returns an array of references from your Git database that match the supplied name. The :ref in the
// URL must be formatted as heads/ for branches and tags/ for tags. If the :ref doesn't exist in the
// repository, but existing refs start with :ref, they will be returned as an array.
// When you use this endpoint without providing a :ref, it will return an array of all the references from your Git database,
// including notes and stashes if they exist on the server. Anything in the
// namespace is returned, not just heads and tags.
// Note: You need to explicitly request a pull request [https://docs.github.com/rest/reference/pulls#get-a-pull-request] to
// trigger a test merge commit, which checks the mergeability of pull requests.
// For more information, see "Checking mergeability of pull requests [https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests]".
// If you request matching references for a branch named feature but the branch feature doesn't exist, the response can still
// include other matching head refs that start with the word feature, such as
// featureA and featureB.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - ref - ref parameter
//   - options - GitHubV3RESTAPIClientGitListMatchingRefsOptions contains the optional parameters for the GitHubV3RESTAPIClient.GitListMatchingRefs
//     method.
func (client *GitHubV3RESTAPIClient) GitListMatchingRefs(ctx context.Context, ref string, options *GitHubV3RESTAPIClientGitListMatchingRefsOptions) (GitHubV3RESTAPIClientGitListMatchingRefsResponse, error) {
	req, err := client.gitListMatchingRefsCreateRequest(ctx, ref, options)
	if err != nil {
		return GitHubV3RESTAPIClientGitListMatchingRefsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGitListMatchingRefsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientGitListMatchingRefsResponse{}, runtime.NewResponseError(resp)
	}
	return client.gitListMatchingRefsHandleResponse(resp)
}

// gitListMatchingRefsCreateRequest creates the GitListMatchingRefs request.
func (client *GitHubV3RESTAPIClient) gitListMatchingRefsCreateRequest(ctx context.Context, ref string, options *GitHubV3RESTAPIClientGitListMatchingRefsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/git/matching-refs/{ref}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if ref == "" {
		return nil, errors.New("parameter ref cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{ref}", url.PathEscape(ref))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gitListMatchingRefsHandleResponse handles the GitListMatchingRefs response.
func (client *GitHubV3RESTAPIClient) gitListMatchingRefsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGitListMatchingRefsResponse, error) {
	result := GitHubV3RESTAPIClientGitListMatchingRefsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.GitRefArray); err != nil {
		return GitHubV3RESTAPIClientGitListMatchingRefsResponse{}, err
	}
	return result, nil
}

// GitUpdateRef - Update a reference
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - ref - The name of the fully qualified reference to update. For example, refs/heads/master. If the value doesn't start with
//     refs and have at least two slashes, it will be rejected.
//   - options - GitHubV3RESTAPIClientGitUpdateRefOptions contains the optional parameters for the GitHubV3RESTAPIClient.GitUpdateRef
//     method.
func (client *GitHubV3RESTAPIClient) GitUpdateRef(ctx context.Context, ref string, body PathsUh4T4SReposOwnerRepoGitRefsRefPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGitUpdateRefOptions) (GitHubV3RESTAPIClientGitUpdateRefResponse, error) {
	req, err := client.gitUpdateRefCreateRequest(ctx, ref, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientGitUpdateRefResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGitUpdateRefResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientGitUpdateRefResponse{}, runtime.NewResponseError(resp)
	}
	return client.gitUpdateRefHandleResponse(resp)
}

// gitUpdateRefCreateRequest creates the GitUpdateRef request.
func (client *GitHubV3RESTAPIClient) gitUpdateRefCreateRequest(ctx context.Context, ref string, body PathsUh4T4SReposOwnerRepoGitRefsRefPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientGitUpdateRefOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/git/refs/{ref}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if ref == "" {
		return nil, errors.New("parameter ref cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{ref}", url.PathEscape(ref))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// gitUpdateRefHandleResponse handles the GitUpdateRef response.
func (client *GitHubV3RESTAPIClient) gitUpdateRefHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGitUpdateRefResponse, error) {
	result := GitHubV3RESTAPIClientGitUpdateRefResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val GitRef
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitUpdateRefResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientGitUpdateRefResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientGitUpdateRefResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GitignoreGetAllTemplates - List all templates available to pass as an option when creating a repository [https://docs.github.com/rest/reference/repos#create-a-repository-for-the-authenticated-user].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGitignoreGetAllTemplatesOptions contains the optional parameters for the GitHubV3RESTAPIClient.GitignoreGetAllTemplates
//     method.
func (client *GitHubV3RESTAPIClient) GitignoreGetAllTemplates(ctx context.Context, options *GitHubV3RESTAPIClientGitignoreGetAllTemplatesOptions) (GitHubV3RESTAPIClientGitignoreGetAllTemplatesResponse, error) {
	req, err := client.gitignoreGetAllTemplatesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientGitignoreGetAllTemplatesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGitignoreGetAllTemplatesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified) {
		return GitHubV3RESTAPIClientGitignoreGetAllTemplatesResponse{}, runtime.NewResponseError(resp)
	}
	return client.gitignoreGetAllTemplatesHandleResponse(resp)
}

// gitignoreGetAllTemplatesCreateRequest creates the GitignoreGetAllTemplates request.
func (client *GitHubV3RESTAPIClient) gitignoreGetAllTemplatesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientGitignoreGetAllTemplatesOptions) (*policy.Request, error) {
	urlPath := "/gitignore/templates"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gitignoreGetAllTemplatesHandleResponse handles the GitignoreGetAllTemplates response.
func (client *GitHubV3RESTAPIClient) gitignoreGetAllTemplatesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGitignoreGetAllTemplatesResponse, error) {
	result := GitHubV3RESTAPIClientGitignoreGetAllTemplatesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringArray); err != nil {
		return GitHubV3RESTAPIClientGitignoreGetAllTemplatesResponse{}, err
	}
	return result, nil
}

// GitignoreGetTemplate - The API also allows fetching the source of a single template. Use the raw media type [https://docs.github.com/rest/overview/media-types/]
// to get the raw contents.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientGitignoreGetTemplateOptions contains the optional parameters for the GitHubV3RESTAPIClient.GitignoreGetTemplate
//     method.
func (client *GitHubV3RESTAPIClient) GitignoreGetTemplate(ctx context.Context, name string, options *GitHubV3RESTAPIClientGitignoreGetTemplateOptions) (GitHubV3RESTAPIClientGitignoreGetTemplateResponse, error) {
	req, err := client.gitignoreGetTemplateCreateRequest(ctx, name, options)
	if err != nil {
		return GitHubV3RESTAPIClientGitignoreGetTemplateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientGitignoreGetTemplateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified) {
		return GitHubV3RESTAPIClientGitignoreGetTemplateResponse{}, runtime.NewResponseError(resp)
	}
	return client.gitignoreGetTemplateHandleResponse(resp)
}

// gitignoreGetTemplateCreateRequest creates the GitignoreGetTemplate request.
func (client *GitHubV3RESTAPIClient) gitignoreGetTemplateCreateRequest(ctx context.Context, name string, options *GitHubV3RESTAPIClientGitignoreGetTemplateOptions) (*policy.Request, error) {
	urlPath := "/gitignore/templates/{name}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// gitignoreGetTemplateHandleResponse handles the GitignoreGetTemplate response.
func (client *GitHubV3RESTAPIClient) gitignoreGetTemplateHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientGitignoreGetTemplateResponse, error) {
	result := GitHubV3RESTAPIClientGitignoreGetTemplateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.GitignoreTemplate); err != nil {
		return GitHubV3RESTAPIClientGitignoreGetTemplateResponse{}, err
	}
	return result, nil
}

// InteractionsGetRestrictionsForAuthenticatedUser - Shows which type of GitHub user can interact with your public repositories
// and when the restriction expires.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientInteractionsGetRestrictionsForAuthenticatedUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.InteractionsGetRestrictionsForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) InteractionsGetRestrictionsForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientInteractionsGetRestrictionsForAuthenticatedUserOptions) (GitHubV3RESTAPIClientInteractionsGetRestrictionsForAuthenticatedUserResponse, error) {
	req, err := client.interactionsGetRestrictionsForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsGetRestrictionsForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsGetRestrictionsForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return GitHubV3RESTAPIClientInteractionsGetRestrictionsForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.interactionsGetRestrictionsForAuthenticatedUserHandleResponse(resp)
}

// interactionsGetRestrictionsForAuthenticatedUserCreateRequest creates the InteractionsGetRestrictionsForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) interactionsGetRestrictionsForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientInteractionsGetRestrictionsForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/interaction-limits"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// interactionsGetRestrictionsForAuthenticatedUserHandleResponse handles the InteractionsGetRestrictionsForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) interactionsGetRestrictionsForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientInteractionsGetRestrictionsForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientInteractionsGetRestrictionsForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1KrbaqcUserInteractionLimitsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientInteractionsGetRestrictionsForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// InteractionsGetRestrictionsForOrg - Shows which type of GitHub user can interact with this organization and when the restriction
// expires. If there is no restrictions, you will see an empty response.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientInteractionsGetRestrictionsForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.InteractionsGetRestrictionsForOrg
//     method.
func (client *GitHubV3RESTAPIClient) InteractionsGetRestrictionsForOrg(ctx context.Context, options *GitHubV3RESTAPIClientInteractionsGetRestrictionsForOrgOptions) (GitHubV3RESTAPIClientInteractionsGetRestrictionsForOrgResponse, error) {
	req, err := client.interactionsGetRestrictionsForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsGetRestrictionsForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsGetRestrictionsForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientInteractionsGetRestrictionsForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.interactionsGetRestrictionsForOrgHandleResponse(resp)
}

// interactionsGetRestrictionsForOrgCreateRequest creates the InteractionsGetRestrictionsForOrg request.
func (client *GitHubV3RESTAPIClient) interactionsGetRestrictionsForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientInteractionsGetRestrictionsForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/interaction-limits"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// interactionsGetRestrictionsForOrgHandleResponse handles the InteractionsGetRestrictionsForOrg response.
func (client *GitHubV3RESTAPIClient) interactionsGetRestrictionsForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientInteractionsGetRestrictionsForOrgResponse, error) {
	result := GitHubV3RESTAPIClientInteractionsGetRestrictionsForOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1Knd2ShOrgsOrgInteractionLimitsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientInteractionsGetRestrictionsForOrgResponse{}, err
	}
	return result, nil
}

// InteractionsGetRestrictionsForRepo - Shows which type of GitHub user can interact with this repository and when the restriction
// expires. If there are no restrictions, you will see an empty response.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientInteractionsGetRestrictionsForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.InteractionsGetRestrictionsForRepo
//     method.
func (client *GitHubV3RESTAPIClient) InteractionsGetRestrictionsForRepo(ctx context.Context, options *GitHubV3RESTAPIClientInteractionsGetRestrictionsForRepoOptions) (GitHubV3RESTAPIClientInteractionsGetRestrictionsForRepoResponse, error) {
	req, err := client.interactionsGetRestrictionsForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsGetRestrictionsForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsGetRestrictionsForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientInteractionsGetRestrictionsForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.interactionsGetRestrictionsForRepoHandleResponse(resp)
}

// interactionsGetRestrictionsForRepoCreateRequest creates the InteractionsGetRestrictionsForRepo request.
func (client *GitHubV3RESTAPIClient) interactionsGetRestrictionsForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientInteractionsGetRestrictionsForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/interaction-limits"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// interactionsGetRestrictionsForRepoHandleResponse handles the InteractionsGetRestrictionsForRepo response.
func (client *GitHubV3RESTAPIClient) interactionsGetRestrictionsForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientInteractionsGetRestrictionsForRepoResponse, error) {
	result := GitHubV3RESTAPIClientInteractionsGetRestrictionsForRepoResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths10Xtt49ReposOwnerRepoInteractionLimitsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientInteractionsGetRestrictionsForRepoResponse{}, err
	}
	return result, nil
}

// InteractionsRemoveRestrictionsForAuthenticatedUser - Removes any interaction restrictions from your public repositories.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForAuthenticatedUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.InteractionsRemoveRestrictionsForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) InteractionsRemoveRestrictionsForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForAuthenticatedUserOptions) (GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForAuthenticatedUserResponse, error) {
	req, err := client.interactionsRemoveRestrictionsForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForAuthenticatedUserResponse{}, nil
}

// interactionsRemoveRestrictionsForAuthenticatedUserCreateRequest creates the InteractionsRemoveRestrictionsForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) interactionsRemoveRestrictionsForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/interaction-limits"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// InteractionsRemoveRestrictionsForOrg - Removes all interaction restrictions from public repositories in the given organization.
// You must be an organization owner to remove restrictions.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.InteractionsRemoveRestrictionsForOrg
//     method.
func (client *GitHubV3RESTAPIClient) InteractionsRemoveRestrictionsForOrg(ctx context.Context, options *GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForOrgOptions) (GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForOrgResponse, error) {
	req, err := client.interactionsRemoveRestrictionsForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForOrgResponse{}, nil
}

// interactionsRemoveRestrictionsForOrgCreateRequest creates the InteractionsRemoveRestrictionsForOrg request.
func (client *GitHubV3RESTAPIClient) interactionsRemoveRestrictionsForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/interaction-limits"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// InteractionsRemoveRestrictionsForRepo - Removes all interaction restrictions from the given repository. You must have owner
// or admin access to remove restrictions. If the interaction limit is set for the user or organization that owns this
// repository, you will receive a 409 Conflict response and will not be able to use this endpoint to change the interaction
// limit for a single repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.InteractionsRemoveRestrictionsForRepo
//     method.
func (client *GitHubV3RESTAPIClient) InteractionsRemoveRestrictionsForRepo(ctx context.Context, options *GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForRepoOptions) (GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForRepoResponse, error) {
	req, err := client.interactionsRemoveRestrictionsForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusConflict) {
		return GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForRepoResponse{}, nil
}

// interactionsRemoveRestrictionsForRepoCreateRequest creates the InteractionsRemoveRestrictionsForRepo request.
func (client *GitHubV3RESTAPIClient) interactionsRemoveRestrictionsForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientInteractionsRemoveRestrictionsForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/interaction-limits"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// InteractionsSetRestrictionsForAuthenticatedUser - Temporarily restricts which type of GitHub user can interact with your
// public repositories. Setting the interaction limit at the user level will overwrite any interaction limits that are set
// for
// individual repositories owned by the user.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientInteractionsSetRestrictionsForAuthenticatedUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.InteractionsSetRestrictionsForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) InteractionsSetRestrictionsForAuthenticatedUser(ctx context.Context, body InteractionLimit, options *GitHubV3RESTAPIClientInteractionsSetRestrictionsForAuthenticatedUserOptions) (GitHubV3RESTAPIClientInteractionsSetRestrictionsForAuthenticatedUserResponse, error) {
	req, err := client.interactionsSetRestrictionsForAuthenticatedUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsSetRestrictionsForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsSetRestrictionsForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientInteractionsSetRestrictionsForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.interactionsSetRestrictionsForAuthenticatedUserHandleResponse(resp)
}

// interactionsSetRestrictionsForAuthenticatedUserCreateRequest creates the InteractionsSetRestrictionsForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) interactionsSetRestrictionsForAuthenticatedUserCreateRequest(ctx context.Context, body InteractionLimit, options *GitHubV3RESTAPIClientInteractionsSetRestrictionsForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/interaction-limits"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// interactionsSetRestrictionsForAuthenticatedUserHandleResponse handles the InteractionsSetRestrictionsForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) interactionsSetRestrictionsForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientInteractionsSetRestrictionsForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientInteractionsSetRestrictionsForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val InteractionLimitResponse
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientInteractionsSetRestrictionsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientInteractionsSetRestrictionsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientInteractionsSetRestrictionsForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// InteractionsSetRestrictionsForOrg - Temporarily restricts interactions to a certain type of GitHub user in any public repository
// in the given organization. You must be an organization owner to set these restrictions. Setting the
// interaction limit at the organization level will overwrite any interaction limits that are set for individual repositories
// owned by the organization.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientInteractionsSetRestrictionsForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.InteractionsSetRestrictionsForOrg
//     method.
func (client *GitHubV3RESTAPIClient) InteractionsSetRestrictionsForOrg(ctx context.Context, body InteractionLimit, options *GitHubV3RESTAPIClientInteractionsSetRestrictionsForOrgOptions) (GitHubV3RESTAPIClientInteractionsSetRestrictionsForOrgResponse, error) {
	req, err := client.interactionsSetRestrictionsForOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsSetRestrictionsForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsSetRestrictionsForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientInteractionsSetRestrictionsForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.interactionsSetRestrictionsForOrgHandleResponse(resp)
}

// interactionsSetRestrictionsForOrgCreateRequest creates the InteractionsSetRestrictionsForOrg request.
func (client *GitHubV3RESTAPIClient) interactionsSetRestrictionsForOrgCreateRequest(ctx context.Context, body InteractionLimit, options *GitHubV3RESTAPIClientInteractionsSetRestrictionsForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/interaction-limits"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// interactionsSetRestrictionsForOrgHandleResponse handles the InteractionsSetRestrictionsForOrg response.
func (client *GitHubV3RESTAPIClient) interactionsSetRestrictionsForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientInteractionsSetRestrictionsForOrgResponse, error) {
	result := GitHubV3RESTAPIClientInteractionsSetRestrictionsForOrgResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val InteractionLimitResponse
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientInteractionsSetRestrictionsForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientInteractionsSetRestrictionsForOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientInteractionsSetRestrictionsForOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// InteractionsSetRestrictionsForRepo - Temporarily restricts interactions to a certain type of GitHub user within the given
// repository. You must have owner or admin access to set these restrictions. If an interaction limit is set for the
// user or organization that owns this repository, you will receive a 409 Conflict response and will not be able to use this
// endpoint to change the interaction limit for a single repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientInteractionsSetRestrictionsForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.InteractionsSetRestrictionsForRepo
//     method.
func (client *GitHubV3RESTAPIClient) InteractionsSetRestrictionsForRepo(ctx context.Context, body InteractionLimit, options *GitHubV3RESTAPIClientInteractionsSetRestrictionsForRepoOptions) (GitHubV3RESTAPIClientInteractionsSetRestrictionsForRepoResponse, error) {
	req, err := client.interactionsSetRestrictionsForRepoCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsSetRestrictionsForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientInteractionsSetRestrictionsForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusConflict) {
		return GitHubV3RESTAPIClientInteractionsSetRestrictionsForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.interactionsSetRestrictionsForRepoHandleResponse(resp)
}

// interactionsSetRestrictionsForRepoCreateRequest creates the InteractionsSetRestrictionsForRepo request.
func (client *GitHubV3RESTAPIClient) interactionsSetRestrictionsForRepoCreateRequest(ctx context.Context, body InteractionLimit, options *GitHubV3RESTAPIClientInteractionsSetRestrictionsForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/interaction-limits"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// interactionsSetRestrictionsForRepoHandleResponse handles the InteractionsSetRestrictionsForRepo response.
func (client *GitHubV3RESTAPIClient) interactionsSetRestrictionsForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientInteractionsSetRestrictionsForRepoResponse, error) {
	result := GitHubV3RESTAPIClientInteractionsSetRestrictionsForRepoResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.InteractionLimitResponse); err != nil {
		return GitHubV3RESTAPIClientInteractionsSetRestrictionsForRepoResponse{}, err
	}
	return result, nil
}

// IssuesAddAssignees - Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesAddAssigneesOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesAddAssignees
//     method.
func (client *GitHubV3RESTAPIClient) IssuesAddAssignees(ctx context.Context, options *GitHubV3RESTAPIClientIssuesAddAssigneesOptions) (GitHubV3RESTAPIClientIssuesAddAssigneesResponse, error) {
	req, err := client.issuesAddAssigneesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesAddAssigneesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesAddAssigneesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientIssuesAddAssigneesResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesAddAssigneesHandleResponse(resp)
}

// issuesAddAssigneesCreateRequest creates the IssuesAddAssignees request.
func (client *GitHubV3RESTAPIClient) issuesAddAssigneesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesAddAssigneesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/assignees"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// issuesAddAssigneesHandleResponse handles the IssuesAddAssignees response.
func (client *GitHubV3RESTAPIClient) issuesAddAssigneesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesAddAssigneesResponse, error) {
	result := GitHubV3RESTAPIClientIssuesAddAssigneesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Issue); err != nil {
		return GitHubV3RESTAPIClientIssuesAddAssigneesResponse{}, err
	}
	return result, nil
}

// IssuesAddLabels - Add labels to an issue
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesAddLabelsOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesAddLabels
//     method.
func (client *GitHubV3RESTAPIClient) IssuesAddLabels(ctx context.Context, options *GitHubV3RESTAPIClientIssuesAddLabelsOptions) (GitHubV3RESTAPIClientIssuesAddLabelsResponse, error) {
	req, err := client.issuesAddLabelsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesAddLabelsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesAddLabelsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusMovedPermanently, http.StatusNotFound, http.StatusGone, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientIssuesAddLabelsResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesAddLabelsHandleResponse(resp)
}

// issuesAddLabelsCreateRequest creates the IssuesAddLabels request.
func (client *GitHubV3RESTAPIClient) issuesAddLabelsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesAddLabelsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/labels"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// issuesAddLabelsHandleResponse handles the IssuesAddLabels response.
func (client *GitHubV3RESTAPIClient) issuesAddLabelsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesAddLabelsResponse, error) {
	result := GitHubV3RESTAPIClientIssuesAddLabelsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Label
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesAddLabelsResponse{}, err
	}
	result.Value = val
	case http.StatusMovedPermanently:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesAddLabelsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesAddLabelsResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesAddLabelsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesAddLabelsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesAddLabelsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesCheckUserCanBeAssigned - Checks if a user has permission to be assigned to an issue in this repository.
// If the assignee can be assigned to issues in the repository, a 204 header with no content is returned.
// Otherwise a 404 status code is returned.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesCheckUserCanBeAssigned
//     method.
func (client *GitHubV3RESTAPIClient) IssuesCheckUserCanBeAssigned(ctx context.Context, assignee string, options *GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedOptions) (GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedResponse, error) {
	req, err := client.issuesCheckUserCanBeAssignedCreateRequest(ctx, assignee, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesCheckUserCanBeAssignedHandleResponse(resp)
}

// issuesCheckUserCanBeAssignedCreateRequest creates the IssuesCheckUserCanBeAssigned request.
func (client *GitHubV3RESTAPIClient) issuesCheckUserCanBeAssignedCreateRequest(ctx context.Context, assignee string, options *GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/assignees/{assignee}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if assignee == "" {
		return nil, errors.New("parameter assignee cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{assignee}", url.PathEscape(assignee))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesCheckUserCanBeAssignedHandleResponse handles the IssuesCheckUserCanBeAssigned response.
func (client *GitHubV3RESTAPIClient) issuesCheckUserCanBeAssignedHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedResponse, error) {
	result := GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedResponse{}, err
	}
	return result, nil
}

// IssuesCheckUserCanBeAssignedToIssue - Checks if a user has permission to be assigned to a specific issue.
// If the assignee can be assigned to this issue, a 204 status code with no content is returned.
// Otherwise a 404 status code is returned.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedToIssueOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesCheckUserCanBeAssignedToIssue
//     method.
func (client *GitHubV3RESTAPIClient) IssuesCheckUserCanBeAssignedToIssue(ctx context.Context, assignee string, options *GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedToIssueOptions) (GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedToIssueResponse, error) {
	req, err := client.issuesCheckUserCanBeAssignedToIssueCreateRequest(ctx, assignee, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedToIssueResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedToIssueResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedToIssueResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesCheckUserCanBeAssignedToIssueHandleResponse(resp)
}

// issuesCheckUserCanBeAssignedToIssueCreateRequest creates the IssuesCheckUserCanBeAssignedToIssue request.
func (client *GitHubV3RESTAPIClient) issuesCheckUserCanBeAssignedToIssueCreateRequest(ctx context.Context, assignee string, options *GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedToIssueOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	if assignee == "" {
		return nil, errors.New("parameter assignee cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{assignee}", url.PathEscape(assignee))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesCheckUserCanBeAssignedToIssueHandleResponse handles the IssuesCheckUserCanBeAssignedToIssue response.
func (client *GitHubV3RESTAPIClient) issuesCheckUserCanBeAssignedToIssueHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedToIssueResponse, error) {
	result := GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedToIssueResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientIssuesCheckUserCanBeAssignedToIssueResponse{}, err
	}
	return result, nil
}

// IssuesCreate - Any user with pull access to a repository can create an issue. If issues are disabled in the repository
// [https://docs.github.com/articles/disabling-issues/], the API returns a 410 Gone status.
// This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// Creating content too quickly using this endpoint may
// result in secondary rate limiting. See "Secondary rate limits [https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits]"
// and "Dealing with secondary rate limits
// [https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits]" for details.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesCreateOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesCreate
//     method.
func (client *GitHubV3RESTAPIClient) IssuesCreate(ctx context.Context, body Paths1Ki9DyiReposOwnerRepoIssuesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesCreateOptions) (GitHubV3RESTAPIClientIssuesCreateResponse, error) {
	req, err := client.issuesCreateCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesCreateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesCreateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden, http.StatusNotFound, http.StatusGone, http.StatusUnprocessableEntity, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientIssuesCreateResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesCreateHandleResponse(resp)
}

// issuesCreateCreateRequest creates the IssuesCreate request.
func (client *GitHubV3RESTAPIClient) issuesCreateCreateRequest(ctx context.Context, body Paths1Ki9DyiReposOwnerRepoIssuesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesCreateOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// issuesCreateHandleResponse handles the IssuesCreate response.
func (client *GitHubV3RESTAPIClient) issuesCreateHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesCreateResponse, error) {
	result := GitHubV3RESTAPIClientIssuesCreateResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Issue
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesCreateResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesCreateComment - This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// Creating content too quickly using this endpoint may
// result in secondary rate limiting. See "Secondary rate limits [https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits]"
// and "Dealing with secondary rate limits
// [https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits]" for details.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesCreateCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesCreateComment
//     method.
func (client *GitHubV3RESTAPIClient) IssuesCreateComment(ctx context.Context, body Paths1KgjzyReposOwnerRepoIssuesIssueNumberCommentsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesCreateCommentOptions) (GitHubV3RESTAPIClientIssuesCreateCommentResponse, error) {
	req, err := client.issuesCreateCommentCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesCreateCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesCreateCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden, http.StatusNotFound, http.StatusGone, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientIssuesCreateCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesCreateCommentHandleResponse(resp)
}

// issuesCreateCommentCreateRequest creates the IssuesCreateComment request.
func (client *GitHubV3RESTAPIClient) issuesCreateCommentCreateRequest(ctx context.Context, body Paths1KgjzyReposOwnerRepoIssuesIssueNumberCommentsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesCreateCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/comments"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// issuesCreateCommentHandleResponse handles the IssuesCreateComment response.
func (client *GitHubV3RESTAPIClient) issuesCreateCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesCreateCommentResponse, error) {
	result := GitHubV3RESTAPIClientIssuesCreateCommentResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val IssueComment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateCommentResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateCommentResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateCommentResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateCommentResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesCreateCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesCreateLabel - Create a label
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesCreateLabelOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesCreateLabel
//     method.
func (client *GitHubV3RESTAPIClient) IssuesCreateLabel(ctx context.Context, body Paths1Sd44YpReposOwnerRepoLabelsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesCreateLabelOptions) (GitHubV3RESTAPIClientIssuesCreateLabelResponse, error) {
	req, err := client.issuesCreateLabelCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesCreateLabelResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesCreateLabelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientIssuesCreateLabelResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesCreateLabelHandleResponse(resp)
}

// issuesCreateLabelCreateRequest creates the IssuesCreateLabel request.
func (client *GitHubV3RESTAPIClient) issuesCreateLabelCreateRequest(ctx context.Context, body Paths1Sd44YpReposOwnerRepoLabelsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesCreateLabelOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/labels"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// issuesCreateLabelHandleResponse handles the IssuesCreateLabel response.
func (client *GitHubV3RESTAPIClient) issuesCreateLabelHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesCreateLabelResponse, error) {
	result := GitHubV3RESTAPIClientIssuesCreateLabelResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Label
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateLabelResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateLabelResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateLabelResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesCreateLabelResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesCreateMilestone - Create a milestone
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesCreateMilestoneOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesCreateMilestone
//     method.
func (client *GitHubV3RESTAPIClient) IssuesCreateMilestone(ctx context.Context, body Paths1SebvwtReposOwnerRepoMilestonesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesCreateMilestoneOptions) (GitHubV3RESTAPIClientIssuesCreateMilestoneResponse, error) {
	req, err := client.issuesCreateMilestoneCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesCreateMilestoneResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesCreateMilestoneResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientIssuesCreateMilestoneResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesCreateMilestoneHandleResponse(resp)
}

// issuesCreateMilestoneCreateRequest creates the IssuesCreateMilestone request.
func (client *GitHubV3RESTAPIClient) issuesCreateMilestoneCreateRequest(ctx context.Context, body Paths1SebvwtReposOwnerRepoMilestonesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesCreateMilestoneOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/milestones"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// issuesCreateMilestoneHandleResponse handles the IssuesCreateMilestone response.
func (client *GitHubV3RESTAPIClient) issuesCreateMilestoneHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesCreateMilestoneResponse, error) {
	result := GitHubV3RESTAPIClientIssuesCreateMilestoneResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Milestone
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateMilestoneResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateMilestoneResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesCreateMilestoneResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesCreateMilestoneResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesDeleteComment - Delete an issue comment
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesDeleteCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesDeleteComment
//     method.
func (client *GitHubV3RESTAPIClient) IssuesDeleteComment(ctx context.Context, options *GitHubV3RESTAPIClientIssuesDeleteCommentOptions) (GitHubV3RESTAPIClientIssuesDeleteCommentResponse, error) {
	req, err := client.issuesDeleteCommentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesDeleteCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesDeleteCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientIssuesDeleteCommentResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientIssuesDeleteCommentResponse{}, nil
}

// issuesDeleteCommentCreateRequest creates the IssuesDeleteComment request.
func (client *GitHubV3RESTAPIClient) issuesDeleteCommentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesDeleteCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/comments/{comment_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// IssuesDeleteLabel - Delete a label
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesDeleteLabelOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesDeleteLabel
//     method.
func (client *GitHubV3RESTAPIClient) IssuesDeleteLabel(ctx context.Context, name string, options *GitHubV3RESTAPIClientIssuesDeleteLabelOptions) (GitHubV3RESTAPIClientIssuesDeleteLabelResponse, error) {
	req, err := client.issuesDeleteLabelCreateRequest(ctx, name, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesDeleteLabelResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesDeleteLabelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientIssuesDeleteLabelResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientIssuesDeleteLabelResponse{}, nil
}

// issuesDeleteLabelCreateRequest creates the IssuesDeleteLabel request.
func (client *GitHubV3RESTAPIClient) issuesDeleteLabelCreateRequest(ctx context.Context, name string, options *GitHubV3RESTAPIClientIssuesDeleteLabelOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/labels/{name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// IssuesDeleteMilestone - Delete a milestone
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesDeleteMilestoneOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesDeleteMilestone
//     method.
func (client *GitHubV3RESTAPIClient) IssuesDeleteMilestone(ctx context.Context, options *GitHubV3RESTAPIClientIssuesDeleteMilestoneOptions) (GitHubV3RESTAPIClientIssuesDeleteMilestoneResponse, error) {
	req, err := client.issuesDeleteMilestoneCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesDeleteMilestoneResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesDeleteMilestoneResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientIssuesDeleteMilestoneResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesDeleteMilestoneHandleResponse(resp)
}

// issuesDeleteMilestoneCreateRequest creates the IssuesDeleteMilestone request.
func (client *GitHubV3RESTAPIClient) issuesDeleteMilestoneCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesDeleteMilestoneOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/milestones/{milestone_number}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{milestone_number}", url.PathEscape(strconv.FormatInt(int64(client.milestoneNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesDeleteMilestoneHandleResponse handles the IssuesDeleteMilestone response.
func (client *GitHubV3RESTAPIClient) issuesDeleteMilestoneHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesDeleteMilestoneResponse, error) {
	result := GitHubV3RESTAPIClientIssuesDeleteMilestoneResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientIssuesDeleteMilestoneResponse{}, err
	}
	return result, nil
}

// IssuesGet - The API returns a 301 Moved Permanently status [https://docs.github.com/rest/overview/resources-in-the-rest-api#http-redirects-redirects]
// if the issue wastransferred
// [https://docs.github.com/articles/transferring-an-issue-to-another-repository/] to another repository. If the issue was
// transferred to or deleted from a repository where the authenticated user lacks
// read access, the API returns a 404 Not Found status. If the issue was deleted from a repository where the authenticated
// user has read access, the API returns a 410 Gone status. To receive webhook
// events for transferred and deleted issues, subscribe to the issues [https://docs.github.com/webhooks/event-payloads/#issues]
// webhook.
// Note: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason,
// "Issues" endpoints may return both issues and pull requests in the response. You
// can identify pull requests by the pull_request key. Be aware that the id of a pull request returned from "Issues" endpoints
// will be an issue id. To find out the pull request id, use the "List pull
// requests [https://docs.github.com/rest/reference/pulls#list-pull-requests]" endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesGetOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesGet
//     method.
func (client *GitHubV3RESTAPIClient) IssuesGet(ctx context.Context, options *GitHubV3RESTAPIClientIssuesGetOptions) (GitHubV3RESTAPIClientIssuesGetResponse, error) {
	req, err := client.issuesGetCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusNotFound, http.StatusGone) {
		return GitHubV3RESTAPIClientIssuesGetResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesGetHandleResponse(resp)
}

// issuesGetCreateRequest creates the IssuesGet request.
func (client *GitHubV3RESTAPIClient) issuesGetCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesGetOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesGetHandleResponse handles the IssuesGet response.
func (client *GitHubV3RESTAPIClient) issuesGetHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesGetResponse, error) {
	result := GitHubV3RESTAPIClientIssuesGetResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Issue
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesGetResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesGetResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesGetResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesGetResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesGetComment - Get an issue comment
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesGetCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesGetComment
//     method.
func (client *GitHubV3RESTAPIClient) IssuesGetComment(ctx context.Context, options *GitHubV3RESTAPIClientIssuesGetCommentOptions) (GitHubV3RESTAPIClientIssuesGetCommentResponse, error) {
	req, err := client.issuesGetCommentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesGetCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesGetCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientIssuesGetCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesGetCommentHandleResponse(resp)
}

// issuesGetCommentCreateRequest creates the IssuesGetComment request.
func (client *GitHubV3RESTAPIClient) issuesGetCommentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesGetCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/comments/{comment_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesGetCommentHandleResponse handles the IssuesGetComment response.
func (client *GitHubV3RESTAPIClient) issuesGetCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesGetCommentResponse, error) {
	result := GitHubV3RESTAPIClientIssuesGetCommentResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val IssueComment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesGetCommentResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesGetCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesGetCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesGetEvent - Get an issue event
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesGetEventOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesGetEvent
//     method.
func (client *GitHubV3RESTAPIClient) IssuesGetEvent(ctx context.Context, eventID int32, options *GitHubV3RESTAPIClientIssuesGetEventOptions) (GitHubV3RESTAPIClientIssuesGetEventResponse, error) {
	req, err := client.issuesGetEventCreateRequest(ctx, eventID, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesGetEventResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesGetEventResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusGone) {
		return GitHubV3RESTAPIClientIssuesGetEventResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesGetEventHandleResponse(resp)
}

// issuesGetEventCreateRequest creates the IssuesGetEvent request.
func (client *GitHubV3RESTAPIClient) issuesGetEventCreateRequest(ctx context.Context, eventID int32, options *GitHubV3RESTAPIClientIssuesGetEventOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/events/{event_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{event_id}", url.PathEscape(strconv.FormatInt(int64(eventID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesGetEventHandleResponse handles the IssuesGetEvent response.
func (client *GitHubV3RESTAPIClient) issuesGetEventHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesGetEventResponse, error) {
	result := GitHubV3RESTAPIClientIssuesGetEventResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val IssueEvent
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesGetEventResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesGetEventResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesGetEventResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesGetEventResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesGetEventResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesGetLabel - Get a label
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesGetLabelOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesGetLabel
//     method.
func (client *GitHubV3RESTAPIClient) IssuesGetLabel(ctx context.Context, name string, options *GitHubV3RESTAPIClientIssuesGetLabelOptions) (GitHubV3RESTAPIClientIssuesGetLabelResponse, error) {
	req, err := client.issuesGetLabelCreateRequest(ctx, name, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesGetLabelResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesGetLabelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientIssuesGetLabelResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesGetLabelHandleResponse(resp)
}

// issuesGetLabelCreateRequest creates the IssuesGetLabel request.
func (client *GitHubV3RESTAPIClient) issuesGetLabelCreateRequest(ctx context.Context, name string, options *GitHubV3RESTAPIClientIssuesGetLabelOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/labels/{name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesGetLabelHandleResponse handles the IssuesGetLabel response.
func (client *GitHubV3RESTAPIClient) issuesGetLabelHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesGetLabelResponse, error) {
	result := GitHubV3RESTAPIClientIssuesGetLabelResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Label
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesGetLabelResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesGetLabelResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesGetLabelResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesGetMilestone - Get a milestone
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesGetMilestoneOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesGetMilestone
//     method.
func (client *GitHubV3RESTAPIClient) IssuesGetMilestone(ctx context.Context, options *GitHubV3RESTAPIClientIssuesGetMilestoneOptions) (GitHubV3RESTAPIClientIssuesGetMilestoneResponse, error) {
	req, err := client.issuesGetMilestoneCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesGetMilestoneResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesGetMilestoneResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientIssuesGetMilestoneResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesGetMilestoneHandleResponse(resp)
}

// issuesGetMilestoneCreateRequest creates the IssuesGetMilestone request.
func (client *GitHubV3RESTAPIClient) issuesGetMilestoneCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesGetMilestoneOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/milestones/{milestone_number}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{milestone_number}", url.PathEscape(strconv.FormatInt(int64(client.milestoneNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesGetMilestoneHandleResponse handles the IssuesGetMilestone response.
func (client *GitHubV3RESTAPIClient) issuesGetMilestoneHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesGetMilestoneResponse, error) {
	result := GitHubV3RESTAPIClientIssuesGetMilestoneResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Milestone
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesGetMilestoneResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesGetMilestoneResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesGetMilestoneResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesList - List issues assigned to the authenticated user across all visible repositories including owned repositories,
// member repositories, and organization repositories. You can use the filter query parameter
// to fetch issues that are not necessarily assigned to you.
// Note: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason,
// "Issues" endpoints may return both issues and pull requests in the response. You
// can identify pull requests by the pull_request key. Be aware that the id of a pull request returned from "Issues" endpoints
// will be an issue id. To find out the pull request id, use the "List pull
// requests [https://docs.github.com/rest/reference/pulls#list-pull-requests]" endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesListOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesList
//     method.
func (client *GitHubV3RESTAPIClient) IssuesList(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListOptions) (GitHubV3RESTAPIClientIssuesListResponse, error) {
	req, err := client.issuesListCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientIssuesListResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesListHandleResponse(resp)
}

// issuesListCreateRequest creates the IssuesList request.
func (client *GitHubV3RESTAPIClient) issuesListCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListOptions) (*policy.Request, error) {
	urlPath := "/issues"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", string(*options.Filter))
	}
	if options != nil && options.State != nil {
		reqQP.Set("state", string(*options.State))
	}
	if client.labels != nil {
		reqQP.Set("labels", *client.labels)
	}
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if options != nil && options.Collab != nil {
		reqQP.Set("collab", strconv.FormatBool(*options.Collab))
	}
	if options != nil && options.Orgs != nil {
		reqQP.Set("orgs", strconv.FormatBool(*options.Orgs))
	}
	if options != nil && options.Owned != nil {
		reqQP.Set("owned", strconv.FormatBool(*options.Owned))
	}
	if options != nil && options.Pulls != nil {
		reqQP.Set("pulls", strconv.FormatBool(*options.Pulls))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesListHandleResponse handles the IssuesList response.
func (client *GitHubV3RESTAPIClient) issuesListHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesListResponse, error) {
	result := GitHubV3RESTAPIClientIssuesListResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Issue
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesListResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesListAssignees - Lists the available assignees [https://docs.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/]
// for issues in a repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesListAssigneesOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesListAssignees
//     method.
func (client *GitHubV3RESTAPIClient) IssuesListAssignees(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListAssigneesOptions) (GitHubV3RESTAPIClientIssuesListAssigneesResponse, error) {
	req, err := client.issuesListAssigneesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListAssigneesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListAssigneesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientIssuesListAssigneesResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesListAssigneesHandleResponse(resp)
}

// issuesListAssigneesCreateRequest creates the IssuesListAssignees request.
func (client *GitHubV3RESTAPIClient) issuesListAssigneesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListAssigneesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/assignees"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesListAssigneesHandleResponse handles the IssuesListAssignees response.
func (client *GitHubV3RESTAPIClient) issuesListAssigneesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesListAssigneesResponse, error) {
	result := GitHubV3RESTAPIClientIssuesListAssigneesResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*SimpleUser
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListAssigneesResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListAssigneesResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesListAssigneesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesListComments - Issue Comments are ordered by ascending ID.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesListCommentsOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesListComments
//     method.
func (client *GitHubV3RESTAPIClient) IssuesListComments(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListCommentsOptions) (GitHubV3RESTAPIClientIssuesListCommentsResponse, error) {
	req, err := client.issuesListCommentsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListCommentsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListCommentsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusGone) {
		return GitHubV3RESTAPIClientIssuesListCommentsResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesListCommentsHandleResponse(resp)
}

// issuesListCommentsCreateRequest creates the IssuesListComments request.
func (client *GitHubV3RESTAPIClient) issuesListCommentsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListCommentsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/comments"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesListCommentsHandleResponse handles the IssuesListComments response.
func (client *GitHubV3RESTAPIClient) issuesListCommentsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesListCommentsResponse, error) {
	result := GitHubV3RESTAPIClientIssuesListCommentsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*IssueComment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListCommentsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListCommentsResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListCommentsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesListCommentsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesListCommentsForRepo - By default, Issue Comments are ordered by ascending ID.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesListCommentsForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesListCommentsForRepo
//     method.
func (client *GitHubV3RESTAPIClient) IssuesListCommentsForRepo(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListCommentsForRepoOptions) (GitHubV3RESTAPIClientIssuesListCommentsForRepoResponse, error) {
	req, err := client.issuesListCommentsForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListCommentsForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListCommentsForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientIssuesListCommentsForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesListCommentsForRepoHandleResponse(resp)
}

// issuesListCommentsForRepoCreateRequest creates the IssuesListCommentsForRepo request.
func (client *GitHubV3RESTAPIClient) issuesListCommentsForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListCommentsForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/comments"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.sortParam != nil {
		reqQP.Set("sort", string(*client.sortParam))
	}
	if options != nil && options.Direction != nil {
		reqQP.Set("direction", string(*options.Direction))
	}
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesListCommentsForRepoHandleResponse handles the IssuesListCommentsForRepo response.
func (client *GitHubV3RESTAPIClient) issuesListCommentsForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesListCommentsForRepoResponse, error) {
	result := GitHubV3RESTAPIClientIssuesListCommentsForRepoResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*IssueComment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListCommentsForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListCommentsForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListCommentsForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesListCommentsForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesListEvents - List issue events
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesListEventsOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesListEvents
//     method.
func (client *GitHubV3RESTAPIClient) IssuesListEvents(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListEventsOptions) (GitHubV3RESTAPIClientIssuesListEventsResponse, error) {
	req, err := client.issuesListEventsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListEventsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListEventsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusGone) {
		return GitHubV3RESTAPIClientIssuesListEventsResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesListEventsHandleResponse(resp)
}

// issuesListEventsCreateRequest creates the IssuesListEvents request.
func (client *GitHubV3RESTAPIClient) issuesListEventsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListEventsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/events"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesListEventsHandleResponse handles the IssuesListEvents response.
func (client *GitHubV3RESTAPIClient) issuesListEventsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesListEventsResponse, error) {
	result := GitHubV3RESTAPIClientIssuesListEventsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*IssueEventForIssue
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListEventsResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListEventsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesListEventsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesListEventsForRepo - List issue events for a repository
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesListEventsForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesListEventsForRepo
//     method.
func (client *GitHubV3RESTAPIClient) IssuesListEventsForRepo(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListEventsForRepoOptions) (GitHubV3RESTAPIClientIssuesListEventsForRepoResponse, error) {
	req, err := client.issuesListEventsForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListEventsForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListEventsForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientIssuesListEventsForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesListEventsForRepoHandleResponse(resp)
}

// issuesListEventsForRepoCreateRequest creates the IssuesListEventsForRepo request.
func (client *GitHubV3RESTAPIClient) issuesListEventsForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListEventsForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/events"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesListEventsForRepoHandleResponse handles the IssuesListEventsForRepo response.
func (client *GitHubV3RESTAPIClient) issuesListEventsForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesListEventsForRepoResponse, error) {
	result := GitHubV3RESTAPIClientIssuesListEventsForRepoResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*IssueEvent
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListEventsForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListEventsForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesListEventsForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesListEventsForTimeline - List timeline events for an issue
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesListEventsForTimelineOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesListEventsForTimeline
//     method.
func (client *GitHubV3RESTAPIClient) IssuesListEventsForTimeline(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListEventsForTimelineOptions) (GitHubV3RESTAPIClientIssuesListEventsForTimelineResponse, error) {
	req, err := client.issuesListEventsForTimelineCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListEventsForTimelineResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListEventsForTimelineResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusGone) {
		return GitHubV3RESTAPIClientIssuesListEventsForTimelineResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesListEventsForTimelineHandleResponse(resp)
}

// issuesListEventsForTimelineCreateRequest creates the IssuesListEventsForTimeline request.
func (client *GitHubV3RESTAPIClient) issuesListEventsForTimelineCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListEventsForTimelineOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/timeline"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesListEventsForTimelineHandleResponse handles the IssuesListEventsForTimeline response.
func (client *GitHubV3RESTAPIClient) issuesListEventsForTimelineHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesListEventsForTimelineResponse, error) {
	result := GitHubV3RESTAPIClientIssuesListEventsForTimelineResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*TimelineIssueEvents
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListEventsForTimelineResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListEventsForTimelineResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListEventsForTimelineResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesListEventsForTimelineResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesListForAuthenticatedUser - List issues across owned and member repositories assigned to the authenticated user.
// Note: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason,
// "Issues" endpoints may return both issues and pull requests in the response. You
// can identify pull requests by the pull_request key. Be aware that the id of a pull request returned from "Issues" endpoints
// will be an issue id. To find out the pull request id, use the "List pull
// requests [https://docs.github.com/rest/reference/pulls#list-pull-requests]" endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesListForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesListForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) IssuesListForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListForAuthenticatedUserOptions) (GitHubV3RESTAPIClientIssuesListForAuthenticatedUserResponse, error) {
	req, err := client.issuesListForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusNotFound) {
		return GitHubV3RESTAPIClientIssuesListForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesListForAuthenticatedUserHandleResponse(resp)
}

// issuesListForAuthenticatedUserCreateRequest creates the IssuesListForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) issuesListForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/issues"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", string(*options.Filter))
	}
	if options != nil && options.State != nil {
		reqQP.Set("state", string(*options.State))
	}
	if client.labels != nil {
		reqQP.Set("labels", *client.labels)
	}
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesListForAuthenticatedUserHandleResponse handles the IssuesListForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) issuesListForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesListForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientIssuesListForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Issue
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesListForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesListForOrg - List issues in an organization assigned to the authenticated user.
// Note: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason,
// "Issues" endpoints may return both issues and pull requests in the response. You
// can identify pull requests by the pull_request key. Be aware that the id of a pull request returned from "Issues" endpoints
// will be an issue id. To find out the pull request id, use the "List pull
// requests [https://docs.github.com/rest/reference/pulls#list-pull-requests]" endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesListForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesListForOrg
//     method.
func (client *GitHubV3RESTAPIClient) IssuesListForOrg(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListForOrgOptions) (GitHubV3RESTAPIClientIssuesListForOrgResponse, error) {
	req, err := client.issuesListForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientIssuesListForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesListForOrgHandleResponse(resp)
}

// issuesListForOrgCreateRequest creates the IssuesListForOrg request.
func (client *GitHubV3RESTAPIClient) issuesListForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/issues"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", string(*options.Filter))
	}
	if options != nil && options.State != nil {
		reqQP.Set("state", string(*options.State))
	}
	if client.labels != nil {
		reqQP.Set("labels", *client.labels)
	}
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesListForOrgHandleResponse handles the IssuesListForOrg response.
func (client *GitHubV3RESTAPIClient) issuesListForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesListForOrgResponse, error) {
	result := GitHubV3RESTAPIClientIssuesListForOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Issue
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListForOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesListForOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesListForRepo - List issues in a repository. Only open issues will be listed.
// Note: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason,
// "Issues" endpoints may return both issues and pull requests in the response. You
// can identify pull requests by the pull_request key. Be aware that the id of a pull request returned from "Issues" endpoints
// will be an issue id. To find out the pull request id, use the "List pull
// requests [https://docs.github.com/rest/reference/pulls#list-pull-requests]" endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesListForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesListForRepo
//     method.
func (client *GitHubV3RESTAPIClient) IssuesListForRepo(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListForRepoOptions) (GitHubV3RESTAPIClientIssuesListForRepoResponse, error) {
	req, err := client.issuesListForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientIssuesListForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesListForRepoHandleResponse(resp)
}

// issuesListForRepoCreateRequest creates the IssuesListForRepo request.
func (client *GitHubV3RESTAPIClient) issuesListForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Milestone != nil {
		reqQP.Set("milestone", *options.Milestone)
	}
	if options != nil && options.State != nil {
		reqQP.Set("state", string(*options.State))
	}
	if options != nil && options.Assignee != nil {
		reqQP.Set("assignee", *options.Assignee)
	}
	if options != nil && options.Creator != nil {
		reqQP.Set("creator", *options.Creator)
	}
	if options != nil && options.Mentioned != nil {
		reqQP.Set("mentioned", *options.Mentioned)
	}
	if client.labels != nil {
		reqQP.Set("labels", *client.labels)
	}
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesListForRepoHandleResponse handles the IssuesListForRepo response.
func (client *GitHubV3RESTAPIClient) issuesListForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesListForRepoResponse, error) {
	result := GitHubV3RESTAPIClientIssuesListForRepoResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Issue
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesListForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesListLabelsForMilestone - List labels for issues in a milestone
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesListLabelsForMilestoneOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesListLabelsForMilestone
//     method.
func (client *GitHubV3RESTAPIClient) IssuesListLabelsForMilestone(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListLabelsForMilestoneOptions) (GitHubV3RESTAPIClientIssuesListLabelsForMilestoneResponse, error) {
	req, err := client.issuesListLabelsForMilestoneCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListLabelsForMilestoneResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListLabelsForMilestoneResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientIssuesListLabelsForMilestoneResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesListLabelsForMilestoneHandleResponse(resp)
}

// issuesListLabelsForMilestoneCreateRequest creates the IssuesListLabelsForMilestone request.
func (client *GitHubV3RESTAPIClient) issuesListLabelsForMilestoneCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListLabelsForMilestoneOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/milestones/{milestone_number}/labels"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{milestone_number}", url.PathEscape(strconv.FormatInt(int64(client.milestoneNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesListLabelsForMilestoneHandleResponse handles the IssuesListLabelsForMilestone response.
func (client *GitHubV3RESTAPIClient) issuesListLabelsForMilestoneHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesListLabelsForMilestoneResponse, error) {
	result := GitHubV3RESTAPIClientIssuesListLabelsForMilestoneResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.LabelArray); err != nil {
		return GitHubV3RESTAPIClientIssuesListLabelsForMilestoneResponse{}, err
	}
	return result, nil
}

// IssuesListLabelsForRepo - List labels for a repository
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesListLabelsForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesListLabelsForRepo
//     method.
func (client *GitHubV3RESTAPIClient) IssuesListLabelsForRepo(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListLabelsForRepoOptions) (GitHubV3RESTAPIClientIssuesListLabelsForRepoResponse, error) {
	req, err := client.issuesListLabelsForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListLabelsForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListLabelsForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientIssuesListLabelsForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesListLabelsForRepoHandleResponse(resp)
}

// issuesListLabelsForRepoCreateRequest creates the IssuesListLabelsForRepo request.
func (client *GitHubV3RESTAPIClient) issuesListLabelsForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListLabelsForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/labels"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesListLabelsForRepoHandleResponse handles the IssuesListLabelsForRepo response.
func (client *GitHubV3RESTAPIClient) issuesListLabelsForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesListLabelsForRepoResponse, error) {
	result := GitHubV3RESTAPIClientIssuesListLabelsForRepoResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Label
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListLabelsForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListLabelsForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesListLabelsForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesListLabelsOnIssue - List labels for an issue
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesListLabelsOnIssueOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesListLabelsOnIssue
//     method.
func (client *GitHubV3RESTAPIClient) IssuesListLabelsOnIssue(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListLabelsOnIssueOptions) (GitHubV3RESTAPIClientIssuesListLabelsOnIssueResponse, error) {
	req, err := client.issuesListLabelsOnIssueCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListLabelsOnIssueResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListLabelsOnIssueResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusGone) {
		return GitHubV3RESTAPIClientIssuesListLabelsOnIssueResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesListLabelsOnIssueHandleResponse(resp)
}

// issuesListLabelsOnIssueCreateRequest creates the IssuesListLabelsOnIssue request.
func (client *GitHubV3RESTAPIClient) issuesListLabelsOnIssueCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListLabelsOnIssueOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/labels"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesListLabelsOnIssueHandleResponse handles the IssuesListLabelsOnIssue response.
func (client *GitHubV3RESTAPIClient) issuesListLabelsOnIssueHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesListLabelsOnIssueResponse, error) {
	result := GitHubV3RESTAPIClientIssuesListLabelsOnIssueResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Label
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListLabelsOnIssueResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListLabelsOnIssueResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListLabelsOnIssueResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesListLabelsOnIssueResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesListMilestones - List milestones
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesListMilestonesOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesListMilestones
//     method.
func (client *GitHubV3RESTAPIClient) IssuesListMilestones(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListMilestonesOptions) (GitHubV3RESTAPIClientIssuesListMilestonesResponse, error) {
	req, err := client.issuesListMilestonesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListMilestonesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesListMilestonesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientIssuesListMilestonesResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesListMilestonesHandleResponse(resp)
}

// issuesListMilestonesCreateRequest creates the IssuesListMilestones request.
func (client *GitHubV3RESTAPIClient) issuesListMilestonesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesListMilestonesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/milestones"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.State != nil {
		reqQP.Set("state", string(*options.State))
	}
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if options != nil && options.Direction != nil {
		reqQP.Set("direction", string(*options.Direction))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesListMilestonesHandleResponse handles the IssuesListMilestones response.
func (client *GitHubV3RESTAPIClient) issuesListMilestonesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesListMilestonesResponse, error) {
	result := GitHubV3RESTAPIClientIssuesListMilestonesResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Milestone
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListMilestonesResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesListMilestonesResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesListMilestonesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesLock - Users with push access can lock an issue or pull request's conversation.
// Note that, if you choose not to pass any parameters, you'll need to set Content-Length to zero when calling out to this
// endpoint. For more information, see "HTTP verbs
// [https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesLockOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesLock
//     method.
func (client *GitHubV3RESTAPIClient) IssuesLock(ctx context.Context, body Paths1Lguu6GReposOwnerRepoIssuesIssueNumberLockPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesLockOptions) (GitHubV3RESTAPIClientIssuesLockResponse, error) {
	req, err := client.issuesLockCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesLockResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesLockResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusForbidden, http.StatusNotFound, http.StatusGone, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientIssuesLockResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesLockHandleResponse(resp)
}

// issuesLockCreateRequest creates the IssuesLock request.
func (client *GitHubV3RESTAPIClient) issuesLockCreateRequest(ctx context.Context, body Paths1Lguu6GReposOwnerRepoIssuesIssueNumberLockPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesLockOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/lock"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// issuesLockHandleResponse handles the IssuesLock response.
func (client *GitHubV3RESTAPIClient) issuesLockHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesLockResponse, error) {
	result := GitHubV3RESTAPIClientIssuesLockResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesLockResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesLockResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesLockResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesLockResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesLockResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesRemoveAllLabels - Remove all labels from an issue
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesRemoveAllLabelsOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesRemoveAllLabels
//     method.
func (client *GitHubV3RESTAPIClient) IssuesRemoveAllLabels(ctx context.Context, options *GitHubV3RESTAPIClientIssuesRemoveAllLabelsOptions) (GitHubV3RESTAPIClientIssuesRemoveAllLabelsResponse, error) {
	req, err := client.issuesRemoveAllLabelsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesRemoveAllLabelsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesRemoveAllLabelsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusMovedPermanently, http.StatusNotFound, http.StatusGone) {
		return GitHubV3RESTAPIClientIssuesRemoveAllLabelsResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesRemoveAllLabelsHandleResponse(resp)
}

// issuesRemoveAllLabelsCreateRequest creates the IssuesRemoveAllLabels request.
func (client *GitHubV3RESTAPIClient) issuesRemoveAllLabelsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesRemoveAllLabelsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/labels"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesRemoveAllLabelsHandleResponse handles the IssuesRemoveAllLabels response.
func (client *GitHubV3RESTAPIClient) issuesRemoveAllLabelsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesRemoveAllLabelsResponse, error) {
	result := GitHubV3RESTAPIClientIssuesRemoveAllLabelsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientIssuesRemoveAllLabelsResponse{}, err
	}
	return result, nil
}

// IssuesRemoveAssignees - Removes one or more assignees from an issue.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesRemoveAssigneesOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesRemoveAssignees
//     method.
func (client *GitHubV3RESTAPIClient) IssuesRemoveAssignees(ctx context.Context, options *GitHubV3RESTAPIClientIssuesRemoveAssigneesOptions) (GitHubV3RESTAPIClientIssuesRemoveAssigneesResponse, error) {
	req, err := client.issuesRemoveAssigneesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesRemoveAssigneesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesRemoveAssigneesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientIssuesRemoveAssigneesResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesRemoveAssigneesHandleResponse(resp)
}

// issuesRemoveAssigneesCreateRequest creates the IssuesRemoveAssignees request.
func (client *GitHubV3RESTAPIClient) issuesRemoveAssigneesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesRemoveAssigneesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/assignees"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// issuesRemoveAssigneesHandleResponse handles the IssuesRemoveAssignees response.
func (client *GitHubV3RESTAPIClient) issuesRemoveAssigneesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesRemoveAssigneesResponse, error) {
	result := GitHubV3RESTAPIClientIssuesRemoveAssigneesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Issue); err != nil {
		return GitHubV3RESTAPIClientIssuesRemoveAssigneesResponse{}, err
	}
	return result, nil
}

// IssuesRemoveLabel - Removes the specified label from the issue, and returns the remaining labels on the issue. This endpoint
// returns a 404 Not Found status if the label does not exist.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesRemoveLabelOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesRemoveLabel
//     method.
func (client *GitHubV3RESTAPIClient) IssuesRemoveLabel(ctx context.Context, name string, options *GitHubV3RESTAPIClientIssuesRemoveLabelOptions) (GitHubV3RESTAPIClientIssuesRemoveLabelResponse, error) {
	req, err := client.issuesRemoveLabelCreateRequest(ctx, name, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesRemoveLabelResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesRemoveLabelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusMovedPermanently, http.StatusNotFound, http.StatusGone) {
		return GitHubV3RESTAPIClientIssuesRemoveLabelResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesRemoveLabelHandleResponse(resp)
}

// issuesRemoveLabelCreateRequest creates the IssuesRemoveLabel request.
func (client *GitHubV3RESTAPIClient) issuesRemoveLabelCreateRequest(ctx context.Context, name string, options *GitHubV3RESTAPIClientIssuesRemoveLabelOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesRemoveLabelHandleResponse handles the IssuesRemoveLabel response.
func (client *GitHubV3RESTAPIClient) issuesRemoveLabelHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesRemoveLabelResponse, error) {
	result := GitHubV3RESTAPIClientIssuesRemoveLabelResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Label
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesRemoveLabelResponse{}, err
	}
	result.Value = val
	case http.StatusMovedPermanently:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesRemoveLabelResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesRemoveLabelResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesRemoveLabelResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesRemoveLabelResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesSetLabels - Removes any previous labels and sets the new labels for an issue.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesSetLabelsOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesSetLabels
//     method.
func (client *GitHubV3RESTAPIClient) IssuesSetLabels(ctx context.Context, body Paths16T4D44ReposOwnerRepoIssuesIssueNumberLabelsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesSetLabelsOptions) (GitHubV3RESTAPIClientIssuesSetLabelsResponse, error) {
	req, err := client.issuesSetLabelsCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesSetLabelsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesSetLabelsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusMovedPermanently, http.StatusNotFound, http.StatusGone, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientIssuesSetLabelsResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesSetLabelsHandleResponse(resp)
}

// issuesSetLabelsCreateRequest creates the IssuesSetLabels request.
func (client *GitHubV3RESTAPIClient) issuesSetLabelsCreateRequest(ctx context.Context, body Paths16T4D44ReposOwnerRepoIssuesIssueNumberLabelsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesSetLabelsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/labels"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// issuesSetLabelsHandleResponse handles the IssuesSetLabels response.
func (client *GitHubV3RESTAPIClient) issuesSetLabelsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesSetLabelsResponse, error) {
	result := GitHubV3RESTAPIClientIssuesSetLabelsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Label
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesSetLabelsResponse{}, err
	}
	result.Value = val
	case http.StatusMovedPermanently:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesSetLabelsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesSetLabelsResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesSetLabelsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesSetLabelsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesSetLabelsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesUnlock - Users with push access can unlock an issue's conversation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesUnlockOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesUnlock
//     method.
func (client *GitHubV3RESTAPIClient) IssuesUnlock(ctx context.Context, options *GitHubV3RESTAPIClientIssuesUnlockOptions) (GitHubV3RESTAPIClientIssuesUnlockResponse, error) {
	req, err := client.issuesUnlockCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesUnlockResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesUnlockResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientIssuesUnlockResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesUnlockHandleResponse(resp)
}

// issuesUnlockCreateRequest creates the IssuesUnlock request.
func (client *GitHubV3RESTAPIClient) issuesUnlockCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientIssuesUnlockOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/lock"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// issuesUnlockHandleResponse handles the IssuesUnlock response.
func (client *GitHubV3RESTAPIClient) issuesUnlockHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesUnlockResponse, error) {
	result := GitHubV3RESTAPIClientIssuesUnlockResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientIssuesUnlockResponse{}, err
	}
	return result, nil
}

// IssuesUpdate - Issue owners and users with push access can edit an issue.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesUpdateOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesUpdate
//     method.
func (client *GitHubV3RESTAPIClient) IssuesUpdate(ctx context.Context, body PathsIa8Cy4ReposOwnerRepoIssuesIssueNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesUpdateOptions) (GitHubV3RESTAPIClientIssuesUpdateResponse, error) {
	req, err := client.issuesUpdateCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusMovedPermanently, http.StatusForbidden, http.StatusNotFound, http.StatusGone, http.StatusUnprocessableEntity, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientIssuesUpdateResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesUpdateHandleResponse(resp)
}

// issuesUpdateCreateRequest creates the IssuesUpdate request.
func (client *GitHubV3RESTAPIClient) issuesUpdateCreateRequest(ctx context.Context, body PathsIa8Cy4ReposOwnerRepoIssuesIssueNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesUpdateOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// issuesUpdateHandleResponse handles the IssuesUpdate response.
func (client *GitHubV3RESTAPIClient) issuesUpdateHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesUpdateResponse, error) {
	result := GitHubV3RESTAPIClientIssuesUpdateResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Issue
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusMovedPermanently:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesUpdateResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesUpdateComment - Update an issue comment
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesUpdateCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesUpdateComment
//     method.
func (client *GitHubV3RESTAPIClient) IssuesUpdateComment(ctx context.Context, body PathsSf3RmpReposOwnerRepoIssuesCommentsCommentIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesUpdateCommentOptions) (GitHubV3RESTAPIClientIssuesUpdateCommentResponse, error) {
	req, err := client.issuesUpdateCommentCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientIssuesUpdateCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesUpdateCommentHandleResponse(resp)
}

// issuesUpdateCommentCreateRequest creates the IssuesUpdateComment request.
func (client *GitHubV3RESTAPIClient) issuesUpdateCommentCreateRequest(ctx context.Context, body PathsSf3RmpReposOwnerRepoIssuesCommentsCommentIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesUpdateCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/comments/{comment_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// issuesUpdateCommentHandleResponse handles the IssuesUpdateComment response.
func (client *GitHubV3RESTAPIClient) issuesUpdateCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesUpdateCommentResponse, error) {
	result := GitHubV3RESTAPIClientIssuesUpdateCommentResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val IssueComment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateCommentResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientIssuesUpdateCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// IssuesUpdateLabel - Update a label
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesUpdateLabelOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesUpdateLabel
//     method.
func (client *GitHubV3RESTAPIClient) IssuesUpdateLabel(ctx context.Context, name string, body Paths47Uk01ReposOwnerRepoLabelsNamePatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesUpdateLabelOptions) (GitHubV3RESTAPIClientIssuesUpdateLabelResponse, error) {
	req, err := client.issuesUpdateLabelCreateRequest(ctx, name, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateLabelResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateLabelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientIssuesUpdateLabelResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesUpdateLabelHandleResponse(resp)
}

// issuesUpdateLabelCreateRequest creates the IssuesUpdateLabel request.
func (client *GitHubV3RESTAPIClient) issuesUpdateLabelCreateRequest(ctx context.Context, name string, body Paths47Uk01ReposOwnerRepoLabelsNamePatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesUpdateLabelOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/labels/{name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// issuesUpdateLabelHandleResponse handles the IssuesUpdateLabel response.
func (client *GitHubV3RESTAPIClient) issuesUpdateLabelHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesUpdateLabelResponse, error) {
	result := GitHubV3RESTAPIClientIssuesUpdateLabelResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Label); err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateLabelResponse{}, err
	}
	return result, nil
}

// IssuesUpdateMilestone - Update a milestone
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientIssuesUpdateMilestoneOptions contains the optional parameters for the GitHubV3RESTAPIClient.IssuesUpdateMilestone
//     method.
func (client *GitHubV3RESTAPIClient) IssuesUpdateMilestone(ctx context.Context, body Paths1Lbsq8BReposOwnerRepoMilestonesMilestoneNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesUpdateMilestoneOptions) (GitHubV3RESTAPIClientIssuesUpdateMilestoneResponse, error) {
	req, err := client.issuesUpdateMilestoneCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateMilestoneResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateMilestoneResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientIssuesUpdateMilestoneResponse{}, runtime.NewResponseError(resp)
	}
	return client.issuesUpdateMilestoneHandleResponse(resp)
}

// issuesUpdateMilestoneCreateRequest creates the IssuesUpdateMilestone request.
func (client *GitHubV3RESTAPIClient) issuesUpdateMilestoneCreateRequest(ctx context.Context, body Paths1Lbsq8BReposOwnerRepoMilestonesMilestoneNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientIssuesUpdateMilestoneOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/milestones/{milestone_number}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{milestone_number}", url.PathEscape(strconv.FormatInt(int64(client.milestoneNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// issuesUpdateMilestoneHandleResponse handles the IssuesUpdateMilestone response.
func (client *GitHubV3RESTAPIClient) issuesUpdateMilestoneHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientIssuesUpdateMilestoneResponse, error) {
	result := GitHubV3RESTAPIClientIssuesUpdateMilestoneResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Milestone); err != nil {
		return GitHubV3RESTAPIClientIssuesUpdateMilestoneResponse{}, err
	}
	return result, nil
}

// LicensesGet - Get a license
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientLicensesGetOptions contains the optional parameters for the GitHubV3RESTAPIClient.LicensesGet
//     method.
func (client *GitHubV3RESTAPIClient) LicensesGet(ctx context.Context, license string, options *GitHubV3RESTAPIClientLicensesGetOptions) (GitHubV3RESTAPIClientLicensesGetResponse, error) {
	req, err := client.licensesGetCreateRequest(ctx, license, options)
	if err != nil {
		return GitHubV3RESTAPIClientLicensesGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientLicensesGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientLicensesGetResponse{}, runtime.NewResponseError(resp)
	}
	return client.licensesGetHandleResponse(resp)
}

// licensesGetCreateRequest creates the LicensesGet request.
func (client *GitHubV3RESTAPIClient) licensesGetCreateRequest(ctx context.Context, license string, options *GitHubV3RESTAPIClientLicensesGetOptions) (*policy.Request, error) {
	urlPath := "/licenses/{license}"
	if license == "" {
		return nil, errors.New("parameter license cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{license}", url.PathEscape(license))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// licensesGetHandleResponse handles the LicensesGet response.
func (client *GitHubV3RESTAPIClient) licensesGetHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientLicensesGetResponse, error) {
	result := GitHubV3RESTAPIClientLicensesGetResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val License
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientLicensesGetResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientLicensesGetResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientLicensesGetResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientLicensesGetResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// LicensesGetAllCommonlyUsed - Get all commonly used licenses
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientLicensesGetAllCommonlyUsedOptions contains the optional parameters for the GitHubV3RESTAPIClient.LicensesGetAllCommonlyUsed
//     method.
func (client *GitHubV3RESTAPIClient) LicensesGetAllCommonlyUsed(ctx context.Context, options *GitHubV3RESTAPIClientLicensesGetAllCommonlyUsedOptions) (GitHubV3RESTAPIClientLicensesGetAllCommonlyUsedResponse, error) {
	req, err := client.licensesGetAllCommonlyUsedCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientLicensesGetAllCommonlyUsedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientLicensesGetAllCommonlyUsedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified) {
		return GitHubV3RESTAPIClientLicensesGetAllCommonlyUsedResponse{}, runtime.NewResponseError(resp)
	}
	return client.licensesGetAllCommonlyUsedHandleResponse(resp)
}

// licensesGetAllCommonlyUsedCreateRequest creates the LicensesGetAllCommonlyUsed request.
func (client *GitHubV3RESTAPIClient) licensesGetAllCommonlyUsedCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientLicensesGetAllCommonlyUsedOptions) (*policy.Request, error) {
	urlPath := "/licenses"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Featured != nil {
		reqQP.Set("featured", strconv.FormatBool(*options.Featured))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// licensesGetAllCommonlyUsedHandleResponse handles the LicensesGetAllCommonlyUsed response.
func (client *GitHubV3RESTAPIClient) licensesGetAllCommonlyUsedHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientLicensesGetAllCommonlyUsedResponse, error) {
	result := GitHubV3RESTAPIClientLicensesGetAllCommonlyUsedResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.LicenseSimpleArray); err != nil {
		return GitHubV3RESTAPIClientLicensesGetAllCommonlyUsedResponse{}, err
	}
	return result, nil
}

// LicensesGetForRepo - This method returns the contents of the repository's license file, if one is detected.
// Similar to Get repository content [https://docs.github.com/rest/reference/repos#get-repository-content], this method also
// supports custom media types
// [https://docs.github.com/rest/overview/media-types] for retrieving the raw license content or rendered license HTML.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientLicensesGetForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.LicensesGetForRepo
//     method.
func (client *GitHubV3RESTAPIClient) LicensesGetForRepo(ctx context.Context, options *GitHubV3RESTAPIClientLicensesGetForRepoOptions) (GitHubV3RESTAPIClientLicensesGetForRepoResponse, error) {
	req, err := client.licensesGetForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientLicensesGetForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientLicensesGetForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientLicensesGetForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.licensesGetForRepoHandleResponse(resp)
}

// licensesGetForRepoCreateRequest creates the LicensesGetForRepo request.
func (client *GitHubV3RESTAPIClient) licensesGetForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientLicensesGetForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/license"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// licensesGetForRepoHandleResponse handles the LicensesGetForRepo response.
func (client *GitHubV3RESTAPIClient) licensesGetForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientLicensesGetForRepoResponse, error) {
	result := GitHubV3RESTAPIClientLicensesGetForRepoResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.LicenseContent); err != nil {
		return GitHubV3RESTAPIClientLicensesGetForRepoResponse{}, err
	}
	return result, nil
}

// MarkdownRender - Render a Markdown document
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMarkdownRenderOptions contains the optional parameters for the GitHubV3RESTAPIClient.MarkdownRender
//     method.
func (client *GitHubV3RESTAPIClient) MarkdownRender(ctx context.Context, body Paths1A4R3XoMarkdownPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientMarkdownRenderOptions) (GitHubV3RESTAPIClientMarkdownRenderResponse, error) {
	req, err := client.markdownRenderCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientMarkdownRenderResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMarkdownRenderResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified) {
		return GitHubV3RESTAPIClientMarkdownRenderResponse{}, runtime.NewResponseError(resp)
	}
	return client.markdownRenderHandleResponse(resp)
}

// markdownRenderCreateRequest creates the MarkdownRender request.
func (client *GitHubV3RESTAPIClient) markdownRenderCreateRequest(ctx context.Context, body Paths1A4R3XoMarkdownPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientMarkdownRenderOptions) (*policy.Request, error) {
	urlPath := "/markdown"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"text/html"}
	return req, runtime.MarshalAsJSON(req, body)
}

// markdownRenderHandleResponse handles the MarkdownRender response.
func (client *GitHubV3RESTAPIClient) markdownRenderHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMarkdownRenderResponse, error) {
	result := GitHubV3RESTAPIClientMarkdownRenderResponse{}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		result.ContentLength = &val
	}
	if val := resp.Header.Get("X-CommonMarker-Version"); val != "" {
		result.XCommonMarkerVersion = &val
	}
	body, err := runtime.Payload(resp)
	if err != nil {
		return GitHubV3RESTAPIClientMarkdownRenderResponse{}, err
	}
	txt := string(body)
	result.Value = &txt
	return result, nil
}

// MarkdownRenderRaw - You must send Markdown as plain text (using a Content-Type header of text/plain or text/x-markdown)
// to this endpoint, rather than using JSON format. In raw mode, GitHub Flavored Markdown
// [https://github.github.com/gfm/] is not supported and Markdown will be rendered in plain format like a README.md file.
// Markdown content must be 400 KB or less.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - contentType - Upload file type
//   - options - GitHubV3RESTAPIClientMarkdownRenderRawOptions contains the optional parameters for the GitHubV3RESTAPIClient.MarkdownRenderRaw
//     method.
func (client *GitHubV3RESTAPIClient) MarkdownRenderRaw(ctx context.Context, contentType ContentType, options *GitHubV3RESTAPIClientMarkdownRenderRawOptions) (GitHubV3RESTAPIClientMarkdownRenderRawResponse, error) {
	req, err := client.markdownRenderRawCreateRequest(ctx, contentType, options)
	if err != nil {
		return GitHubV3RESTAPIClientMarkdownRenderRawResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMarkdownRenderRawResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified) {
		return GitHubV3RESTAPIClientMarkdownRenderRawResponse{}, runtime.NewResponseError(resp)
	}
	return client.markdownRenderRawHandleResponse(resp)
}

// markdownRenderRawCreateRequest creates the MarkdownRenderRaw request.
func (client *GitHubV3RESTAPIClient) markdownRenderRawCreateRequest(ctx context.Context, contentType ContentType, options *GitHubV3RESTAPIClientMarkdownRenderRawOptions) (*policy.Request, error) {
	urlPath := "/markdown/raw"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{string(contentType)}
	req.Raw().Header["Accept"] = []string{"text/html"}
	if options != nil && options.Data != nil {
	body := streaming.NopCloser(strings.NewReader(*options.Data))
	return req, req.SetBody(body, "text/plain")
	}
	return req, nil
}

// markdownRenderRawHandleResponse handles the MarkdownRenderRaw response.
func (client *GitHubV3RESTAPIClient) markdownRenderRawHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMarkdownRenderRawResponse, error) {
	result := GitHubV3RESTAPIClientMarkdownRenderRawResponse{}
	if val := resp.Header.Get("X-CommonMarker-Version"); val != "" {
		result.XCommonMarkerVersion = &val
	}
	body, err := runtime.Payload(resp)
	if err != nil {
		return GitHubV3RESTAPIClientMarkdownRenderRawResponse{}, err
	}
	txt := string(body)
	result.Value = &txt
	return result, nil
}

// MetaGet - Returns meta information about GitHub, including a list of GitHub's IP addresses. For more information, see "About
// GitHub's IP addresses [https://docs.github.com/articles/about-github-s-ip-addresses/]
// ."
// Note: The IP addresses shown in the documentation's response are only example values. You must always query the API directly
// to get the latest list of IP addresses.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMetaGetOptions contains the optional parameters for the GitHubV3RESTAPIClient.MetaGet method.
func (client *GitHubV3RESTAPIClient) MetaGet(ctx context.Context, options *GitHubV3RESTAPIClientMetaGetOptions) (GitHubV3RESTAPIClientMetaGetResponse, error) {
	req, err := client.metaGetCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMetaGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMetaGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified) {
		return GitHubV3RESTAPIClientMetaGetResponse{}, runtime.NewResponseError(resp)
	}
	return client.metaGetHandleResponse(resp)
}

// metaGetCreateRequest creates the MetaGet request.
func (client *GitHubV3RESTAPIClient) metaGetCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMetaGetOptions) (*policy.Request, error) {
	urlPath := "/meta"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// metaGetHandleResponse handles the MetaGet response.
func (client *GitHubV3RESTAPIClient) metaGetHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMetaGetResponse, error) {
	result := GitHubV3RESTAPIClientMetaGetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIOverview); err != nil {
		return GitHubV3RESTAPIClientMetaGetResponse{}, err
	}
	return result, nil
}

// MetaGetAllVersions - Get all supported GitHub API versions.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMetaGetAllVersionsOptions contains the optional parameters for the GitHubV3RESTAPIClient.MetaGetAllVersions
//     method.
func (client *GitHubV3RESTAPIClient) MetaGetAllVersions(ctx context.Context, options *GitHubV3RESTAPIClientMetaGetAllVersionsOptions) (GitHubV3RESTAPIClientMetaGetAllVersionsResponse, error) {
	req, err := client.metaGetAllVersionsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMetaGetAllVersionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMetaGetAllVersionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientMetaGetAllVersionsResponse{}, runtime.NewResponseError(resp)
	}
	return client.metaGetAllVersionsHandleResponse(resp)
}

// metaGetAllVersionsCreateRequest creates the MetaGetAllVersions request.
func (client *GitHubV3RESTAPIClient) metaGetAllVersionsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMetaGetAllVersionsOptions) (*policy.Request, error) {
	urlPath := "/versions"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// metaGetAllVersionsHandleResponse handles the MetaGetAllVersions response.
func (client *GitHubV3RESTAPIClient) metaGetAllVersionsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMetaGetAllVersionsResponse, error) {
	result := GitHubV3RESTAPIClientMetaGetAllVersionsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*time.Time
	var aux []*dateType
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return GitHubV3RESTAPIClientMetaGetAllVersionsResponse{}, err
	}
	cp := make([]*time.Time, len(aux))
	for i := 0; i < len(aux); i++ {
		cp[i] = (*time.Time)(aux[i])
	}
	result.Value = cp
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMetaGetAllVersionsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientMetaGetAllVersionsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// MetaGetOctocat - Get the octocat as ASCII art
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMetaGetOctocatOptions contains the optional parameters for the GitHubV3RESTAPIClient.MetaGetOctocat
//     method.
func (client *GitHubV3RESTAPIClient) MetaGetOctocat(ctx context.Context, options *GitHubV3RESTAPIClientMetaGetOctocatOptions) (GitHubV3RESTAPIClientMetaGetOctocatResponse, error) {
	req, err := client.metaGetOctocatCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMetaGetOctocatResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMetaGetOctocatResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientMetaGetOctocatResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientMetaGetOctocatResponse{}, nil
}

// metaGetOctocatCreateRequest creates the MetaGetOctocat request.
func (client *GitHubV3RESTAPIClient) metaGetOctocatCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMetaGetOctocatOptions) (*policy.Request, error) {
	urlPath := "/octocat"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.S != nil {
		reqQP.Set("s", *options.S)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// MetaGetZen - Get a random sentence from the Zen of GitHub
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMetaGetZenOptions contains the optional parameters for the GitHubV3RESTAPIClient.MetaGetZen
//     method.
func (client *GitHubV3RESTAPIClient) MetaGetZen(ctx context.Context, options *GitHubV3RESTAPIClientMetaGetZenOptions) (GitHubV3RESTAPIClientMetaGetZenResponse, error) {
	req, err := client.metaGetZenCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMetaGetZenResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMetaGetZenResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientMetaGetZenResponse{}, runtime.NewResponseError(resp)
	}
	return client.metaGetZenHandleResponse(resp)
}

// metaGetZenCreateRequest creates the MetaGetZen request.
func (client *GitHubV3RESTAPIClient) metaGetZenCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMetaGetZenOptions) (*policy.Request, error) {
	urlPath := "/zen"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"text/plain"}
	return req, nil
}

// metaGetZenHandleResponse handles the MetaGetZen response.
func (client *GitHubV3RESTAPIClient) metaGetZenHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMetaGetZenResponse, error) {
	result := GitHubV3RESTAPIClientMetaGetZenResponse{}
	body, err := runtime.Payload(resp)
	if err != nil {
		return GitHubV3RESTAPIClientMetaGetZenResponse{}, err
	}
	txt := string(body)
	result.Value = &txt
	return result, nil
}

// MetaRoot - Get Hypermedia links to resources accessible in GitHub's REST API
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMetaRootOptions contains the optional parameters for the GitHubV3RESTAPIClient.MetaRoot
//     method.
func (client *GitHubV3RESTAPIClient) MetaRoot(ctx context.Context, options *GitHubV3RESTAPIClientMetaRootOptions) (GitHubV3RESTAPIClientMetaRootResponse, error) {
	req, err := client.metaRootCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMetaRootResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMetaRootResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientMetaRootResponse{}, runtime.NewResponseError(resp)
	}
	return client.metaRootHandleResponse(resp)
}

// metaRootCreateRequest creates the MetaRoot request.
func (client *GitHubV3RESTAPIClient) metaRootCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMetaRootOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// metaRootHandleResponse handles the MetaRoot response.
func (client *GitHubV3RESTAPIClient) metaRootHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMetaRootResponse, error) {
	result := GitHubV3RESTAPIClientMetaRootResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Root); err != nil {
		return GitHubV3RESTAPIClientMetaRootResponse{}, err
	}
	return result, nil
}

// MigrationsCancelImport - Stop an import for a repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsCancelImportOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsCancelImport
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsCancelImport(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsCancelImportOptions) (GitHubV3RESTAPIClientMigrationsCancelImportResponse, error) {
	req, err := client.migrationsCancelImportCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsCancelImportResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsCancelImportResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientMigrationsCancelImportResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsCancelImportHandleResponse(resp)
}

// migrationsCancelImportCreateRequest creates the MigrationsCancelImport request.
func (client *GitHubV3RESTAPIClient) migrationsCancelImportCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsCancelImportOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/import"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// migrationsCancelImportHandleResponse handles the MigrationsCancelImport response.
func (client *GitHubV3RESTAPIClient) migrationsCancelImportHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsCancelImportResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsCancelImportResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientMigrationsCancelImportResponse{}, err
	}
	return result, nil
}

// MigrationsDeleteArchiveForAuthenticatedUser - Deletes a previous migration archive. Downloadable migration archives are
// automatically deleted after seven days. Migration metadata, which is returned in the List user migrations
// [https://docs.github.com/rest/reference/migrations#list-user-migrations] and Get a user migration status [https://docs.github.com/rest/reference/migrations#get-a-user-migration-status]
// endpoints, will
// continue to be available even after an archive is deleted.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsDeleteArchiveForAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.MigrationsDeleteArchiveForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) MigrationsDeleteArchiveForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsDeleteArchiveForAuthenticatedUserOptions) (GitHubV3RESTAPIClientMigrationsDeleteArchiveForAuthenticatedUserResponse, error) {
	req, err := client.migrationsDeleteArchiveForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsDeleteArchiveForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsDeleteArchiveForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientMigrationsDeleteArchiveForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsDeleteArchiveForAuthenticatedUserHandleResponse(resp)
}

// migrationsDeleteArchiveForAuthenticatedUserCreateRequest creates the MigrationsDeleteArchiveForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) migrationsDeleteArchiveForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsDeleteArchiveForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/migrations/{migration_id}/archive"
	urlPath = strings.ReplaceAll(urlPath, "{migration_id}", url.PathEscape(strconv.FormatInt(int64(client.migrationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// migrationsDeleteArchiveForAuthenticatedUserHandleResponse handles the MigrationsDeleteArchiveForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) migrationsDeleteArchiveForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsDeleteArchiveForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsDeleteArchiveForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientMigrationsDeleteArchiveForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// MigrationsDeleteArchiveForOrg - Deletes a previous migration archive. Migration archives are automatically deleted after
// seven days.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsDeleteArchiveForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsDeleteArchiveForOrg
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsDeleteArchiveForOrg(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsDeleteArchiveForOrgOptions) (GitHubV3RESTAPIClientMigrationsDeleteArchiveForOrgResponse, error) {
	req, err := client.migrationsDeleteArchiveForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsDeleteArchiveForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsDeleteArchiveForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientMigrationsDeleteArchiveForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsDeleteArchiveForOrgHandleResponse(resp)
}

// migrationsDeleteArchiveForOrgCreateRequest creates the MigrationsDeleteArchiveForOrg request.
func (client *GitHubV3RESTAPIClient) migrationsDeleteArchiveForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsDeleteArchiveForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/migrations/{migration_id}/archive"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{migration_id}", url.PathEscape(strconv.FormatInt(int64(client.migrationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// migrationsDeleteArchiveForOrgHandleResponse handles the MigrationsDeleteArchiveForOrg response.
func (client *GitHubV3RESTAPIClient) migrationsDeleteArchiveForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsDeleteArchiveForOrgResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsDeleteArchiveForOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientMigrationsDeleteArchiveForOrgResponse{}, err
	}
	return result, nil
}

// MigrationsDownloadArchiveForOrg - Fetches the URL to a migration archive.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsDownloadArchiveForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsDownloadArchiveForOrg
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsDownloadArchiveForOrg(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsDownloadArchiveForOrgOptions) (GitHubV3RESTAPIClientMigrationsDownloadArchiveForOrgResponse, error) {
	req, err := client.migrationsDownloadArchiveForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsDownloadArchiveForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsDownloadArchiveForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNotFound) {
		return GitHubV3RESTAPIClientMigrationsDownloadArchiveForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsDownloadArchiveForOrgHandleResponse(resp)
}

// migrationsDownloadArchiveForOrgCreateRequest creates the MigrationsDownloadArchiveForOrg request.
func (client *GitHubV3RESTAPIClient) migrationsDownloadArchiveForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsDownloadArchiveForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/migrations/{migration_id}/archive"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{migration_id}", url.PathEscape(strconv.FormatInt(int64(client.migrationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// migrationsDownloadArchiveForOrgHandleResponse handles the MigrationsDownloadArchiveForOrg response.
func (client *GitHubV3RESTAPIClient) migrationsDownloadArchiveForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsDownloadArchiveForOrgResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsDownloadArchiveForOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientMigrationsDownloadArchiveForOrgResponse{}, err
	}
	return result, nil
}

// MigrationsGetArchiveForAuthenticatedUser - Fetches the URL to download the migration archive as a tar.gz file. Depending
// on the resources your repository uses, the migration archive can contain JSON files with data for these objects:
// * attachments
// * bases
// * commit_comments
// * issue_comments
// * issue_events
// * issues
// * milestones
// * organizations
// * projects
// * protected_branches
// * pullrequestreviews
// * pull_requests
// * releases
// * repositories
// * review_comments
// * schema
// * users
// The archive will also contain an attachments directory that includes all attachment files uploaded to GitHub.com and a
// repositories directory that contains the repository's Git data.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsGetArchiveForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.MigrationsGetArchiveForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) MigrationsGetArchiveForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsGetArchiveForAuthenticatedUserOptions) (GitHubV3RESTAPIClientMigrationsGetArchiveForAuthenticatedUserResponse, error) {
	req, err := client.migrationsGetArchiveForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsGetArchiveForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsGetArchiveForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientMigrationsGetArchiveForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsGetArchiveForAuthenticatedUserHandleResponse(resp)
}

// migrationsGetArchiveForAuthenticatedUserCreateRequest creates the MigrationsGetArchiveForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) migrationsGetArchiveForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsGetArchiveForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/migrations/{migration_id}/archive"
	urlPath = strings.ReplaceAll(urlPath, "{migration_id}", url.PathEscape(strconv.FormatInt(int64(client.migrationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// migrationsGetArchiveForAuthenticatedUserHandleResponse handles the MigrationsGetArchiveForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) migrationsGetArchiveForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsGetArchiveForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsGetArchiveForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientMigrationsGetArchiveForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// MigrationsGetCommitAuthors - Each type of source control system represents authors in a different way. For example, a Git
// commit author has a display name and an email address, but a Subversion commit author just has a username.
// The GitHub Importer will make the author information valid, but the author might not be correct. For example, it will change
// the bare Subversion username hubot into something like hubot.
// This endpoint and the Map a commit author [https://docs.github.com/rest/reference/migrations#map-a-commit-author] endpoint
// allow you to provide correct Git author information.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsGetCommitAuthorsOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsGetCommitAuthors
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsGetCommitAuthors(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsGetCommitAuthorsOptions) (GitHubV3RESTAPIClientMigrationsGetCommitAuthorsResponse, error) {
	req, err := client.migrationsGetCommitAuthorsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsGetCommitAuthorsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsGetCommitAuthorsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientMigrationsGetCommitAuthorsResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsGetCommitAuthorsHandleResponse(resp)
}

// migrationsGetCommitAuthorsCreateRequest creates the MigrationsGetCommitAuthors request.
func (client *GitHubV3RESTAPIClient) migrationsGetCommitAuthorsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsGetCommitAuthorsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/import/authors"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// migrationsGetCommitAuthorsHandleResponse handles the MigrationsGetCommitAuthors response.
func (client *GitHubV3RESTAPIClient) migrationsGetCommitAuthorsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsGetCommitAuthorsResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsGetCommitAuthorsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*PorterAuthor
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsGetCommitAuthorsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsGetCommitAuthorsResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsGetCommitAuthorsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientMigrationsGetCommitAuthorsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// MigrationsGetImportStatus - View the progress of an import.
// Import status
// This section includes details about the possible values of the status field of the Import Progress response.
// An import that does not have errors will progress through these steps:
// * detecting - the "detection" step of the import is in progress because the request did not include a vcs parameter. The
// import is identifying the type of source control present at the URL.
// * importing - the "raw" step of the import is in progress. This is where commit data is fetched from the original repository.
// The import progress response will include commit_count (the total number
// of raw commits that will be imported) and percent (0 - 100, the current progress through the import).
// * mapping - the "rewrite" step of the import is in progress. This is where SVN branches are converted to Git branches,
// and where author updates are applied. The import progress response does not
// include progress information.
// * pushing - the "push" step of the import is in progress. This is where the importer updates the repository on GitHub.
// The import progress response will include push_percent, which is the percent
// value reported by git push when it is "Writing objects".
// * complete - the import is complete, and the repository is ready on GitHub.
// If there are problems, you will see one of these in the status field:
// * auth_failed - the import requires authentication in order to connect to the original repository. To update authentication
// for the import, please see the Update an import
// [https://docs.github.com/rest/reference/migrations#update-an-import] section.
// * error - the import encountered an error. The import progress response will include the failed_step and an error message.
// Contact GitHub Support
// [https://support.github.com/contact?tags=dotcom-rest-api] for more information.
// * detectionneedsauth - the importer requires authentication for the originating repository to continue detection. To update
// authentication for the import, please see the Update an import
// [https://docs.github.com/rest/reference/migrations#update-an-import] section.
// * detectionfoundnothing - the importer didn't recognize any source control at the URL. To resolve, Cancel the import [https://docs.github.com/rest/reference/migrations#cancel-an-import]
// and retry
// [https://docs.github.com/rest/reference/migrations#start-an-import] with the correct URL.
// * detectionfoundmultiple - the importer found several projects or repositories at the provided URL. When this is the case,
// the Import Progress response will also include a project_choices field with
// the possible project choices as values. To update project choice, please see the Update an import [https://docs.github.com/rest/reference/migrations#update-an-import]
// section.
// The project_choices field
// When multiple projects are found at the provided URL, the response hash will include a project_choices field, the value
// of which is an array of hashes each representing a project choice. The exact
// key/value pairs of the project hashes will differ depending on the version control type.
// Git LFS related fields
// This section includes details about Git LFS related fields that may be present in the Import Progress response.
// * uselfs - describes whether the import has been opted in or out of using Git LFS. The value can be optin, opt_out, or
// undecided if no action has been taken.
// * haslargefiles - the boolean value describing whether files larger than 100MB were found during the importing step.
// * largefilessize - the total size in gigabytes of files larger than 100MB found in the originating repository.
// * largefilescount - the total number of files larger than 100MB found in the originating repository. To see a list of these
// files, make a "Get Large Files" request.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsGetImportStatusOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsGetImportStatus
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsGetImportStatus(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsGetImportStatusOptions) (GitHubV3RESTAPIClientMigrationsGetImportStatusResponse, error) {
	req, err := client.migrationsGetImportStatusCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsGetImportStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsGetImportStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientMigrationsGetImportStatusResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsGetImportStatusHandleResponse(resp)
}

// migrationsGetImportStatusCreateRequest creates the MigrationsGetImportStatus request.
func (client *GitHubV3RESTAPIClient) migrationsGetImportStatusCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsGetImportStatusOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/import"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// migrationsGetImportStatusHandleResponse handles the MigrationsGetImportStatus response.
func (client *GitHubV3RESTAPIClient) migrationsGetImportStatusHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsGetImportStatusResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsGetImportStatusResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Import
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsGetImportStatusResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsGetImportStatusResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsGetImportStatusResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientMigrationsGetImportStatusResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// MigrationsGetLargeFiles - List files larger than 100MB found during the import
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsGetLargeFilesOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsGetLargeFiles
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsGetLargeFiles(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsGetLargeFilesOptions) (GitHubV3RESTAPIClientMigrationsGetLargeFilesResponse, error) {
	req, err := client.migrationsGetLargeFilesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsGetLargeFilesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsGetLargeFilesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientMigrationsGetLargeFilesResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsGetLargeFilesHandleResponse(resp)
}

// migrationsGetLargeFilesCreateRequest creates the MigrationsGetLargeFiles request.
func (client *GitHubV3RESTAPIClient) migrationsGetLargeFilesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsGetLargeFilesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/import/large_files"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// migrationsGetLargeFilesHandleResponse handles the MigrationsGetLargeFiles response.
func (client *GitHubV3RESTAPIClient) migrationsGetLargeFilesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsGetLargeFilesResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsGetLargeFilesResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*PorterLargeFile
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsGetLargeFilesResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsGetLargeFilesResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientMigrationsGetLargeFilesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// MigrationsGetStatusForAuthenticatedUser - Fetches a single user migration. The response includes the state of the migration,
// which can be one of the following values:
// * pending - the migration hasn't started yet.
// * exporting - the migration is in progress.
// * exported - the migration finished successfully.
// * failed - the migration failed.
// Once the migration has been exported you can download the migration archive [https://docs.github.com/rest/reference/migrations#download-a-user-migration-archive].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsGetStatusForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.MigrationsGetStatusForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) MigrationsGetStatusForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsGetStatusForAuthenticatedUserOptions) (GitHubV3RESTAPIClientMigrationsGetStatusForAuthenticatedUserResponse, error) {
	req, err := client.migrationsGetStatusForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsGetStatusForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsGetStatusForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientMigrationsGetStatusForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsGetStatusForAuthenticatedUserHandleResponse(resp)
}

// migrationsGetStatusForAuthenticatedUserCreateRequest creates the MigrationsGetStatusForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) migrationsGetStatusForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsGetStatusForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/migrations/{migration_id}"
	urlPath = strings.ReplaceAll(urlPath, "{migration_id}", url.PathEscape(strconv.FormatInt(int64(client.migrationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Exclude != nil {
		reqQP.Set("exclude", strings.Join(options.Exclude, ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// migrationsGetStatusForAuthenticatedUserHandleResponse handles the MigrationsGetStatusForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) migrationsGetStatusForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsGetStatusForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsGetStatusForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Migration
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsGetStatusForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsGetStatusForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsGetStatusForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsGetStatusForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientMigrationsGetStatusForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// MigrationsGetStatusForOrg - Fetches the status of a migration.
// The state of a migration can be one of the following values:
// * pending, which means the migration hasn't started yet.
// * exporting, which means the migration is in progress.
// * exported, which means the migration finished successfully.
// * failed, which means the migration failed.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsGetStatusForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsGetStatusForOrg
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsGetStatusForOrg(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsGetStatusForOrgOptions) (GitHubV3RESTAPIClientMigrationsGetStatusForOrgResponse, error) {
	req, err := client.migrationsGetStatusForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsGetStatusForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsGetStatusForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientMigrationsGetStatusForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsGetStatusForOrgHandleResponse(resp)
}

// migrationsGetStatusForOrgCreateRequest creates the MigrationsGetStatusForOrg request.
func (client *GitHubV3RESTAPIClient) migrationsGetStatusForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsGetStatusForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/migrations/{migration_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{migration_id}", url.PathEscape(strconv.FormatInt(int64(client.migrationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Exclude != nil {
		reqQP.Set("exclude", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.Exclude), "[]")), ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// migrationsGetStatusForOrgHandleResponse handles the MigrationsGetStatusForOrg response.
func (client *GitHubV3RESTAPIClient) migrationsGetStatusForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsGetStatusForOrgResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsGetStatusForOrgResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Migration
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsGetStatusForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsGetStatusForOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientMigrationsGetStatusForOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// MigrationsListForAuthenticatedUser - Lists all migrations a user has started.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsListForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsListForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsListForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsListForAuthenticatedUserOptions) (GitHubV3RESTAPIClientMigrationsListForAuthenticatedUserResponse, error) {
	req, err := client.migrationsListForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsListForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsListForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientMigrationsListForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsListForAuthenticatedUserHandleResponse(resp)
}

// migrationsListForAuthenticatedUserCreateRequest creates the MigrationsListForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) migrationsListForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsListForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/migrations"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// migrationsListForAuthenticatedUserHandleResponse handles the MigrationsListForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) migrationsListForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsListForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsListForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Migration
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientMigrationsListForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// MigrationsListForOrg - Lists the most recent migrations, including both exports (which can be started through the REST
// API) and imports (which cannot be started using the REST API).
// A list of repositories is only returned for export migrations.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsListForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsListForOrg
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsListForOrg(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsListForOrgOptions) (GitHubV3RESTAPIClientMigrationsListForOrgResponse, error) {
	req, err := client.migrationsListForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsListForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsListForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientMigrationsListForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsListForOrgHandleResponse(resp)
}

// migrationsListForOrgCreateRequest creates the MigrationsListForOrg request.
func (client *GitHubV3RESTAPIClient) migrationsListForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsListForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/migrations"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if options != nil && options.Exclude != nil {
		reqQP.Set("exclude", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.Exclude), "[]")), ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// migrationsListForOrgHandleResponse handles the MigrationsListForOrg response.
func (client *GitHubV3RESTAPIClient) migrationsListForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsListForOrgResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsListForOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.MigrationArray); err != nil {
		return GitHubV3RESTAPIClientMigrationsListForOrgResponse{}, err
	}
	return result, nil
}

// MigrationsListReposForAuthenticatedUser - Lists all the repositories for this user migration.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsListReposForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.MigrationsListReposForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) MigrationsListReposForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsListReposForAuthenticatedUserOptions) (GitHubV3RESTAPIClientMigrationsListReposForAuthenticatedUserResponse, error) {
	req, err := client.migrationsListReposForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsListReposForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsListReposForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientMigrationsListReposForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsListReposForAuthenticatedUserHandleResponse(resp)
}

// migrationsListReposForAuthenticatedUserCreateRequest creates the MigrationsListReposForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) migrationsListReposForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsListReposForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/migrations/{migration_id}/repositories"
	urlPath = strings.ReplaceAll(urlPath, "{migration_id}", url.PathEscape(strconv.FormatInt(int64(client.migrationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// migrationsListReposForAuthenticatedUserHandleResponse handles the MigrationsListReposForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) migrationsListReposForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsListReposForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsListReposForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*MinimalRepository
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsListReposForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsListReposForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientMigrationsListReposForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// MigrationsListReposForOrg - List all the repositories for this organization migration.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsListReposForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsListReposForOrg
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsListReposForOrg(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsListReposForOrgOptions) (GitHubV3RESTAPIClientMigrationsListReposForOrgResponse, error) {
	req, err := client.migrationsListReposForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsListReposForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsListReposForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientMigrationsListReposForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsListReposForOrgHandleResponse(resp)
}

// migrationsListReposForOrgCreateRequest creates the MigrationsListReposForOrg request.
func (client *GitHubV3RESTAPIClient) migrationsListReposForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsListReposForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/migrations/{migration_id}/repositories"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{migration_id}", url.PathEscape(strconv.FormatInt(int64(client.migrationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// migrationsListReposForOrgHandleResponse handles the MigrationsListReposForOrg response.
func (client *GitHubV3RESTAPIClient) migrationsListReposForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsListReposForOrgResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsListReposForOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*MinimalRepository
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsListReposForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsListReposForOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientMigrationsListReposForOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// MigrationsMapCommitAuthor - Update an author's identity for the import. Your application can continue updating authors
// any time before you push new commits to the repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsMapCommitAuthorOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsMapCommitAuthor
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsMapCommitAuthor(ctx context.Context, authorID int32, body PathsGlpsnqReposOwnerRepoImportAuthorsAuthorIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientMigrationsMapCommitAuthorOptions) (GitHubV3RESTAPIClientMigrationsMapCommitAuthorResponse, error) {
	req, err := client.migrationsMapCommitAuthorCreateRequest(ctx, authorID, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsMapCommitAuthorResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsMapCommitAuthorResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientMigrationsMapCommitAuthorResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsMapCommitAuthorHandleResponse(resp)
}

// migrationsMapCommitAuthorCreateRequest creates the MigrationsMapCommitAuthor request.
func (client *GitHubV3RESTAPIClient) migrationsMapCommitAuthorCreateRequest(ctx context.Context, authorID int32, body PathsGlpsnqReposOwnerRepoImportAuthorsAuthorIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientMigrationsMapCommitAuthorOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/import/authors/{author_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{author_id}", url.PathEscape(strconv.FormatInt(int64(authorID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// migrationsMapCommitAuthorHandleResponse handles the MigrationsMapCommitAuthor response.
func (client *GitHubV3RESTAPIClient) migrationsMapCommitAuthorHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsMapCommitAuthorResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsMapCommitAuthorResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PorterAuthor
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsMapCommitAuthorResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsMapCommitAuthorResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsMapCommitAuthorResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsMapCommitAuthorResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientMigrationsMapCommitAuthorResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// MigrationsSetLfsPreference - You can import repositories from Subversion, Mercurial, and TFS that include files larger
// than 100MB. This ability is powered by Git LFS [https://git-lfs.github.com]. You can learn more about our LFS
// feature and working with large files on our help site [https://docs.github.com/articles/versioning-large-files/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsSetLfsPreferenceOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsSetLfsPreference
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsSetLfsPreference(ctx context.Context, body Paths1Pk0FbvReposOwnerRepoImportLfsPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientMigrationsSetLfsPreferenceOptions) (GitHubV3RESTAPIClientMigrationsSetLfsPreferenceResponse, error) {
	req, err := client.migrationsSetLfsPreferenceCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsSetLfsPreferenceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsSetLfsPreferenceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientMigrationsSetLfsPreferenceResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsSetLfsPreferenceHandleResponse(resp)
}

// migrationsSetLfsPreferenceCreateRequest creates the MigrationsSetLfsPreference request.
func (client *GitHubV3RESTAPIClient) migrationsSetLfsPreferenceCreateRequest(ctx context.Context, body Paths1Pk0FbvReposOwnerRepoImportLfsPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientMigrationsSetLfsPreferenceOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/import/lfs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// migrationsSetLfsPreferenceHandleResponse handles the MigrationsSetLfsPreference response.
func (client *GitHubV3RESTAPIClient) migrationsSetLfsPreferenceHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsSetLfsPreferenceResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsSetLfsPreferenceResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Import
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsSetLfsPreferenceResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsSetLfsPreferenceResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsSetLfsPreferenceResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientMigrationsSetLfsPreferenceResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// MigrationsStartForAuthenticatedUser - Initiates the generation of a user migration archive.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsStartForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsStartForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsStartForAuthenticatedUser(ctx context.Context, body PathsYvzodUserMigrationsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientMigrationsStartForAuthenticatedUserOptions) (GitHubV3RESTAPIClientMigrationsStartForAuthenticatedUserResponse, error) {
	req, err := client.migrationsStartForAuthenticatedUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsStartForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsStartForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientMigrationsStartForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsStartForAuthenticatedUserHandleResponse(resp)
}

// migrationsStartForAuthenticatedUserCreateRequest creates the MigrationsStartForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) migrationsStartForAuthenticatedUserCreateRequest(ctx context.Context, body PathsYvzodUserMigrationsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientMigrationsStartForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/migrations"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// migrationsStartForAuthenticatedUserHandleResponse handles the MigrationsStartForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) migrationsStartForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsStartForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsStartForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Migration
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsStartForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsStartForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsStartForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsStartForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientMigrationsStartForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// MigrationsStartForOrg - Initiates the generation of a migration archive.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsStartForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsStartForOrg
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsStartForOrg(ctx context.Context, body Paths1Jz2FqtOrgsOrgMigrationsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientMigrationsStartForOrgOptions) (GitHubV3RESTAPIClientMigrationsStartForOrgResponse, error) {
	req, err := client.migrationsStartForOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsStartForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsStartForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientMigrationsStartForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsStartForOrgHandleResponse(resp)
}

// migrationsStartForOrgCreateRequest creates the MigrationsStartForOrg request.
func (client *GitHubV3RESTAPIClient) migrationsStartForOrgCreateRequest(ctx context.Context, body Paths1Jz2FqtOrgsOrgMigrationsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientMigrationsStartForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/migrations"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// migrationsStartForOrgHandleResponse handles the MigrationsStartForOrg response.
func (client *GitHubV3RESTAPIClient) migrationsStartForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsStartForOrgResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsStartForOrgResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Migration
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsStartForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsStartForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsStartForOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientMigrationsStartForOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// MigrationsStartImport - Start a source import to a GitHub repository using GitHub Importer.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsStartImportOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsStartImport
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsStartImport(ctx context.Context, body Paths19S09RvReposOwnerRepoImportPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientMigrationsStartImportOptions) (GitHubV3RESTAPIClientMigrationsStartImportResponse, error) {
	req, err := client.migrationsStartImportCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsStartImportResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsStartImportResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotFound, http.StatusUnprocessableEntity, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientMigrationsStartImportResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsStartImportHandleResponse(resp)
}

// migrationsStartImportCreateRequest creates the MigrationsStartImport request.
func (client *GitHubV3RESTAPIClient) migrationsStartImportCreateRequest(ctx context.Context, body Paths19S09RvReposOwnerRepoImportPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientMigrationsStartImportOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/import"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// migrationsStartImportHandleResponse handles the MigrationsStartImport response.
func (client *GitHubV3RESTAPIClient) migrationsStartImportHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsStartImportResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsStartImportResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Import
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsStartImportResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsStartImportResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsStartImportResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsStartImportResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientMigrationsStartImportResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// MigrationsUnlockRepoForAuthenticatedUser - Unlocks a repository. You can lock repositories when you start a user migration
// [https://docs.github.com/rest/reference/migrations#start-a-user-migration]. Once the migration is complete you can
// unlock each repository to begin using it again or delete the repository [https://docs.github.com/rest/reference/repos#delete-a-repository]
// if you no longer need the source data. Returns a status of
// 404 Not Found if the repository is not locked.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsUnlockRepoForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.MigrationsUnlockRepoForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) MigrationsUnlockRepoForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsUnlockRepoForAuthenticatedUserOptions) (GitHubV3RESTAPIClientMigrationsUnlockRepoForAuthenticatedUserResponse, error) {
	req, err := client.migrationsUnlockRepoForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsUnlockRepoForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsUnlockRepoForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientMigrationsUnlockRepoForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsUnlockRepoForAuthenticatedUserHandleResponse(resp)
}

// migrationsUnlockRepoForAuthenticatedUserCreateRequest creates the MigrationsUnlockRepoForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) migrationsUnlockRepoForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsUnlockRepoForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/migrations/{migration_id}/repos/{repo_name}/lock"
	urlPath = strings.ReplaceAll(urlPath, "{migration_id}", url.PathEscape(strconv.FormatInt(int64(client.migrationID), 10)))
	if client.repoName == "" {
		return nil, errors.New("parameter client.repoName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo_name}", url.PathEscape(client.repoName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// migrationsUnlockRepoForAuthenticatedUserHandleResponse handles the MigrationsUnlockRepoForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) migrationsUnlockRepoForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsUnlockRepoForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsUnlockRepoForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientMigrationsUnlockRepoForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// MigrationsUnlockRepoForOrg - Unlocks a repository that was locked for migration. You should unlock each migrated repository
// and delete them [https://docs.github.com/rest/reference/repos#delete-a-repository] when the migration is
// complete and you no longer need the source data.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsUnlockRepoForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsUnlockRepoForOrg
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsUnlockRepoForOrg(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsUnlockRepoForOrgOptions) (GitHubV3RESTAPIClientMigrationsUnlockRepoForOrgResponse, error) {
	req, err := client.migrationsUnlockRepoForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsUnlockRepoForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsUnlockRepoForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientMigrationsUnlockRepoForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsUnlockRepoForOrgHandleResponse(resp)
}

// migrationsUnlockRepoForOrgCreateRequest creates the MigrationsUnlockRepoForOrg request.
func (client *GitHubV3RESTAPIClient) migrationsUnlockRepoForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientMigrationsUnlockRepoForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{migration_id}", url.PathEscape(strconv.FormatInt(int64(client.migrationID), 10)))
	if client.repoName == "" {
		return nil, errors.New("parameter client.repoName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo_name}", url.PathEscape(client.repoName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// migrationsUnlockRepoForOrgHandleResponse handles the MigrationsUnlockRepoForOrg response.
func (client *GitHubV3RESTAPIClient) migrationsUnlockRepoForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsUnlockRepoForOrgResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsUnlockRepoForOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientMigrationsUnlockRepoForOrgResponse{}, err
	}
	return result, nil
}

// MigrationsUpdateImport - An import can be updated with credentials or a project choice by passing in the appropriate parameters
// in this API request. If no parameters are provided, the import will be restarted.
// Some servers (e.g. TFS servers) can have several projects at a single URL. In those cases the import progress will have
// the status detectionfoundmultiple and the Import Progress response will include
// a projectchoices array. You can select the project to import by providing one of the objects in the projectchoices array
// in the update request.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientMigrationsUpdateImportOptions contains the optional parameters for the GitHubV3RESTAPIClient.MigrationsUpdateImport
//     method.
func (client *GitHubV3RESTAPIClient) MigrationsUpdateImport(ctx context.Context, body Paths1Iaoy4IReposOwnerRepoImportPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientMigrationsUpdateImportOptions) (GitHubV3RESTAPIClientMigrationsUpdateImportResponse, error) {
	req, err := client.migrationsUpdateImportCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsUpdateImportResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientMigrationsUpdateImportResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientMigrationsUpdateImportResponse{}, runtime.NewResponseError(resp)
	}
	return client.migrationsUpdateImportHandleResponse(resp)
}

// migrationsUpdateImportCreateRequest creates the MigrationsUpdateImport request.
func (client *GitHubV3RESTAPIClient) migrationsUpdateImportCreateRequest(ctx context.Context, body Paths1Iaoy4IReposOwnerRepoImportPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientMigrationsUpdateImportOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/import"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// migrationsUpdateImportHandleResponse handles the MigrationsUpdateImport response.
func (client *GitHubV3RESTAPIClient) migrationsUpdateImportHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientMigrationsUpdateImportResponse, error) {
	result := GitHubV3RESTAPIClientMigrationsUpdateImportResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Import
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsUpdateImportResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientMigrationsUpdateImportResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientMigrationsUpdateImportResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OidcGetOidcCustomSubTemplateForOrg - Gets the customization template for an OpenID Connect (OIDC) subject claim. You must
// authenticate using an access token with the read:org scope to use this endpoint. GitHub Apps must have the
// organization_administration:write permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOidcGetOidcCustomSubTemplateForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.OidcGetOidcCustomSubTemplateForOrg
//     method.
func (client *GitHubV3RESTAPIClient) OidcGetOidcCustomSubTemplateForOrg(ctx context.Context, options *GitHubV3RESTAPIClientOidcGetOidcCustomSubTemplateForOrgOptions) (GitHubV3RESTAPIClientOidcGetOidcCustomSubTemplateForOrgResponse, error) {
	req, err := client.oidcGetOidcCustomSubTemplateForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOidcGetOidcCustomSubTemplateForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOidcGetOidcCustomSubTemplateForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientOidcGetOidcCustomSubTemplateForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.oidcGetOidcCustomSubTemplateForOrgHandleResponse(resp)
}

// oidcGetOidcCustomSubTemplateForOrgCreateRequest creates the OidcGetOidcCustomSubTemplateForOrg request.
func (client *GitHubV3RESTAPIClient) oidcGetOidcCustomSubTemplateForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOidcGetOidcCustomSubTemplateForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/oidc/customization/sub"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// oidcGetOidcCustomSubTemplateForOrgHandleResponse handles the OidcGetOidcCustomSubTemplateForOrg response.
func (client *GitHubV3RESTAPIClient) oidcGetOidcCustomSubTemplateForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOidcGetOidcCustomSubTemplateForOrgResponse, error) {
	result := GitHubV3RESTAPIClientOidcGetOidcCustomSubTemplateForOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.OidcCustomSub); err != nil {
		return GitHubV3RESTAPIClientOidcGetOidcCustomSubTemplateForOrgResponse{}, err
	}
	return result, nil
}

// OidcUpdateOidcCustomSubTemplateForOrg - Creates or updates the customization template for an OpenID Connect (OIDC) subject
// claim. You must authenticate using an access token with the write:org scope to use this endpoint. GitHub Apps must
// have the admin:org permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOidcUpdateOidcCustomSubTemplateForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.OidcUpdateOidcCustomSubTemplateForOrg
//     method.
func (client *GitHubV3RESTAPIClient) OidcUpdateOidcCustomSubTemplateForOrg(ctx context.Context, body OidcCustomSub, options *GitHubV3RESTAPIClientOidcUpdateOidcCustomSubTemplateForOrgOptions) (GitHubV3RESTAPIClientOidcUpdateOidcCustomSubTemplateForOrgResponse, error) {
	req, err := client.oidcUpdateOidcCustomSubTemplateForOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientOidcUpdateOidcCustomSubTemplateForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOidcUpdateOidcCustomSubTemplateForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientOidcUpdateOidcCustomSubTemplateForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.oidcUpdateOidcCustomSubTemplateForOrgHandleResponse(resp)
}

// oidcUpdateOidcCustomSubTemplateForOrgCreateRequest creates the OidcUpdateOidcCustomSubTemplateForOrg request.
func (client *GitHubV3RESTAPIClient) oidcUpdateOidcCustomSubTemplateForOrgCreateRequest(ctx context.Context, body OidcCustomSub, options *GitHubV3RESTAPIClientOidcUpdateOidcCustomSubTemplateForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/actions/oidc/customization/sub"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// oidcUpdateOidcCustomSubTemplateForOrgHandleResponse handles the OidcUpdateOidcCustomSubTemplateForOrg response.
func (client *GitHubV3RESTAPIClient) oidcUpdateOidcCustomSubTemplateForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOidcUpdateOidcCustomSubTemplateForOrgResponse, error) {
	result := GitHubV3RESTAPIClientOidcUpdateOidcCustomSubTemplateForOrgResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOidcUpdateOidcCustomSubTemplateForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOidcUpdateOidcCustomSubTemplateForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOidcUpdateOidcCustomSubTemplateForOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOidcUpdateOidcCustomSubTemplateForOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsAddSecurityManagerTeam - Adds a team as a security manager for an organization. For more information, see "Managing
// security for an organization
// [https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization]
// for an organization."
// To use this endpoint, you must be an administrator for the organization, and you must use an access token with the write:org
// scope.
// GitHub Apps must have the administration organization read-write permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsAddSecurityManagerTeamOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsAddSecurityManagerTeam
//     method.
func (client *GitHubV3RESTAPIClient) OrgsAddSecurityManagerTeam(ctx context.Context, options *GitHubV3RESTAPIClientOrgsAddSecurityManagerTeamOptions) (GitHubV3RESTAPIClientOrgsAddSecurityManagerTeamResponse, error) {
	req, err := client.orgsAddSecurityManagerTeamCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsAddSecurityManagerTeamResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsAddSecurityManagerTeamResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusConflict) {
		return GitHubV3RESTAPIClientOrgsAddSecurityManagerTeamResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientOrgsAddSecurityManagerTeamResponse{}, nil
}

// orgsAddSecurityManagerTeamCreateRequest creates the OrgsAddSecurityManagerTeam request.
func (client *GitHubV3RESTAPIClient) orgsAddSecurityManagerTeamCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsAddSecurityManagerTeamOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/security-managers/teams/{team_slug}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// OrgsBlockUser - Block a user from an organization
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsBlockUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsBlockUser
//     method.
func (client *GitHubV3RESTAPIClient) OrgsBlockUser(ctx context.Context, options *GitHubV3RESTAPIClientOrgsBlockUserOptions) (GitHubV3RESTAPIClientOrgsBlockUserResponse, error) {
	req, err := client.orgsBlockUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsBlockUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsBlockUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientOrgsBlockUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsBlockUserHandleResponse(resp)
}

// orgsBlockUserCreateRequest creates the OrgsBlockUser request.
func (client *GitHubV3RESTAPIClient) orgsBlockUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsBlockUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/blocks/{username}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsBlockUserHandleResponse handles the OrgsBlockUser response.
func (client *GitHubV3RESTAPIClient) orgsBlockUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsBlockUserResponse, error) {
	result := GitHubV3RESTAPIClientOrgsBlockUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ValidationError); err != nil {
		return GitHubV3RESTAPIClientOrgsBlockUserResponse{}, err
	}
	return result, nil
}

// OrgsCancelInvitation - Cancel an organization invitation. In order to cancel an organization invitation, the authenticated
// user must be an organization owner.
// This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsCancelInvitationOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsCancelInvitation
//     method.
func (client *GitHubV3RESTAPIClient) OrgsCancelInvitation(ctx context.Context, options *GitHubV3RESTAPIClientOrgsCancelInvitationOptions) (GitHubV3RESTAPIClientOrgsCancelInvitationResponse, error) {
	req, err := client.orgsCancelInvitationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsCancelInvitationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsCancelInvitationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientOrgsCancelInvitationResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsCancelInvitationHandleResponse(resp)
}

// orgsCancelInvitationCreateRequest creates the OrgsCancelInvitation request.
func (client *GitHubV3RESTAPIClient) orgsCancelInvitationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsCancelInvitationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/invitations/{invitation_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{invitation_id}", url.PathEscape(strconv.FormatInt(int64(client.invitationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsCancelInvitationHandleResponse handles the OrgsCancelInvitation response.
func (client *GitHubV3RESTAPIClient) orgsCancelInvitationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsCancelInvitationResponse, error) {
	result := GitHubV3RESTAPIClientOrgsCancelInvitationResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsCancelInvitationResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsCancelInvitationResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsCancelInvitationResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsCheckBlockedUser - Check if a user is blocked by an organization
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsCheckBlockedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsCheckBlockedUser
//     method.
func (client *GitHubV3RESTAPIClient) OrgsCheckBlockedUser(ctx context.Context, options *GitHubV3RESTAPIClientOrgsCheckBlockedUserOptions) (GitHubV3RESTAPIClientOrgsCheckBlockedUserResponse, error) {
	req, err := client.orgsCheckBlockedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsCheckBlockedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsCheckBlockedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientOrgsCheckBlockedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsCheckBlockedUserHandleResponse(resp)
}

// orgsCheckBlockedUserCreateRequest creates the OrgsCheckBlockedUser request.
func (client *GitHubV3RESTAPIClient) orgsCheckBlockedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsCheckBlockedUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/blocks/{username}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsCheckBlockedUserHandleResponse handles the OrgsCheckBlockedUser response.
func (client *GitHubV3RESTAPIClient) orgsCheckBlockedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsCheckBlockedUserResponse, error) {
	result := GitHubV3RESTAPIClientOrgsCheckBlockedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientOrgsCheckBlockedUserResponse{}, err
	}
	return result, nil
}

// OrgsCheckMembershipForUser - Check if a user is, publicly or privately, a member of the organization.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsCheckMembershipForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsCheckMembershipForUser
//     method.
func (client *GitHubV3RESTAPIClient) OrgsCheckMembershipForUser(ctx context.Context, options *GitHubV3RESTAPIClientOrgsCheckMembershipForUserOptions) (GitHubV3RESTAPIClientOrgsCheckMembershipForUserResponse, error) {
	req, err := client.orgsCheckMembershipForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsCheckMembershipForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsCheckMembershipForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientOrgsCheckMembershipForUserResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientOrgsCheckMembershipForUserResponse{}, nil
}

// orgsCheckMembershipForUserCreateRequest creates the OrgsCheckMembershipForUser request.
func (client *GitHubV3RESTAPIClient) orgsCheckMembershipForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsCheckMembershipForUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/members/{username}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// OrgsCheckPublicMembershipForUser - Check public organization membership for a user
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsCheckPublicMembershipForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsCheckPublicMembershipForUser
//     method.
func (client *GitHubV3RESTAPIClient) OrgsCheckPublicMembershipForUser(ctx context.Context, options *GitHubV3RESTAPIClientOrgsCheckPublicMembershipForUserOptions) (GitHubV3RESTAPIClientOrgsCheckPublicMembershipForUserResponse, error) {
	req, err := client.orgsCheckPublicMembershipForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsCheckPublicMembershipForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsCheckPublicMembershipForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientOrgsCheckPublicMembershipForUserResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientOrgsCheckPublicMembershipForUserResponse{}, nil
}

// orgsCheckPublicMembershipForUserCreateRequest creates the OrgsCheckPublicMembershipForUser request.
func (client *GitHubV3RESTAPIClient) orgsCheckPublicMembershipForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsCheckPublicMembershipForUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/public_members/{username}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// OrgsConvertMemberToOutsideCollaborator - When an organization member is converted to an outside collaborator, they'll only
// have access to the repositories that their current team membership allows. The user will no longer be a member of the
// organization. For more information, see "Converting an organization member to an outside collaborator [https://docs.github.com/articles/converting-an-organization-member-to-an-outside-collaborator/]".
// Converting an organization member to an outside collaborator may be restricted by enterprise administrators. For more information,
// see "Enforcing repository management policies in your enterprise
// [https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories]
// ."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsConvertMemberToOutsideCollaboratorOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsConvertMemberToOutsideCollaborator
//     method.
func (client *GitHubV3RESTAPIClient) OrgsConvertMemberToOutsideCollaborator(ctx context.Context, body Paths1R8N665OrgsOrgOutsideCollaboratorsUsernamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientOrgsConvertMemberToOutsideCollaboratorOptions) (GitHubV3RESTAPIClientOrgsConvertMemberToOutsideCollaboratorResponse, error) {
	req, err := client.orgsConvertMemberToOutsideCollaboratorCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsConvertMemberToOutsideCollaboratorResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsConvertMemberToOutsideCollaboratorResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientOrgsConvertMemberToOutsideCollaboratorResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsConvertMemberToOutsideCollaboratorHandleResponse(resp)
}

// orgsConvertMemberToOutsideCollaboratorCreateRequest creates the OrgsConvertMemberToOutsideCollaborator request.
func (client *GitHubV3RESTAPIClient) orgsConvertMemberToOutsideCollaboratorCreateRequest(ctx context.Context, body Paths1R8N665OrgsOrgOutsideCollaboratorsUsernamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientOrgsConvertMemberToOutsideCollaboratorOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/outside_collaborators/{username}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// orgsConvertMemberToOutsideCollaboratorHandleResponse handles the OrgsConvertMemberToOutsideCollaborator response.
func (client *GitHubV3RESTAPIClient) orgsConvertMemberToOutsideCollaboratorHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsConvertMemberToOutsideCollaboratorResponse, error) {
	result := GitHubV3RESTAPIClientOrgsConvertMemberToOutsideCollaboratorResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsConvertMemberToOutsideCollaboratorResponse{}, err
	}
	result.Value = val
	case http.StatusNoContent:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsConvertMemberToOutsideCollaboratorResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsConvertMemberToOutsideCollaboratorResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsCreateInvitation - Invite people to an organization by using their GitHub user ID or their email address. In order
// to create invitations in an organization, the authenticated user must be an organization owner.
// This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// Creating content too quickly using this endpoint may
// result in secondary rate limiting. See "Secondary rate limits [https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits]"
// and "Dealing with secondary rate limits
// [https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits]" for details.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsCreateInvitationOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsCreateInvitation
//     method.
func (client *GitHubV3RESTAPIClient) OrgsCreateInvitation(ctx context.Context, options *GitHubV3RESTAPIClientOrgsCreateInvitationOptions) (GitHubV3RESTAPIClientOrgsCreateInvitationResponse, error) {
	req, err := client.orgsCreateInvitationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsCreateInvitationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsCreateInvitationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientOrgsCreateInvitationResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsCreateInvitationHandleResponse(resp)
}

// orgsCreateInvitationCreateRequest creates the OrgsCreateInvitation request.
func (client *GitHubV3RESTAPIClient) orgsCreateInvitationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsCreateInvitationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/invitations"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// orgsCreateInvitationHandleResponse handles the OrgsCreateInvitation response.
func (client *GitHubV3RESTAPIClient) orgsCreateInvitationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsCreateInvitationResponse, error) {
	result := GitHubV3RESTAPIClientOrgsCreateInvitationResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val OrganizationInvitation
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsCreateInvitationResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsCreateInvitationResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsCreateInvitationResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsCreateInvitationResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsCreateWebhook - Here's how you can create a hook that posts payloads in JSON format:
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsCreateWebhookOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsCreateWebhook
//     method.
func (client *GitHubV3RESTAPIClient) OrgsCreateWebhook(ctx context.Context, body Paths8XkywmOrgsOrgHooksPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientOrgsCreateWebhookOptions) (GitHubV3RESTAPIClientOrgsCreateWebhookResponse, error) {
	req, err := client.orgsCreateWebhookCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsCreateWebhookResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsCreateWebhookResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientOrgsCreateWebhookResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsCreateWebhookHandleResponse(resp)
}

// orgsCreateWebhookCreateRequest creates the OrgsCreateWebhook request.
func (client *GitHubV3RESTAPIClient) orgsCreateWebhookCreateRequest(ctx context.Context, body Paths8XkywmOrgsOrgHooksPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientOrgsCreateWebhookOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/hooks"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// orgsCreateWebhookHandleResponse handles the OrgsCreateWebhook response.
func (client *GitHubV3RESTAPIClient) orgsCreateWebhookHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsCreateWebhookResponse, error) {
	result := GitHubV3RESTAPIClientOrgsCreateWebhookResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val OrgHook
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsCreateWebhookResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsCreateWebhookResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsCreateWebhookResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsCreateWebhookResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsDeleteWebhook - Delete an organization webhook
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsDeleteWebhookOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsDeleteWebhook
//     method.
func (client *GitHubV3RESTAPIClient) OrgsDeleteWebhook(ctx context.Context, options *GitHubV3RESTAPIClientOrgsDeleteWebhookOptions) (GitHubV3RESTAPIClientOrgsDeleteWebhookResponse, error) {
	req, err := client.orgsDeleteWebhookCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsDeleteWebhookResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsDeleteWebhookResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientOrgsDeleteWebhookResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsDeleteWebhookHandleResponse(resp)
}

// orgsDeleteWebhookCreateRequest creates the OrgsDeleteWebhook request.
func (client *GitHubV3RESTAPIClient) orgsDeleteWebhookCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsDeleteWebhookOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/hooks/{hook_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsDeleteWebhookHandleResponse handles the OrgsDeleteWebhook response.
func (client *GitHubV3RESTAPIClient) orgsDeleteWebhookHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsDeleteWebhookResponse, error) {
	result := GitHubV3RESTAPIClientOrgsDeleteWebhookResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientOrgsDeleteWebhookResponse{}, err
	}
	return result, nil
}

// OrgsEnableOrDisableSecurityProductOnAllOrgRepos - Enables or disables the specified security feature for all repositories
// in an organization.
// To use this endpoint, you must be an organization owner or be member of a team with the security manager role. A token
// with the 'write:org' scope is also required.
// GitHub Apps must have the organization_administration:write permission to use this endpoint.
// For more information, see "Managing security managers in your organization
// [https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsEnableOrDisableSecurityProductOnAllOrgReposOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.OrgsEnableOrDisableSecurityProductOnAllOrgRepos method.
func (client *GitHubV3RESTAPIClient) OrgsEnableOrDisableSecurityProductOnAllOrgRepos(ctx context.Context, options *GitHubV3RESTAPIClientOrgsEnableOrDisableSecurityProductOnAllOrgReposOptions) (GitHubV3RESTAPIClientOrgsEnableOrDisableSecurityProductOnAllOrgReposResponse, error) {
	req, err := client.orgsEnableOrDisableSecurityProductOnAllOrgReposCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsEnableOrDisableSecurityProductOnAllOrgReposResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsEnableOrDisableSecurityProductOnAllOrgReposResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientOrgsEnableOrDisableSecurityProductOnAllOrgReposResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientOrgsEnableOrDisableSecurityProductOnAllOrgReposResponse{}, nil
}

// orgsEnableOrDisableSecurityProductOnAllOrgReposCreateRequest creates the OrgsEnableOrDisableSecurityProductOnAllOrgRepos request.
func (client *GitHubV3RESTAPIClient) orgsEnableOrDisableSecurityProductOnAllOrgReposCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsEnableOrDisableSecurityProductOnAllOrgReposOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/{security_product}/{enablement}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.securityProduct == "" {
		return nil, errors.New("parameter client.securityProduct cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{security_product}", url.PathEscape(string(client.securityProduct)))
	if client.enablement == "" {
		return nil, errors.New("parameter client.enablement cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{enablement}", url.PathEscape(string(client.enablement)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// OrgsGet - To see many of the organization response values, you need to be an authenticated organization owner with the
// admin:org scope. When the value of twofactorrequirement_enabled is true, the organization
// requires all members, billing managers, and outside collaborators to enable two-factor authentication [https://docs.github.com/articles/securing-your-account-with-two-factor-authentication-2fa/].
// GitHub Apps with the Organization plan permission can use this endpoint to retrieve information about an organization's
// GitHub plan. See "Authenticating with GitHub Apps
// [https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/]" for details. For an example response,
// see 'Response with GitHub plan information' below."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsGetOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsGet method.
func (client *GitHubV3RESTAPIClient) OrgsGet(ctx context.Context, options *GitHubV3RESTAPIClientOrgsGetOptions) (GitHubV3RESTAPIClientOrgsGetResponse, error) {
	req, err := client.orgsGetCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientOrgsGetResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsGetHandleResponse(resp)
}

// orgsGetCreateRequest creates the OrgsGet request.
func (client *GitHubV3RESTAPIClient) orgsGetCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsGetOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsGetHandleResponse handles the OrgsGet response.
func (client *GitHubV3RESTAPIClient) orgsGetHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsGetResponse, error) {
	result := GitHubV3RESTAPIClientOrgsGetResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val OrganizationFull
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsGetResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsGetResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsGetResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsGetMembershipForAuthenticatedUser - Get an organization membership for the authenticated user
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsGetMembershipForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsGetMembershipForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) OrgsGetMembershipForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientOrgsGetMembershipForAuthenticatedUserOptions) (GitHubV3RESTAPIClientOrgsGetMembershipForAuthenticatedUserResponse, error) {
	req, err := client.orgsGetMembershipForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsGetMembershipForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsGetMembershipForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientOrgsGetMembershipForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsGetMembershipForAuthenticatedUserHandleResponse(resp)
}

// orgsGetMembershipForAuthenticatedUserCreateRequest creates the OrgsGetMembershipForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) orgsGetMembershipForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsGetMembershipForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/memberships/orgs/{org}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsGetMembershipForAuthenticatedUserHandleResponse handles the OrgsGetMembershipForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) orgsGetMembershipForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsGetMembershipForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientOrgsGetMembershipForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val OrgMembership
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsGetMembershipForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsGetMembershipForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsGetMembershipForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsGetMembershipForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsGetMembershipForUser - In order to get a user's membership with an organization, the authenticated user must be an
// organization member. The state parameter in the response can be used to identify the user's membership
// status.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsGetMembershipForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsGetMembershipForUser
//     method.
func (client *GitHubV3RESTAPIClient) OrgsGetMembershipForUser(ctx context.Context, options *GitHubV3RESTAPIClientOrgsGetMembershipForUserOptions) (GitHubV3RESTAPIClientOrgsGetMembershipForUserResponse, error) {
	req, err := client.orgsGetMembershipForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsGetMembershipForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsGetMembershipForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientOrgsGetMembershipForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsGetMembershipForUserHandleResponse(resp)
}

// orgsGetMembershipForUserCreateRequest creates the OrgsGetMembershipForUser request.
func (client *GitHubV3RESTAPIClient) orgsGetMembershipForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsGetMembershipForUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/memberships/{username}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsGetMembershipForUserHandleResponse handles the OrgsGetMembershipForUser response.
func (client *GitHubV3RESTAPIClient) orgsGetMembershipForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsGetMembershipForUserResponse, error) {
	result := GitHubV3RESTAPIClientOrgsGetMembershipForUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val OrgMembership
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsGetMembershipForUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsGetMembershipForUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsGetMembershipForUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsGetMembershipForUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsGetWebhook - Returns a webhook configured in an organization. To get only the webhook config properties, see "Get a
// webhook configuration for an organization
// [/rest/reference/orgs#get-a-webhook-configuration-for-an-organization]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsGetWebhookOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsGetWebhook
//     method.
func (client *GitHubV3RESTAPIClient) OrgsGetWebhook(ctx context.Context, options *GitHubV3RESTAPIClientOrgsGetWebhookOptions) (GitHubV3RESTAPIClientOrgsGetWebhookResponse, error) {
	req, err := client.orgsGetWebhookCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsGetWebhookResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsGetWebhookResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientOrgsGetWebhookResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsGetWebhookHandleResponse(resp)
}

// orgsGetWebhookCreateRequest creates the OrgsGetWebhook request.
func (client *GitHubV3RESTAPIClient) orgsGetWebhookCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsGetWebhookOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/hooks/{hook_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsGetWebhookHandleResponse handles the OrgsGetWebhook response.
func (client *GitHubV3RESTAPIClient) orgsGetWebhookHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsGetWebhookResponse, error) {
	result := GitHubV3RESTAPIClientOrgsGetWebhookResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val OrgHook
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsGetWebhookResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsGetWebhookResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsGetWebhookResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsGetWebhookConfigForOrg - Returns the webhook configuration for an organization. To get more information about the webhook,
// including the active state and events, use "Get an organization webhook
// [/rest/reference/orgs#get-an-organization-webhook]."
// Access tokens must have the admin:orghook scope, and GitHub Apps must have the organizationhooks:read permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsGetWebhookConfigForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsGetWebhookConfigForOrg
//     method.
func (client *GitHubV3RESTAPIClient) OrgsGetWebhookConfigForOrg(ctx context.Context, options *GitHubV3RESTAPIClientOrgsGetWebhookConfigForOrgOptions) (GitHubV3RESTAPIClientOrgsGetWebhookConfigForOrgResponse, error) {
	req, err := client.orgsGetWebhookConfigForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsGetWebhookConfigForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsGetWebhookConfigForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientOrgsGetWebhookConfigForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsGetWebhookConfigForOrgHandleResponse(resp)
}

// orgsGetWebhookConfigForOrgCreateRequest creates the OrgsGetWebhookConfigForOrg request.
func (client *GitHubV3RESTAPIClient) orgsGetWebhookConfigForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsGetWebhookConfigForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/hooks/{hook_id}/config"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsGetWebhookConfigForOrgHandleResponse handles the OrgsGetWebhookConfigForOrg response.
func (client *GitHubV3RESTAPIClient) orgsGetWebhookConfigForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsGetWebhookConfigForOrgResponse, error) {
	result := GitHubV3RESTAPIClientOrgsGetWebhookConfigForOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebhookConfig); err != nil {
		return GitHubV3RESTAPIClientOrgsGetWebhookConfigForOrgResponse{}, err
	}
	return result, nil
}

// OrgsGetWebhookDelivery - Returns a delivery for a webhook configured in an organization.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsGetWebhookDeliveryOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsGetWebhookDelivery
//     method.
func (client *GitHubV3RESTAPIClient) OrgsGetWebhookDelivery(ctx context.Context, options *GitHubV3RESTAPIClientOrgsGetWebhookDeliveryOptions) (GitHubV3RESTAPIClientOrgsGetWebhookDeliveryResponse, error) {
	req, err := client.orgsGetWebhookDeliveryCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsGetWebhookDeliveryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsGetWebhookDeliveryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientOrgsGetWebhookDeliveryResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsGetWebhookDeliveryHandleResponse(resp)
}

// orgsGetWebhookDeliveryCreateRequest creates the OrgsGetWebhookDelivery request.
func (client *GitHubV3RESTAPIClient) orgsGetWebhookDeliveryCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsGetWebhookDeliveryOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{delivery_id}", url.PathEscape(strconv.FormatInt(int64(client.deliveryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// orgsGetWebhookDeliveryHandleResponse handles the OrgsGetWebhookDelivery response.
func (client *GitHubV3RESTAPIClient) orgsGetWebhookDeliveryHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsGetWebhookDeliveryResponse, error) {
	result := GitHubV3RESTAPIClientOrgsGetWebhookDeliveryResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val HookDelivery
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsGetWebhookDeliveryResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsGetWebhookDeliveryResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsGetWebhookDeliveryResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsGetWebhookDeliveryResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsList - Lists all organizations, in the order that they were created on GitHub.
// Note: Pagination is powered exclusively by the since parameter. Use the Link header [https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header]
// to get the URL for the next page of
// organizations.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsListOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsList
//     method.
func (client *GitHubV3RESTAPIClient) OrgsList(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListOptions) (GitHubV3RESTAPIClientOrgsListResponse, error) {
	req, err := client.orgsListCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified) {
		return GitHubV3RESTAPIClientOrgsListResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsListHandleResponse(resp)
}

// orgsListCreateRequest creates the OrgsList request.
func (client *GitHubV3RESTAPIClient) orgsListCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListOptions) (*policy.Request, error) {
	urlPath := "/organizations"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsListHandleResponse handles the OrgsList response.
func (client *GitHubV3RESTAPIClient) orgsListHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsListResponse, error) {
	result := GitHubV3RESTAPIClientOrgsListResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.OrganizationSimpleArray); err != nil {
		return GitHubV3RESTAPIClientOrgsListResponse{}, err
	}
	return result, nil
}

// OrgsListAppInstallations - Lists all GitHub Apps in an organization. The installation count includes all GitHub Apps installed
// on repositories in the organization. You must be an organization owner with admin:read scope to use
// this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsListAppInstallationsOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsListAppInstallations
//     method.
func (client *GitHubV3RESTAPIClient) OrgsListAppInstallations(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListAppInstallationsOptions) (GitHubV3RESTAPIClientOrgsListAppInstallationsResponse, error) {
	req, err := client.orgsListAppInstallationsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListAppInstallationsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListAppInstallationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientOrgsListAppInstallationsResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsListAppInstallationsHandleResponse(resp)
}

// orgsListAppInstallationsCreateRequest creates the OrgsListAppInstallations request.
func (client *GitHubV3RESTAPIClient) orgsListAppInstallationsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListAppInstallationsOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/installations"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsListAppInstallationsHandleResponse handles the OrgsListAppInstallations response.
func (client *GitHubV3RESTAPIClient) orgsListAppInstallationsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsListAppInstallationsResponse, error) {
	result := GitHubV3RESTAPIClientOrgsListAppInstallationsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1Msrxd9OrgsOrgInstallationsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientOrgsListAppInstallationsResponse{}, err
	}
	return result, nil
}

// OrgsListBlockedUsers - List the users blocked by an organization.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsListBlockedUsersOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsListBlockedUsers
//     method.
func (client *GitHubV3RESTAPIClient) OrgsListBlockedUsers(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListBlockedUsersOptions) (GitHubV3RESTAPIClientOrgsListBlockedUsersResponse, error) {
	req, err := client.orgsListBlockedUsersCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListBlockedUsersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListBlockedUsersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientOrgsListBlockedUsersResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsListBlockedUsersHandleResponse(resp)
}

// orgsListBlockedUsersCreateRequest creates the OrgsListBlockedUsers request.
func (client *GitHubV3RESTAPIClient) orgsListBlockedUsersCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListBlockedUsersOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/blocks"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsListBlockedUsersHandleResponse handles the OrgsListBlockedUsers response.
func (client *GitHubV3RESTAPIClient) orgsListBlockedUsersHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsListBlockedUsersResponse, error) {
	result := GitHubV3RESTAPIClientOrgsListBlockedUsersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SimpleUserArray); err != nil {
		return GitHubV3RESTAPIClientOrgsListBlockedUsersResponse{}, err
	}
	return result, nil
}

// OrgsListFailedInvitations - The return hash contains failedat and failedreason fields which represent the time at which
// the invitation failed and the reason for the failure.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsListFailedInvitationsOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsListFailedInvitations
//     method.
func (client *GitHubV3RESTAPIClient) OrgsListFailedInvitations(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListFailedInvitationsOptions) (GitHubV3RESTAPIClientOrgsListFailedInvitationsResponse, error) {
	req, err := client.orgsListFailedInvitationsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListFailedInvitationsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListFailedInvitationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientOrgsListFailedInvitationsResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsListFailedInvitationsHandleResponse(resp)
}

// orgsListFailedInvitationsCreateRequest creates the OrgsListFailedInvitations request.
func (client *GitHubV3RESTAPIClient) orgsListFailedInvitationsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListFailedInvitationsOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/failed_invitations"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsListFailedInvitationsHandleResponse handles the OrgsListFailedInvitations response.
func (client *GitHubV3RESTAPIClient) orgsListFailedInvitationsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsListFailedInvitationsResponse, error) {
	result := GitHubV3RESTAPIClientOrgsListFailedInvitationsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*OrganizationInvitation
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListFailedInvitationsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListFailedInvitationsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsListFailedInvitationsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsListForAuthenticatedUser - List organizations for the authenticated user.
// OAuth scope requirements
// This only lists organizations that your authorization allows you to operate on in some way (e.g., you can list teams with
// read:org scope, you can publicize your organization membership with user
// scope, etc.). Therefore, this API requires at least user or read:org scope. OAuth requests with insufficient scope receive
// a 403 Forbidden response.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsListForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsListForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) OrgsListForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListForAuthenticatedUserOptions) (GitHubV3RESTAPIClientOrgsListForAuthenticatedUserResponse, error) {
	req, err := client.orgsListForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientOrgsListForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsListForAuthenticatedUserHandleResponse(resp)
}

// orgsListForAuthenticatedUserCreateRequest creates the OrgsListForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) orgsListForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/orgs"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsListForAuthenticatedUserHandleResponse handles the OrgsListForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) orgsListForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsListForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientOrgsListForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*OrganizationSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsListForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsListForUser - List public organization memberships [https://docs.github.com/articles/publicizing-or-concealing-organization-membership]
// for the specified user.
// This method only lists public memberships, regardless of authentication. If you need to fetch all of the organization memberships
// (public and private) for the authenticated user, use the List
// organizations for the authenticated user [https://docs.github.com/rest/reference/orgs#list-organizations-for-the-authenticated-user]
// API instead.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsListForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsListForUser
//     method.
func (client *GitHubV3RESTAPIClient) OrgsListForUser(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListForUserOptions) (GitHubV3RESTAPIClientOrgsListForUserResponse, error) {
	req, err := client.orgsListForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientOrgsListForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsListForUserHandleResponse(resp)
}

// orgsListForUserCreateRequest creates the OrgsListForUser request.
func (client *GitHubV3RESTAPIClient) orgsListForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/orgs"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsListForUserHandleResponse handles the OrgsListForUser response.
func (client *GitHubV3RESTAPIClient) orgsListForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsListForUserResponse, error) {
	result := GitHubV3RESTAPIClientOrgsListForUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.OrganizationSimpleArray); err != nil {
		return GitHubV3RESTAPIClientOrgsListForUserResponse{}, err
	}
	return result, nil
}

// OrgsListInvitationTeams - List all teams associated with an invitation. In order to see invitations in an organization,
// the authenticated user must be an organization owner.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsListInvitationTeamsOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsListInvitationTeams
//     method.
func (client *GitHubV3RESTAPIClient) OrgsListInvitationTeams(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListInvitationTeamsOptions) (GitHubV3RESTAPIClientOrgsListInvitationTeamsResponse, error) {
	req, err := client.orgsListInvitationTeamsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListInvitationTeamsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListInvitationTeamsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientOrgsListInvitationTeamsResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsListInvitationTeamsHandleResponse(resp)
}

// orgsListInvitationTeamsCreateRequest creates the OrgsListInvitationTeams request.
func (client *GitHubV3RESTAPIClient) orgsListInvitationTeamsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListInvitationTeamsOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/invitations/{invitation_id}/teams"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{invitation_id}", url.PathEscape(strconv.FormatInt(int64(client.invitationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsListInvitationTeamsHandleResponse handles the OrgsListInvitationTeams response.
func (client *GitHubV3RESTAPIClient) orgsListInvitationTeamsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsListInvitationTeamsResponse, error) {
	result := GitHubV3RESTAPIClientOrgsListInvitationTeamsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Team
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListInvitationTeamsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListInvitationTeamsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsListInvitationTeamsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsListMembers - List all users who are members of an organization. If the authenticated user is also a member of this
// organization then both concealed and public members will be returned.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsListMembersOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsListMembers
//     method.
func (client *GitHubV3RESTAPIClient) OrgsListMembers(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListMembersOptions) (GitHubV3RESTAPIClientOrgsListMembersResponse, error) {
	req, err := client.orgsListMembersCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListMembersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListMembersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientOrgsListMembersResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsListMembersHandleResponse(resp)
}

// orgsListMembersCreateRequest creates the OrgsListMembers request.
func (client *GitHubV3RESTAPIClient) orgsListMembersCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListMembersOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/members"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", string(*options.Filter))
	}
	if options != nil && options.Role != nil {
		reqQP.Set("role", string(*options.Role))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsListMembersHandleResponse handles the OrgsListMembers response.
func (client *GitHubV3RESTAPIClient) orgsListMembersHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsListMembersResponse, error) {
	result := GitHubV3RESTAPIClientOrgsListMembersResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*SimpleUser
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListMembersResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListMembersResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsListMembersResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsListMembershipsForAuthenticatedUser - List organization memberships for the authenticated user
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsListMembershipsForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.OrgsListMembershipsForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) OrgsListMembershipsForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListMembershipsForAuthenticatedUserOptions) (GitHubV3RESTAPIClientOrgsListMembershipsForAuthenticatedUserResponse, error) {
	req, err := client.orgsListMembershipsForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListMembershipsForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListMembershipsForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientOrgsListMembershipsForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsListMembershipsForAuthenticatedUserHandleResponse(resp)
}

// orgsListMembershipsForAuthenticatedUserCreateRequest creates the OrgsListMembershipsForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) orgsListMembershipsForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListMembershipsForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/memberships/orgs"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.State != nil {
		reqQP.Set("state", string(*options.State))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsListMembershipsForAuthenticatedUserHandleResponse handles the OrgsListMembershipsForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) orgsListMembershipsForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsListMembershipsForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientOrgsListMembershipsForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*OrgMembership
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListMembershipsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListMembershipsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListMembershipsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListMembershipsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsListMembershipsForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsListOutsideCollaborators - List all users who are outside collaborators of an organization.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsListOutsideCollaboratorsOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsListOutsideCollaborators
//     method.
func (client *GitHubV3RESTAPIClient) OrgsListOutsideCollaborators(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListOutsideCollaboratorsOptions) (GitHubV3RESTAPIClientOrgsListOutsideCollaboratorsResponse, error) {
	req, err := client.orgsListOutsideCollaboratorsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListOutsideCollaboratorsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListOutsideCollaboratorsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientOrgsListOutsideCollaboratorsResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsListOutsideCollaboratorsHandleResponse(resp)
}

// orgsListOutsideCollaboratorsCreateRequest creates the OrgsListOutsideCollaborators request.
func (client *GitHubV3RESTAPIClient) orgsListOutsideCollaboratorsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListOutsideCollaboratorsOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/outside_collaborators"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", string(*options.Filter))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsListOutsideCollaboratorsHandleResponse handles the OrgsListOutsideCollaborators response.
func (client *GitHubV3RESTAPIClient) orgsListOutsideCollaboratorsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsListOutsideCollaboratorsResponse, error) {
	result := GitHubV3RESTAPIClientOrgsListOutsideCollaboratorsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.SimpleUserArray); err != nil {
		return GitHubV3RESTAPIClientOrgsListOutsideCollaboratorsResponse{}, err
	}
	return result, nil
}

// OrgsListPendingInvitations - The return hash contains a role field which refers to the Organization Invitation role and
// will be one of the following values: directmember, admin, billingmanager, or hiring_manager. If the invitee
// is not a GitHub member, the login field in the return hash will be null.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsListPendingInvitationsOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsListPendingInvitations
//     method.
func (client *GitHubV3RESTAPIClient) OrgsListPendingInvitations(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListPendingInvitationsOptions) (GitHubV3RESTAPIClientOrgsListPendingInvitationsResponse, error) {
	req, err := client.orgsListPendingInvitationsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListPendingInvitationsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListPendingInvitationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientOrgsListPendingInvitationsResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsListPendingInvitationsHandleResponse(resp)
}

// orgsListPendingInvitationsCreateRequest creates the OrgsListPendingInvitations request.
func (client *GitHubV3RESTAPIClient) orgsListPendingInvitationsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListPendingInvitationsOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/invitations"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if options != nil && options.Role != nil {
		reqQP.Set("role", string(*options.Role))
	}
	if options != nil && options.InvitationSource != nil {
		reqQP.Set("invitation_source", string(*options.InvitationSource))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsListPendingInvitationsHandleResponse handles the OrgsListPendingInvitations response.
func (client *GitHubV3RESTAPIClient) orgsListPendingInvitationsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsListPendingInvitationsResponse, error) {
	result := GitHubV3RESTAPIClientOrgsListPendingInvitationsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*OrganizationInvitation
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListPendingInvitationsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListPendingInvitationsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsListPendingInvitationsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsListPublicMembers - Members of an organization can choose to have their membership publicized or not.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsListPublicMembersOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsListPublicMembers
//     method.
func (client *GitHubV3RESTAPIClient) OrgsListPublicMembers(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListPublicMembersOptions) (GitHubV3RESTAPIClientOrgsListPublicMembersResponse, error) {
	req, err := client.orgsListPublicMembersCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListPublicMembersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListPublicMembersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientOrgsListPublicMembersResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsListPublicMembersHandleResponse(resp)
}

// orgsListPublicMembersCreateRequest creates the OrgsListPublicMembers request.
func (client *GitHubV3RESTAPIClient) orgsListPublicMembersCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListPublicMembersOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/public_members"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsListPublicMembersHandleResponse handles the OrgsListPublicMembers response.
func (client *GitHubV3RESTAPIClient) orgsListPublicMembersHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsListPublicMembersResponse, error) {
	result := GitHubV3RESTAPIClientOrgsListPublicMembersResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.SimpleUserArray); err != nil {
		return GitHubV3RESTAPIClientOrgsListPublicMembersResponse{}, err
	}
	return result, nil
}

// OrgsListSecurityManagerTeams - Lists teams that are security managers for an organization. For more information, see "Managing
// security managers in your organization
// [https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization]."
// To use this endpoint, you must be an administrator or security manager for the organization, and you must use an access
// token with the read:org scope.
// GitHub Apps must have the administration organization read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsListSecurityManagerTeamsOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsListSecurityManagerTeams
//     method.
func (client *GitHubV3RESTAPIClient) OrgsListSecurityManagerTeams(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListSecurityManagerTeamsOptions) (GitHubV3RESTAPIClientOrgsListSecurityManagerTeamsResponse, error) {
	req, err := client.orgsListSecurityManagerTeamsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListSecurityManagerTeamsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListSecurityManagerTeamsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientOrgsListSecurityManagerTeamsResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsListSecurityManagerTeamsHandleResponse(resp)
}

// orgsListSecurityManagerTeamsCreateRequest creates the OrgsListSecurityManagerTeams request.
func (client *GitHubV3RESTAPIClient) orgsListSecurityManagerTeamsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListSecurityManagerTeamsOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/security-managers"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsListSecurityManagerTeamsHandleResponse handles the OrgsListSecurityManagerTeams response.
func (client *GitHubV3RESTAPIClient) orgsListSecurityManagerTeamsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsListSecurityManagerTeamsResponse, error) {
	result := GitHubV3RESTAPIClientOrgsListSecurityManagerTeamsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamSimpleArray); err != nil {
		return GitHubV3RESTAPIClientOrgsListSecurityManagerTeamsResponse{}, err
	}
	return result, nil
}

// OrgsListWebhookDeliveries - Returns a list of webhook deliveries for a webhook configured in an organization.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsListWebhookDeliveriesOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsListWebhookDeliveries
//     method.
func (client *GitHubV3RESTAPIClient) OrgsListWebhookDeliveries(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListWebhookDeliveriesOptions) (GitHubV3RESTAPIClientOrgsListWebhookDeliveriesResponse, error) {
	req, err := client.orgsListWebhookDeliveriesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListWebhookDeliveriesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListWebhookDeliveriesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientOrgsListWebhookDeliveriesResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsListWebhookDeliveriesHandleResponse(resp)
}

// orgsListWebhookDeliveriesCreateRequest creates the OrgsListWebhookDeliveries request.
func (client *GitHubV3RESTAPIClient) orgsListWebhookDeliveriesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListWebhookDeliveriesOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/hooks/{hook_id}/deliveries"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.cursor != nil {
		reqQP.Set("cursor", *client.cursor)
	}
	if options != nil && options.Redelivery != nil {
		reqQP.Set("redelivery", strconv.FormatBool(*options.Redelivery))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// orgsListWebhookDeliveriesHandleResponse handles the OrgsListWebhookDeliveries response.
func (client *GitHubV3RESTAPIClient) orgsListWebhookDeliveriesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsListWebhookDeliveriesResponse, error) {
	result := GitHubV3RESTAPIClientOrgsListWebhookDeliveriesResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*HookDeliveryItem
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListWebhookDeliveriesResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListWebhookDeliveriesResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListWebhookDeliveriesResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsListWebhookDeliveriesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsListWebhooks - List organization webhooks
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsListWebhooksOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsListWebhooks
//     method.
func (client *GitHubV3RESTAPIClient) OrgsListWebhooks(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListWebhooksOptions) (GitHubV3RESTAPIClientOrgsListWebhooksResponse, error) {
	req, err := client.orgsListWebhooksCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListWebhooksResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsListWebhooksResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientOrgsListWebhooksResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsListWebhooksHandleResponse(resp)
}

// orgsListWebhooksCreateRequest creates the OrgsListWebhooks request.
func (client *GitHubV3RESTAPIClient) orgsListWebhooksCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsListWebhooksOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/hooks"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsListWebhooksHandleResponse handles the OrgsListWebhooks response.
func (client *GitHubV3RESTAPIClient) orgsListWebhooksHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsListWebhooksResponse, error) {
	result := GitHubV3RESTAPIClientOrgsListWebhooksResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*OrgHook
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListWebhooksResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsListWebhooksResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsListWebhooksResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsPingWebhook - This will trigger a ping event [https://docs.github.com/webhooks/#ping-event] to be sent to the hook.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsPingWebhookOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsPingWebhook
//     method.
func (client *GitHubV3RESTAPIClient) OrgsPingWebhook(ctx context.Context, options *GitHubV3RESTAPIClientOrgsPingWebhookOptions) (GitHubV3RESTAPIClientOrgsPingWebhookResponse, error) {
	req, err := client.orgsPingWebhookCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsPingWebhookResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsPingWebhookResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientOrgsPingWebhookResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsPingWebhookHandleResponse(resp)
}

// orgsPingWebhookCreateRequest creates the OrgsPingWebhook request.
func (client *GitHubV3RESTAPIClient) orgsPingWebhookCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsPingWebhookOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/hooks/{hook_id}/pings"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsPingWebhookHandleResponse handles the OrgsPingWebhook response.
func (client *GitHubV3RESTAPIClient) orgsPingWebhookHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsPingWebhookResponse, error) {
	result := GitHubV3RESTAPIClientOrgsPingWebhookResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientOrgsPingWebhookResponse{}, err
	}
	return result, nil
}

// OrgsRedeliverWebhookDelivery - Redeliver a delivery for a webhook configured in an organization.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsRedeliverWebhookDeliveryOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsRedeliverWebhookDelivery
//     method.
func (client *GitHubV3RESTAPIClient) OrgsRedeliverWebhookDelivery(ctx context.Context, options *GitHubV3RESTAPIClientOrgsRedeliverWebhookDeliveryOptions) (GitHubV3RESTAPIClientOrgsRedeliverWebhookDeliveryResponse, error) {
	req, err := client.orgsRedeliverWebhookDeliveryCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsRedeliverWebhookDeliveryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsRedeliverWebhookDeliveryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusBadRequest, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientOrgsRedeliverWebhookDeliveryResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsRedeliverWebhookDeliveryHandleResponse(resp)
}

// orgsRedeliverWebhookDeliveryCreateRequest creates the OrgsRedeliverWebhookDelivery request.
func (client *GitHubV3RESTAPIClient) orgsRedeliverWebhookDeliveryCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsRedeliverWebhookDeliveryOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{delivery_id}", url.PathEscape(strconv.FormatInt(int64(client.deliveryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// orgsRedeliverWebhookDeliveryHandleResponse handles the OrgsRedeliverWebhookDelivery response.
func (client *GitHubV3RESTAPIClient) orgsRedeliverWebhookDeliveryHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsRedeliverWebhookDeliveryResponse, error) {
	result := GitHubV3RESTAPIClientOrgsRedeliverWebhookDeliveryResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsRedeliverWebhookDeliveryResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsRedeliverWebhookDeliveryResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsRedeliverWebhookDeliveryResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsRedeliverWebhookDeliveryResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsRemoveMember - Removing a user from this list will remove them from all teams and they will no longer have any access
// to the organization's repositories.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsRemoveMemberOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsRemoveMember
//     method.
func (client *GitHubV3RESTAPIClient) OrgsRemoveMember(ctx context.Context, options *GitHubV3RESTAPIClientOrgsRemoveMemberOptions) (GitHubV3RESTAPIClientOrgsRemoveMemberResponse, error) {
	req, err := client.orgsRemoveMemberCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsRemoveMemberResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsRemoveMemberResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusForbidden) {
		return GitHubV3RESTAPIClientOrgsRemoveMemberResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsRemoveMemberHandleResponse(resp)
}

// orgsRemoveMemberCreateRequest creates the OrgsRemoveMember request.
func (client *GitHubV3RESTAPIClient) orgsRemoveMemberCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsRemoveMemberOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/members/{username}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsRemoveMemberHandleResponse handles the OrgsRemoveMember response.
func (client *GitHubV3RESTAPIClient) orgsRemoveMemberHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsRemoveMemberResponse, error) {
	result := GitHubV3RESTAPIClientOrgsRemoveMemberResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientOrgsRemoveMemberResponse{}, err
	}
	return result, nil
}

// OrgsRemoveMembershipForUser - In order to remove a user's membership with an organization, the authenticated user must
// be an organization owner.
// If the specified user is an active member of the organization, this will remove them from the organization. If the specified
// user has been invited to the organization, this will cancel their
// invitation. The specified user will receive an email notification in both cases.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsRemoveMembershipForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsRemoveMembershipForUser
//     method.
func (client *GitHubV3RESTAPIClient) OrgsRemoveMembershipForUser(ctx context.Context, options *GitHubV3RESTAPIClientOrgsRemoveMembershipForUserOptions) (GitHubV3RESTAPIClientOrgsRemoveMembershipForUserResponse, error) {
	req, err := client.orgsRemoveMembershipForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsRemoveMembershipForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsRemoveMembershipForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientOrgsRemoveMembershipForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsRemoveMembershipForUserHandleResponse(resp)
}

// orgsRemoveMembershipForUserCreateRequest creates the OrgsRemoveMembershipForUser request.
func (client *GitHubV3RESTAPIClient) orgsRemoveMembershipForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsRemoveMembershipForUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/memberships/{username}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsRemoveMembershipForUserHandleResponse handles the OrgsRemoveMembershipForUser response.
func (client *GitHubV3RESTAPIClient) orgsRemoveMembershipForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsRemoveMembershipForUserResponse, error) {
	result := GitHubV3RESTAPIClientOrgsRemoveMembershipForUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientOrgsRemoveMembershipForUserResponse{}, err
	}
	return result, nil
}

// OrgsRemoveOutsideCollaborator - Removing a user from this list will remove them from all the organization's repositories.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsRemoveOutsideCollaboratorOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsRemoveOutsideCollaborator
//     method.
func (client *GitHubV3RESTAPIClient) OrgsRemoveOutsideCollaborator(ctx context.Context, options *GitHubV3RESTAPIClientOrgsRemoveOutsideCollaboratorOptions) (GitHubV3RESTAPIClientOrgsRemoveOutsideCollaboratorResponse, error) {
	req, err := client.orgsRemoveOutsideCollaboratorCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsRemoveOutsideCollaboratorResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsRemoveOutsideCollaboratorResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientOrgsRemoveOutsideCollaboratorResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsRemoveOutsideCollaboratorHandleResponse(resp)
}

// orgsRemoveOutsideCollaboratorCreateRequest creates the OrgsRemoveOutsideCollaborator request.
func (client *GitHubV3RESTAPIClient) orgsRemoveOutsideCollaboratorCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsRemoveOutsideCollaboratorOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/outside_collaborators/{username}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsRemoveOutsideCollaboratorHandleResponse handles the OrgsRemoveOutsideCollaborator response.
func (client *GitHubV3RESTAPIClient) orgsRemoveOutsideCollaboratorHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsRemoveOutsideCollaboratorResponse, error) {
	result := GitHubV3RESTAPIClientOrgsRemoveOutsideCollaboratorResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths13L7Wt9OrgsOrgOutsideCollaboratorsUsernameDeleteResponses422ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientOrgsRemoveOutsideCollaboratorResponse{}, err
	}
	return result, nil
}

// OrgsRemovePublicMembershipForAuthenticatedUser - Remove public organization membership for the authenticated user
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsRemovePublicMembershipForAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.OrgsRemovePublicMembershipForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) OrgsRemovePublicMembershipForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientOrgsRemovePublicMembershipForAuthenticatedUserOptions) (GitHubV3RESTAPIClientOrgsRemovePublicMembershipForAuthenticatedUserResponse, error) {
	req, err := client.orgsRemovePublicMembershipForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsRemovePublicMembershipForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsRemovePublicMembershipForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientOrgsRemovePublicMembershipForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientOrgsRemovePublicMembershipForAuthenticatedUserResponse{}, nil
}

// orgsRemovePublicMembershipForAuthenticatedUserCreateRequest creates the OrgsRemovePublicMembershipForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) orgsRemovePublicMembershipForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsRemovePublicMembershipForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/public_members/{username}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// OrgsRemoveSecurityManagerTeam - Removes the security manager role from a team for an organization. For more information,
// see "Managing security managers in your organization
// [https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization]
// team from an organization."
// To use this endpoint, you must be an administrator for the organization, and you must use an access token with the admin:org
// scope.
// GitHub Apps must have the administration organization read-write permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsRemoveSecurityManagerTeamOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsRemoveSecurityManagerTeam
//     method.
func (client *GitHubV3RESTAPIClient) OrgsRemoveSecurityManagerTeam(ctx context.Context, options *GitHubV3RESTAPIClientOrgsRemoveSecurityManagerTeamOptions) (GitHubV3RESTAPIClientOrgsRemoveSecurityManagerTeamResponse, error) {
	req, err := client.orgsRemoveSecurityManagerTeamCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsRemoveSecurityManagerTeamResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsRemoveSecurityManagerTeamResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientOrgsRemoveSecurityManagerTeamResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientOrgsRemoveSecurityManagerTeamResponse{}, nil
}

// orgsRemoveSecurityManagerTeamCreateRequest creates the OrgsRemoveSecurityManagerTeam request.
func (client *GitHubV3RESTAPIClient) orgsRemoveSecurityManagerTeamCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsRemoveSecurityManagerTeamOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/security-managers/teams/{team_slug}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// OrgsSetMembershipForUser - Only authenticated organization owners can add a member to the organization or update the member's
// role.
// * If the authenticated user is adding a member to the organization, the invited user will receive an email inviting them
// to the organization. The user's membership status
// [https://docs.github.com/rest/reference/orgs#get-organization-membership-for-a-user] will be pending until they accept
// the invitation.
//
//
// * Authenticated users can update a user's membership by passing the role parameter. If the authenticated user changes a
// member's role to admin, the affected user will receive an email notifying them
// that they've been made an organization owner. If the authenticated user changes an owner's role to member, no email will
// be sent.
//
//
// Rate limits
// To prevent abuse, the authenticated user is limited to 50 organization invitations per 24 hour period. If the organization
// is more than one month old or on a paid plan, the limit is 500 invitations
// per 24 hour period.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsSetMembershipForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsSetMembershipForUser
//     method.
func (client *GitHubV3RESTAPIClient) OrgsSetMembershipForUser(ctx context.Context, body Paths2PsmrjOrgsOrgMembershipsUsernamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientOrgsSetMembershipForUserOptions) (GitHubV3RESTAPIClientOrgsSetMembershipForUserResponse, error) {
	req, err := client.orgsSetMembershipForUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsSetMembershipForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsSetMembershipForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientOrgsSetMembershipForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsSetMembershipForUserHandleResponse(resp)
}

// orgsSetMembershipForUserCreateRequest creates the OrgsSetMembershipForUser request.
func (client *GitHubV3RESTAPIClient) orgsSetMembershipForUserCreateRequest(ctx context.Context, body Paths2PsmrjOrgsOrgMembershipsUsernamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientOrgsSetMembershipForUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/memberships/{username}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// orgsSetMembershipForUserHandleResponse handles the OrgsSetMembershipForUser response.
func (client *GitHubV3RESTAPIClient) orgsSetMembershipForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsSetMembershipForUserResponse, error) {
	result := GitHubV3RESTAPIClientOrgsSetMembershipForUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val OrgMembership
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsSetMembershipForUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsSetMembershipForUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsSetMembershipForUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsSetMembershipForUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsSetPublicMembershipForAuthenticatedUser - The user can publicize their own membership. (A user cannot publicize the
// membership for another user.)
// Note that you'll need to set Content-Length to zero when calling out to this endpoint. For more information, see "HTTP
// verbs
// [https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsSetPublicMembershipForAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.OrgsSetPublicMembershipForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) OrgsSetPublicMembershipForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientOrgsSetPublicMembershipForAuthenticatedUserOptions) (GitHubV3RESTAPIClientOrgsSetPublicMembershipForAuthenticatedUserResponse, error) {
	req, err := client.orgsSetPublicMembershipForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsSetPublicMembershipForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsSetPublicMembershipForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusForbidden) {
		return GitHubV3RESTAPIClientOrgsSetPublicMembershipForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsSetPublicMembershipForAuthenticatedUserHandleResponse(resp)
}

// orgsSetPublicMembershipForAuthenticatedUserCreateRequest creates the OrgsSetPublicMembershipForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) orgsSetPublicMembershipForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsSetPublicMembershipForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/public_members/{username}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// orgsSetPublicMembershipForAuthenticatedUserHandleResponse handles the OrgsSetPublicMembershipForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) orgsSetPublicMembershipForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsSetPublicMembershipForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientOrgsSetPublicMembershipForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientOrgsSetPublicMembershipForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// OrgsUnblockUser - Unblock a user from an organization
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsUnblockUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsUnblockUser
//     method.
func (client *GitHubV3RESTAPIClient) OrgsUnblockUser(ctx context.Context, options *GitHubV3RESTAPIClientOrgsUnblockUserOptions) (GitHubV3RESTAPIClientOrgsUnblockUserResponse, error) {
	req, err := client.orgsUnblockUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsUnblockUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsUnblockUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientOrgsUnblockUserResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientOrgsUnblockUserResponse{}, nil
}

// orgsUnblockUserCreateRequest creates the OrgsUnblockUser request.
func (client *GitHubV3RESTAPIClient) orgsUnblockUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientOrgsUnblockUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/blocks/{username}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// OrgsUpdate - Parameter Deprecation Notice: GitHub will replace and discontinue membersallowedrepositorycreationtype in
// favor of more granular permissions. The new input parameters are memberscancreatepublic
// repositories, memberscancreateprivaterepositories for all organizations and memberscancreateinternalrepositories for organizations
// associated with an enterprise account using GitHub Enterprise Cloud
// or GitHub Enterprise Server 2.20+. For more information, see the blog post [https://developer.github.com/changes/2019-12-03-internal-visibility-changes].
// Enables an authenticated organization owner with the admin:org scope to update the organization's profile and member privileges.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsUpdateOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsUpdate
//     method.
func (client *GitHubV3RESTAPIClient) OrgsUpdate(ctx context.Context, body Paths6G9Mz4OrgsOrgPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientOrgsUpdateOptions) (GitHubV3RESTAPIClientOrgsUpdateResponse, error) {
	req, err := client.orgsUpdateCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusConflict, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientOrgsUpdateResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsUpdateHandleResponse(resp)
}

// orgsUpdateCreateRequest creates the OrgsUpdate request.
func (client *GitHubV3RESTAPIClient) orgsUpdateCreateRequest(ctx context.Context, body Paths6G9Mz4OrgsOrgPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientOrgsUpdateOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// orgsUpdateHandleResponse handles the OrgsUpdate response.
func (client *GitHubV3RESTAPIClient) orgsUpdateHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsUpdateResponse, error) {
	result := GitHubV3RESTAPIClientOrgsUpdateResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val OrganizationFull
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val Paths1Jw0C69OrgsOrgPatchResponses422ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsUpdateResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsUpdateMembershipForAuthenticatedUser - Update an organization membership for the authenticated user
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsUpdateMembershipForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.OrgsUpdateMembershipForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) OrgsUpdateMembershipForAuthenticatedUser(ctx context.Context, body Paths1EzemxdUserMembershipsOrgsOrgPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientOrgsUpdateMembershipForAuthenticatedUserOptions) (GitHubV3RESTAPIClientOrgsUpdateMembershipForAuthenticatedUserResponse, error) {
	req, err := client.orgsUpdateMembershipForAuthenticatedUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateMembershipForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateMembershipForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientOrgsUpdateMembershipForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsUpdateMembershipForAuthenticatedUserHandleResponse(resp)
}

// orgsUpdateMembershipForAuthenticatedUserCreateRequest creates the OrgsUpdateMembershipForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) orgsUpdateMembershipForAuthenticatedUserCreateRequest(ctx context.Context, body Paths1EzemxdUserMembershipsOrgsOrgPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientOrgsUpdateMembershipForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/memberships/orgs/{org}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// orgsUpdateMembershipForAuthenticatedUserHandleResponse handles the OrgsUpdateMembershipForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) orgsUpdateMembershipForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsUpdateMembershipForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientOrgsUpdateMembershipForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val OrgMembership
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateMembershipForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateMembershipForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateMembershipForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateMembershipForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsUpdateMembershipForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsUpdateWebhook - Updates a webhook configured in an organization. When you update a webhook, the secret will be overwritten.
// If you previously had a secret set, you must provide the same secret or set a new secret or
// the secret will be removed. If you are only updating individual webhook config properties, use "Update a webhook configuration
// for an organization
// [/rest/reference/orgs#update-a-webhook-configuration-for-an-organization]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsUpdateWebhookOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsUpdateWebhook
//     method.
func (client *GitHubV3RESTAPIClient) OrgsUpdateWebhook(ctx context.Context, body Paths18U4O2XOrgsOrgHooksHookIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientOrgsUpdateWebhookOptions) (GitHubV3RESTAPIClientOrgsUpdateWebhookResponse, error) {
	req, err := client.orgsUpdateWebhookCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateWebhookResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateWebhookResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientOrgsUpdateWebhookResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsUpdateWebhookHandleResponse(resp)
}

// orgsUpdateWebhookCreateRequest creates the OrgsUpdateWebhook request.
func (client *GitHubV3RESTAPIClient) orgsUpdateWebhookCreateRequest(ctx context.Context, body Paths18U4O2XOrgsOrgHooksHookIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientOrgsUpdateWebhookOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/hooks/{hook_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// orgsUpdateWebhookHandleResponse handles the OrgsUpdateWebhook response.
func (client *GitHubV3RESTAPIClient) orgsUpdateWebhookHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsUpdateWebhookResponse, error) {
	result := GitHubV3RESTAPIClientOrgsUpdateWebhookResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val OrgHook
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateWebhookResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateWebhookResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateWebhookResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientOrgsUpdateWebhookResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// OrgsUpdateWebhookConfigForOrg - Updates the webhook configuration for an organization. To update more information about
// the webhook, including the active state and events, use "Update an organization webhook
// [/rest/reference/orgs#update-an-organization-webhook]."
// Access tokens must have the admin:orghook scope, and GitHub Apps must have the organizationhooks:write permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientOrgsUpdateWebhookConfigForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.OrgsUpdateWebhookConfigForOrg
//     method.
func (client *GitHubV3RESTAPIClient) OrgsUpdateWebhookConfigForOrg(ctx context.Context, body Paths1Sedmy0OrgsOrgHooksHookIDConfigPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientOrgsUpdateWebhookConfigForOrgOptions) (GitHubV3RESTAPIClientOrgsUpdateWebhookConfigForOrgResponse, error) {
	req, err := client.orgsUpdateWebhookConfigForOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateWebhookConfigForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateWebhookConfigForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientOrgsUpdateWebhookConfigForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.orgsUpdateWebhookConfigForOrgHandleResponse(resp)
}

// orgsUpdateWebhookConfigForOrgCreateRequest creates the OrgsUpdateWebhookConfigForOrg request.
func (client *GitHubV3RESTAPIClient) orgsUpdateWebhookConfigForOrgCreateRequest(ctx context.Context, body Paths1Sedmy0OrgsOrgHooksHookIDConfigPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientOrgsUpdateWebhookConfigForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/hooks/{hook_id}/config"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// orgsUpdateWebhookConfigForOrgHandleResponse handles the OrgsUpdateWebhookConfigForOrg response.
func (client *GitHubV3RESTAPIClient) orgsUpdateWebhookConfigForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientOrgsUpdateWebhookConfigForOrgResponse, error) {
	result := GitHubV3RESTAPIClientOrgsUpdateWebhookConfigForOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebhookConfig); err != nil {
		return GitHubV3RESTAPIClientOrgsUpdateWebhookConfigForOrgResponse{}, err
	}
	return result, nil
}

// PackagesDeletePackageForAuthenticatedUser - Deletes a package owned by the authenticated user. You cannot delete a public
// package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further
// assistance.
// To use this endpoint, you must authenticate using an access token with the read:packages and delete:packages scopes. If
// the package_type belongs to a GitHub Packages registry that only supports
// repository-scoped permissions, your token must also include the repo scope. For the list of GitHub Packages registries
// that only support repository-scoped permissions, see "About permissions for
// GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesDeletePackageForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.PackagesDeletePackageForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) PackagesDeletePackageForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientPackagesDeletePackageForAuthenticatedUserOptions) (GitHubV3RESTAPIClientPackagesDeletePackageForAuthenticatedUserResponse, error) {
	req, err := client.packagesDeletePackageForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPackagesDeletePackageForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesDeletePackageForAuthenticatedUserHandleResponse(resp)
}

// packagesDeletePackageForAuthenticatedUserCreateRequest creates the PackagesDeletePackageForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) packagesDeletePackageForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesDeletePackageForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/packages/{package_type}/{package_name}"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesDeletePackageForAuthenticatedUserHandleResponse handles the PackagesDeletePackageForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) packagesDeletePackageForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesDeletePackageForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientPackagesDeletePackageForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// PackagesDeletePackageForOrg - Deletes an entire package in an organization. You cannot delete a public package if any version
// of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further
// assistance.
// To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the
// read:packages and delete:packages scopes. In addition:
// * If the package_type belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token
// must also include the repo scope. For the list of these registries, see "About
// permissions for GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// * If the package_type belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions
// to the package you want to delete. For the list of these registries,
// see "About permissions for GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesDeletePackageForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.PackagesDeletePackageForOrg
//     method.
func (client *GitHubV3RESTAPIClient) PackagesDeletePackageForOrg(ctx context.Context, options *GitHubV3RESTAPIClientPackagesDeletePackageForOrgOptions) (GitHubV3RESTAPIClientPackagesDeletePackageForOrgResponse, error) {
	req, err := client.packagesDeletePackageForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPackagesDeletePackageForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesDeletePackageForOrgHandleResponse(resp)
}

// packagesDeletePackageForOrgCreateRequest creates the PackagesDeletePackageForOrg request.
func (client *GitHubV3RESTAPIClient) packagesDeletePackageForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesDeletePackageForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/packages/{package_type}/{package_name}"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesDeletePackageForOrgHandleResponse handles the PackagesDeletePackageForOrg response.
func (client *GitHubV3RESTAPIClient) packagesDeletePackageForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesDeletePackageForOrgResponse, error) {
	result := GitHubV3RESTAPIClientPackagesDeletePackageForOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageForOrgResponse{}, err
	}
	return result, nil
}

// PackagesDeletePackageForUser - Deletes an entire package for a user. You cannot delete a public package if any version
// of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.
// To use this endpoint, you must authenticate using an access token with the read:packages and delete:packages scopes. In
// addition:
// * If the package_type belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token
// must also include the repo scope. For the list of these registries, see "About
// permissions for GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// * If the package_type belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions
// to the package you want to delete. For the list of these registries,
// see "About permissions for GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesDeletePackageForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.PackagesDeletePackageForUser
//     method.
func (client *GitHubV3RESTAPIClient) PackagesDeletePackageForUser(ctx context.Context, options *GitHubV3RESTAPIClientPackagesDeletePackageForUserOptions) (GitHubV3RESTAPIClientPackagesDeletePackageForUserResponse, error) {
	req, err := client.packagesDeletePackageForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPackagesDeletePackageForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesDeletePackageForUserHandleResponse(resp)
}

// packagesDeletePackageForUserCreateRequest creates the PackagesDeletePackageForUser request.
func (client *GitHubV3RESTAPIClient) packagesDeletePackageForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesDeletePackageForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/packages/{package_type}/{package_name}"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesDeletePackageForUserHandleResponse handles the PackagesDeletePackageForUser response.
func (client *GitHubV3RESTAPIClient) packagesDeletePackageForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesDeletePackageForUserResponse, error) {
	result := GitHubV3RESTAPIClientPackagesDeletePackageForUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageForUserResponse{}, err
	}
	return result, nil
}

// PackagesDeletePackageVersionForAuthenticatedUser - Deletes a specific package version for a package owned by the authenticated
// user. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version.
// In this scenario, contact GitHub support for further assistance.
// To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the
// read:packages and delete:packages scopes. If the package_type belongs to a
// GitHub Packages registry that only supports repository-scoped permissions, your token must also include the repo scope.
// For the list of GitHub Packages registries that only support repository-scoped
// permissions, see "About permissions for GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesDeletePackageVersionForAuthenticatedUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.PackagesDeletePackageVersionForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) PackagesDeletePackageVersionForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientPackagesDeletePackageVersionForAuthenticatedUserOptions) (GitHubV3RESTAPIClientPackagesDeletePackageVersionForAuthenticatedUserResponse, error) {
	req, err := client.packagesDeletePackageVersionForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageVersionForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageVersionForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPackagesDeletePackageVersionForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesDeletePackageVersionForAuthenticatedUserHandleResponse(resp)
}

// packagesDeletePackageVersionForAuthenticatedUserCreateRequest creates the PackagesDeletePackageVersionForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) packagesDeletePackageVersionForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesDeletePackageVersionForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/packages/{package_type}/{package_name}/versions/{package_version_id}"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	urlPath = strings.ReplaceAll(urlPath, "{package_version_id}", url.PathEscape(strconv.FormatInt(int64(client.packageVersionID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesDeletePackageVersionForAuthenticatedUserHandleResponse handles the PackagesDeletePackageVersionForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) packagesDeletePackageVersionForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesDeletePackageVersionForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientPackagesDeletePackageVersionForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageVersionForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// PackagesDeletePackageVersionForOrg - Deletes a specific package version in an organization. If the package is public and
// the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact
// GitHub support for further assistance.
// To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the
// read:packages and delete:packages scopes. In addition:
// * If the package_type belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token
// must also include the repo scope. For the list of these registries, see "About
// permissions for GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// * If the package_type belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions
// to the package whose version you want to delete. For the list of these
// registries, see "About permissions for GitHub Packages
// [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesDeletePackageVersionForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.PackagesDeletePackageVersionForOrg
//     method.
func (client *GitHubV3RESTAPIClient) PackagesDeletePackageVersionForOrg(ctx context.Context, options *GitHubV3RESTAPIClientPackagesDeletePackageVersionForOrgOptions) (GitHubV3RESTAPIClientPackagesDeletePackageVersionForOrgResponse, error) {
	req, err := client.packagesDeletePackageVersionForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageVersionForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageVersionForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPackagesDeletePackageVersionForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesDeletePackageVersionForOrgHandleResponse(resp)
}

// packagesDeletePackageVersionForOrgCreateRequest creates the PackagesDeletePackageVersionForOrg request.
func (client *GitHubV3RESTAPIClient) packagesDeletePackageVersionForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesDeletePackageVersionForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{package_version_id}", url.PathEscape(strconv.FormatInt(int64(client.packageVersionID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesDeletePackageVersionForOrgHandleResponse handles the PackagesDeletePackageVersionForOrg response.
func (client *GitHubV3RESTAPIClient) packagesDeletePackageVersionForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesDeletePackageVersionForOrgResponse, error) {
	result := GitHubV3RESTAPIClientPackagesDeletePackageVersionForOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageVersionForOrgResponse{}, err
	}
	return result, nil
}

// PackagesDeletePackageVersionForUser - Deletes a specific package version for a user. If the package is public and the package
// version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub
// support for further assistance.
// To use this endpoint, you must authenticate using an access token with the read:packages and delete:packages scopes. In
// addition:
// * If the package_type belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token
// must also include the repo scope. For the list of these registries, see "About
// permissions for GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// * If the package_type belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions
// to the package whose version you want to delete. For the list of these
// registries, see "About permissions for GitHub Packages
// [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesDeletePackageVersionForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.PackagesDeletePackageVersionForUser
//     method.
func (client *GitHubV3RESTAPIClient) PackagesDeletePackageVersionForUser(ctx context.Context, options *GitHubV3RESTAPIClientPackagesDeletePackageVersionForUserOptions) (GitHubV3RESTAPIClientPackagesDeletePackageVersionForUserResponse, error) {
	req, err := client.packagesDeletePackageVersionForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageVersionForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageVersionForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPackagesDeletePackageVersionForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesDeletePackageVersionForUserHandleResponse(resp)
}

// packagesDeletePackageVersionForUserCreateRequest creates the PackagesDeletePackageVersionForUser request.
func (client *GitHubV3RESTAPIClient) packagesDeletePackageVersionForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesDeletePackageVersionForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	urlPath = strings.ReplaceAll(urlPath, "{package_version_id}", url.PathEscape(strconv.FormatInt(int64(client.packageVersionID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesDeletePackageVersionForUserHandleResponse handles the PackagesDeletePackageVersionForUser response.
func (client *GitHubV3RESTAPIClient) packagesDeletePackageVersionForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesDeletePackageVersionForUserResponse, error) {
	result := GitHubV3RESTAPIClientPackagesDeletePackageVersionForUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientPackagesDeletePackageVersionForUserResponse{}, err
	}
	return result, nil
}

// PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser - Lists package versions for a package owned by the authenticated
// user.
// To use this endpoint, you must authenticate using an access token with the read:packages scope. If the package_type belongs
// to a GitHub Packages registry that only supports repository-scoped
// permissions, your token must also include the repo scope. For the list of GitHub Packages registries that only support
// repository-scoped permissions, see "About permissions for GitHub Packages
// [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOptions contains the optional
//     parameters for the GitHubV3RESTAPIClient.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOptions) (GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse, error) {
	req, err := client.packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserHandleResponse(resp)
}

// packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserCreateRequest creates the PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/packages/{package_type}/{package_name}/versions"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if options != nil && options.State != nil {
		reqQP.Set("state", string(*options.State))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserHandleResponse handles the PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*PackageVersion
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PackagesGetAllPackageVersionsForPackageOwnedByOrg - Lists package versions for a package owned by an organization.
// If the package_type belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token
// must also include the repo scope. For the list of GitHub Packages registries that
// only support repository-scoped permissions, see "About permissions for GitHub Packages
// [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByOrgOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.PackagesGetAllPackageVersionsForPackageOwnedByOrg method.
func (client *GitHubV3RESTAPIClient) PackagesGetAllPackageVersionsForPackageOwnedByOrg(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByOrgOptions) (GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByOrgResponse, error) {
	req, err := client.packagesGetAllPackageVersionsForPackageOwnedByOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesGetAllPackageVersionsForPackageOwnedByOrgHandleResponse(resp)
}

// packagesGetAllPackageVersionsForPackageOwnedByOrgCreateRequest creates the PackagesGetAllPackageVersionsForPackageOwnedByOrg request.
func (client *GitHubV3RESTAPIClient) packagesGetAllPackageVersionsForPackageOwnedByOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/packages/{package_type}/{package_name}/versions"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if options != nil && options.State != nil {
		reqQP.Set("state", string(*options.State))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesGetAllPackageVersionsForPackageOwnedByOrgHandleResponse handles the PackagesGetAllPackageVersionsForPackageOwnedByOrg response.
func (client *GitHubV3RESTAPIClient) packagesGetAllPackageVersionsForPackageOwnedByOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByOrgResponse, error) {
	result := GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByOrgResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*PackageVersion
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByOrgResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByOrgResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PackagesGetAllPackageVersionsForPackageOwnedByUser - Lists package versions for a public package owned by a specified user.
// To use this endpoint, you must authenticate using an access token with the read:packages scope. If the package_type belongs
// to a GitHub Packages registry that only supports repository-scoped
// permissions, your token must also include the repo scope. For the list of GitHub Packages registries that only support
// repository-scoped permissions, see "About permissions for GitHub Packages
// [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.PackagesGetAllPackageVersionsForPackageOwnedByUser method.
func (client *GitHubV3RESTAPIClient) PackagesGetAllPackageVersionsForPackageOwnedByUser(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByUserOptions) (GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByUserResponse, error) {
	req, err := client.packagesGetAllPackageVersionsForPackageOwnedByUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesGetAllPackageVersionsForPackageOwnedByUserHandleResponse(resp)
}

// packagesGetAllPackageVersionsForPackageOwnedByUserCreateRequest creates the PackagesGetAllPackageVersionsForPackageOwnedByUser request.
func (client *GitHubV3RESTAPIClient) packagesGetAllPackageVersionsForPackageOwnedByUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/packages/{package_type}/{package_name}/versions"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesGetAllPackageVersionsForPackageOwnedByUserHandleResponse handles the PackagesGetAllPackageVersionsForPackageOwnedByUser response.
func (client *GitHubV3RESTAPIClient) packagesGetAllPackageVersionsForPackageOwnedByUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByUserResponse, error) {
	result := GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*PackageVersion
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPackagesGetAllPackageVersionsForPackageOwnedByUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PackagesGetPackageForAuthenticatedUser - Gets a specific package for a package owned by the authenticated user.
// To use this endpoint, you must authenticate using an access token with the read:packages scope. If the package_type belongs
// to a GitHub Packages registry that only supports repository-scoped
// permissions, your token must also include the repo scope. For the list of GitHub Packages registries that only support
// repository-scoped permissions, see "About permissions for GitHub Packages
// [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesGetPackageForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.PackagesGetPackageForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) PackagesGetPackageForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetPackageForAuthenticatedUserOptions) (GitHubV3RESTAPIClientPackagesGetPackageForAuthenticatedUserResponse, error) {
	req, err := client.packagesGetPackageForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientPackagesGetPackageForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesGetPackageForAuthenticatedUserHandleResponse(resp)
}

// packagesGetPackageForAuthenticatedUserCreateRequest creates the PackagesGetPackageForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) packagesGetPackageForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetPackageForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/packages/{package_type}/{package_name}"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesGetPackageForAuthenticatedUserHandleResponse handles the PackagesGetPackageForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) packagesGetPackageForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesGetPackageForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientPackagesGetPackageForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Package); err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// PackagesGetPackageForOrganization - Gets a specific package in an organization.
// To use this endpoint, you must authenticate using an access token with the read:packages scope. If the package_type belongs
// to a GitHub Packages registry that only supports repository-scoped
// permissions, your token must also include the repo scope. For the list of GitHub Packages registries that only support
// repository-scoped permissions, see "About permissions for GitHub Packages
// [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesGetPackageForOrganizationOptions contains the optional parameters for the GitHubV3RESTAPIClient.PackagesGetPackageForOrganization
//     method.
func (client *GitHubV3RESTAPIClient) PackagesGetPackageForOrganization(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetPackageForOrganizationOptions) (GitHubV3RESTAPIClientPackagesGetPackageForOrganizationResponse, error) {
	req, err := client.packagesGetPackageForOrganizationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageForOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageForOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientPackagesGetPackageForOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesGetPackageForOrganizationHandleResponse(resp)
}

// packagesGetPackageForOrganizationCreateRequest creates the PackagesGetPackageForOrganization request.
func (client *GitHubV3RESTAPIClient) packagesGetPackageForOrganizationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetPackageForOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/packages/{package_type}/{package_name}"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesGetPackageForOrganizationHandleResponse handles the PackagesGetPackageForOrganization response.
func (client *GitHubV3RESTAPIClient) packagesGetPackageForOrganizationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesGetPackageForOrganizationResponse, error) {
	result := GitHubV3RESTAPIClientPackagesGetPackageForOrganizationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Package); err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageForOrganizationResponse{}, err
	}
	return result, nil
}

// PackagesGetPackageForUser - Gets a specific package metadata for a public package owned by a user.
// To use this endpoint, you must authenticate using an access token with the read:packages scope. If the package_type belongs
// to a GitHub Packages registry that only supports repository-scoped
// permissions, your token must also include the repo scope. For the list of GitHub Packages registries that only support
// repository-scoped permissions, see "About permissions for GitHub Packages
// [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesGetPackageForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.PackagesGetPackageForUser
//     method.
func (client *GitHubV3RESTAPIClient) PackagesGetPackageForUser(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetPackageForUserOptions) (GitHubV3RESTAPIClientPackagesGetPackageForUserResponse, error) {
	req, err := client.packagesGetPackageForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientPackagesGetPackageForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesGetPackageForUserHandleResponse(resp)
}

// packagesGetPackageForUserCreateRequest creates the PackagesGetPackageForUser request.
func (client *GitHubV3RESTAPIClient) packagesGetPackageForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetPackageForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/packages/{package_type}/{package_name}"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesGetPackageForUserHandleResponse handles the PackagesGetPackageForUser response.
func (client *GitHubV3RESTAPIClient) packagesGetPackageForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesGetPackageForUserResponse, error) {
	result := GitHubV3RESTAPIClientPackagesGetPackageForUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Package); err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageForUserResponse{}, err
	}
	return result, nil
}

// PackagesGetPackageVersionForAuthenticatedUser - Gets a specific package version for a package owned by the authenticated
// user.
// To use this endpoint, you must authenticate using an access token with the read:packages scope. If the package_type belongs
// to a GitHub Packages registry that only supports repository-scoped
// permissions, your token must also include the repo scope. For the list of GitHub Packages registries that only support
// repository-scoped permissions, see "About permissions for GitHub Packages
// [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesGetPackageVersionForAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.PackagesGetPackageVersionForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) PackagesGetPackageVersionForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetPackageVersionForAuthenticatedUserOptions) (GitHubV3RESTAPIClientPackagesGetPackageVersionForAuthenticatedUserResponse, error) {
	req, err := client.packagesGetPackageVersionForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageVersionForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageVersionForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientPackagesGetPackageVersionForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesGetPackageVersionForAuthenticatedUserHandleResponse(resp)
}

// packagesGetPackageVersionForAuthenticatedUserCreateRequest creates the PackagesGetPackageVersionForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) packagesGetPackageVersionForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetPackageVersionForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/packages/{package_type}/{package_name}/versions/{package_version_id}"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	urlPath = strings.ReplaceAll(urlPath, "{package_version_id}", url.PathEscape(strconv.FormatInt(int64(client.packageVersionID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesGetPackageVersionForAuthenticatedUserHandleResponse handles the PackagesGetPackageVersionForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) packagesGetPackageVersionForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesGetPackageVersionForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientPackagesGetPackageVersionForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PackageVersion); err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageVersionForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// PackagesGetPackageVersionForOrganization - Gets a specific package version in an organization.
// You must authenticate using an access token with the read:packages scope. If the package_type belongs to a GitHub Packages
// registry that only supports repository-scoped permissions, your token must
// also include the repo scope. For the list of GitHub Packages registries that only support repository-scoped permissions,
// see "About permissions for GitHub Packages
// [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesGetPackageVersionForOrganizationOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.PackagesGetPackageVersionForOrganization method.
func (client *GitHubV3RESTAPIClient) PackagesGetPackageVersionForOrganization(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetPackageVersionForOrganizationOptions) (GitHubV3RESTAPIClientPackagesGetPackageVersionForOrganizationResponse, error) {
	req, err := client.packagesGetPackageVersionForOrganizationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageVersionForOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageVersionForOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientPackagesGetPackageVersionForOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesGetPackageVersionForOrganizationHandleResponse(resp)
}

// packagesGetPackageVersionForOrganizationCreateRequest creates the PackagesGetPackageVersionForOrganization request.
func (client *GitHubV3RESTAPIClient) packagesGetPackageVersionForOrganizationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetPackageVersionForOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{package_version_id}", url.PathEscape(strconv.FormatInt(int64(client.packageVersionID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesGetPackageVersionForOrganizationHandleResponse handles the PackagesGetPackageVersionForOrganization response.
func (client *GitHubV3RESTAPIClient) packagesGetPackageVersionForOrganizationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesGetPackageVersionForOrganizationResponse, error) {
	result := GitHubV3RESTAPIClientPackagesGetPackageVersionForOrganizationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PackageVersion); err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageVersionForOrganizationResponse{}, err
	}
	return result, nil
}

// PackagesGetPackageVersionForUser - Gets a specific package version for a public package owned by a specified user.
// At this time, to use this endpoint, you must authenticate using an access token with the read:packages scope. If the package_type
// belongs to a GitHub Packages registry that only supports
// repository-scoped permissions, your token must also include the repo scope. For the list of GitHub Packages registries
// that only support repository-scoped permissions, see "About permissions for
// GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesGetPackageVersionForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.PackagesGetPackageVersionForUser
//     method.
func (client *GitHubV3RESTAPIClient) PackagesGetPackageVersionForUser(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetPackageVersionForUserOptions) (GitHubV3RESTAPIClientPackagesGetPackageVersionForUserResponse, error) {
	req, err := client.packagesGetPackageVersionForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageVersionForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageVersionForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientPackagesGetPackageVersionForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesGetPackageVersionForUserHandleResponse(resp)
}

// packagesGetPackageVersionForUserCreateRequest creates the PackagesGetPackageVersionForUser request.
func (client *GitHubV3RESTAPIClient) packagesGetPackageVersionForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesGetPackageVersionForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	urlPath = strings.ReplaceAll(urlPath, "{package_version_id}", url.PathEscape(strconv.FormatInt(int64(client.packageVersionID), 10)))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesGetPackageVersionForUserHandleResponse handles the PackagesGetPackageVersionForUser response.
func (client *GitHubV3RESTAPIClient) packagesGetPackageVersionForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesGetPackageVersionForUserResponse, error) {
	result := GitHubV3RESTAPIClientPackagesGetPackageVersionForUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PackageVersion); err != nil {
		return GitHubV3RESTAPIClientPackagesGetPackageVersionForUserResponse{}, err
	}
	return result, nil
}

// PackagesListPackagesForAuthenticatedUser - Lists packages owned by the authenticated user within the user's namespace.
// To use this endpoint, you must authenticate using an access token with the read:packages scope. If the package_type belongs
// to a GitHub Packages registry that only supports repository-scoped
// permissions, your token must also include the repo scope. For the list of GitHub Packages registries that only support
// repository-scoped permissions, see "About permissions for GitHub Packages
// [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - packageType - The type of supported package. Packages in GitHub's Gradle registry have the type maven. Docker images pushed
//     to GitHub's Container registry (ghcr.io) have the type container. You can use the type
//     docker to find images that were pushed to GitHub's Docker registry (docker.pkg.github.com), even if these have now been
//     migrated to the Container registry.
//   - options - GitHubV3RESTAPIClientPackagesListPackagesForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.PackagesListPackagesForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) PackagesListPackagesForAuthenticatedUser(ctx context.Context, packageType Enum321, options *GitHubV3RESTAPIClientPackagesListPackagesForAuthenticatedUserOptions) (GitHubV3RESTAPIClientPackagesListPackagesForAuthenticatedUserResponse, error) {
	req, err := client.packagesListPackagesForAuthenticatedUserCreateRequest(ctx, packageType, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesListPackagesForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesListPackagesForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientPackagesListPackagesForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesListPackagesForAuthenticatedUserHandleResponse(resp)
}

// packagesListPackagesForAuthenticatedUserCreateRequest creates the PackagesListPackagesForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) packagesListPackagesForAuthenticatedUserCreateRequest(ctx context.Context, packageType Enum321, options *GitHubV3RESTAPIClientPackagesListPackagesForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/packages"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("package_type", string(packageType))
	if client.visibility != nil {
		reqQP.Set("visibility", string(*client.visibility))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesListPackagesForAuthenticatedUserHandleResponse handles the PackagesListPackagesForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) packagesListPackagesForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesListPackagesForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientPackagesListPackagesForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PackageArray); err != nil {
		return GitHubV3RESTAPIClientPackagesListPackagesForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// PackagesListPackagesForOrganization - Lists all packages in an organization readable by the user.
// To use this endpoint, you must authenticate using an access token with the read:packages scope. If the package_type belongs
// to a registry that only supports repository-scoped permissions, your token
// must also include the repo scope. For the list of GitHub Packages registries that only support repository-scoped permissions,
// see "About permissions for GitHub Packages
// [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - packageType - The type of supported package. Packages in GitHub's Gradle registry have the type maven. Docker images pushed
//     to GitHub's Container registry (ghcr.io) have the type container. You can use the type
//     docker to find images that were pushed to GitHub's Docker registry (docker.pkg.github.com), even if these have now been
//     migrated to the Container registry.
//   - options - GitHubV3RESTAPIClientPackagesListPackagesForOrganizationOptions contains the optional parameters for the GitHubV3RESTAPIClient.PackagesListPackagesForOrganization
//     method.
func (client *GitHubV3RESTAPIClient) PackagesListPackagesForOrganization(ctx context.Context, packageType Enum117, options *GitHubV3RESTAPIClientPackagesListPackagesForOrganizationOptions) (GitHubV3RESTAPIClientPackagesListPackagesForOrganizationResponse, error) {
	req, err := client.packagesListPackagesForOrganizationCreateRequest(ctx, packageType, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesListPackagesForOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesListPackagesForOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientPackagesListPackagesForOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesListPackagesForOrganizationHandleResponse(resp)
}

// packagesListPackagesForOrganizationCreateRequest creates the PackagesListPackagesForOrganization request.
func (client *GitHubV3RESTAPIClient) packagesListPackagesForOrganizationCreateRequest(ctx context.Context, packageType Enum117, options *GitHubV3RESTAPIClientPackagesListPackagesForOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/packages"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("package_type", string(packageType))
	if client.visibility != nil {
		reqQP.Set("visibility", string(*client.visibility))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesListPackagesForOrganizationHandleResponse handles the PackagesListPackagesForOrganization response.
func (client *GitHubV3RESTAPIClient) packagesListPackagesForOrganizationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesListPackagesForOrganizationResponse, error) {
	result := GitHubV3RESTAPIClientPackagesListPackagesForOrganizationResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Package
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesListPackagesForOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesListPackagesForOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesListPackagesForOrganizationResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPackagesListPackagesForOrganizationResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PackagesListPackagesForUser - Lists all packages in a user's namespace for which the requesting user has access.
// To use this endpoint, you must authenticate using an access token with the read:packages scope. If the package_type belongs
// to a GitHub Packages registry that only supports repository-scoped
// permissions, your token must also include the repo scope. For the list of GitHub Packages registries that only support
// repository-scoped permissions, see "About permissions for GitHub Packages
// [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - packageType - The type of supported package. Packages in GitHub's Gradle registry have the type maven. Docker images pushed
//     to GitHub's Container registry (ghcr.io) have the type container. You can use the type
//     docker to find images that were pushed to GitHub's Docker registry (docker.pkg.github.com), even if these have now been
//     migrated to the Container registry.
//   - options - GitHubV3RESTAPIClientPackagesListPackagesForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.PackagesListPackagesForUser
//     method.
func (client *GitHubV3RESTAPIClient) PackagesListPackagesForUser(ctx context.Context, packageType Enum332, options *GitHubV3RESTAPIClientPackagesListPackagesForUserOptions) (GitHubV3RESTAPIClientPackagesListPackagesForUserResponse, error) {
	req, err := client.packagesListPackagesForUserCreateRequest(ctx, packageType, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesListPackagesForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesListPackagesForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientPackagesListPackagesForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesListPackagesForUserHandleResponse(resp)
}

// packagesListPackagesForUserCreateRequest creates the PackagesListPackagesForUser request.
func (client *GitHubV3RESTAPIClient) packagesListPackagesForUserCreateRequest(ctx context.Context, packageType Enum332, options *GitHubV3RESTAPIClientPackagesListPackagesForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/packages"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("package_type", string(packageType))
	if client.visibility != nil {
		reqQP.Set("visibility", string(*client.visibility))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesListPackagesForUserHandleResponse handles the PackagesListPackagesForUser response.
func (client *GitHubV3RESTAPIClient) packagesListPackagesForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesListPackagesForUserResponse, error) {
	result := GitHubV3RESTAPIClientPackagesListPackagesForUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Package
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesListPackagesForUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesListPackagesForUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPackagesListPackagesForUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPackagesListPackagesForUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PackagesRestorePackageForAuthenticatedUser - Restores a package owned by the authenticated user.
// You can restore a deleted package under the following conditions:
// * The package was deleted within the last 30 days.
// * The same package namespace and version is still available and not reused for a new package. If the same package namespace
// is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.
// To use this endpoint, you must authenticate using an access token with the read:packages and write:packages scopes. If
// the package_type belongs to a GitHub Packages registry that only supports
// repository-scoped permissions, your token must also include the repo scope. For the list of GitHub Packages registries
// that only support repository-scoped permissions, see "About permissions for
// GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesRestorePackageForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.PackagesRestorePackageForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) PackagesRestorePackageForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientPackagesRestorePackageForAuthenticatedUserOptions) (GitHubV3RESTAPIClientPackagesRestorePackageForAuthenticatedUserResponse, error) {
	req, err := client.packagesRestorePackageForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPackagesRestorePackageForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesRestorePackageForAuthenticatedUserHandleResponse(resp)
}

// packagesRestorePackageForAuthenticatedUserCreateRequest creates the PackagesRestorePackageForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) packagesRestorePackageForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesRestorePackageForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/packages/{package_type}/{package_name}/restore"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Token != nil {
		reqQP.Set("token", *options.Token)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesRestorePackageForAuthenticatedUserHandleResponse handles the PackagesRestorePackageForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) packagesRestorePackageForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesRestorePackageForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientPackagesRestorePackageForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// PackagesRestorePackageForOrg - Restores an entire package in an organization.
// You can restore a deleted package under the following conditions:
// * The package was deleted within the last 30 days.
// * The same package namespace and version is still available and not reused for a new package. If the same package namespace
// is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.
// To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the
// read:packages and write:packages scopes. In addition:
// * If the package_type belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token
// must also include the repo scope. For the list of these registries, see "About
// permissions for GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// * If the package_type belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions
// to the package you want to restore. For the list of these registries,
// see "About permissions for GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesRestorePackageForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.PackagesRestorePackageForOrg
//     method.
func (client *GitHubV3RESTAPIClient) PackagesRestorePackageForOrg(ctx context.Context, options *GitHubV3RESTAPIClientPackagesRestorePackageForOrgOptions) (GitHubV3RESTAPIClientPackagesRestorePackageForOrgResponse, error) {
	req, err := client.packagesRestorePackageForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPackagesRestorePackageForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesRestorePackageForOrgHandleResponse(resp)
}

// packagesRestorePackageForOrgCreateRequest creates the PackagesRestorePackageForOrg request.
func (client *GitHubV3RESTAPIClient) packagesRestorePackageForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesRestorePackageForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/packages/{package_type}/{package_name}/restore"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Token != nil {
		reqQP.Set("token", *options.Token)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesRestorePackageForOrgHandleResponse handles the PackagesRestorePackageForOrg response.
func (client *GitHubV3RESTAPIClient) packagesRestorePackageForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesRestorePackageForOrgResponse, error) {
	result := GitHubV3RESTAPIClientPackagesRestorePackageForOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageForOrgResponse{}, err
	}
	return result, nil
}

// PackagesRestorePackageForUser - Restores an entire package for a user.
// You can restore a deleted package under the following conditions:
// * The package was deleted within the last 30 days.
// * The same package namespace and version is still available and not reused for a new package. If the same package namespace
// is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.
// To use this endpoint, you must authenticate using an access token with the read:packages and write:packages scopes. In
// addition:
// * If the package_type belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token
// must also include the repo scope. For the list of these registries, see "About
// permissions for GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// * If the package_type belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions
// to the package you want to restore. For the list of these registries,
// see "About permissions for GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesRestorePackageForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.PackagesRestorePackageForUser
//     method.
func (client *GitHubV3RESTAPIClient) PackagesRestorePackageForUser(ctx context.Context, options *GitHubV3RESTAPIClientPackagesRestorePackageForUserOptions) (GitHubV3RESTAPIClientPackagesRestorePackageForUserResponse, error) {
	req, err := client.packagesRestorePackageForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPackagesRestorePackageForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesRestorePackageForUserHandleResponse(resp)
}

// packagesRestorePackageForUserCreateRequest creates the PackagesRestorePackageForUser request.
func (client *GitHubV3RESTAPIClient) packagesRestorePackageForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesRestorePackageForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/packages/{package_type}/{package_name}/restore"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Token != nil {
		reqQP.Set("token", *options.Token)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesRestorePackageForUserHandleResponse handles the PackagesRestorePackageForUser response.
func (client *GitHubV3RESTAPIClient) packagesRestorePackageForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesRestorePackageForUserResponse, error) {
	result := GitHubV3RESTAPIClientPackagesRestorePackageForUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageForUserResponse{}, err
	}
	return result, nil
}

// PackagesRestorePackageVersionForAuthenticatedUser - Restores a package version owned by the authenticated user.
// You can restore a deleted package version under the following conditions:
// * The package was deleted within the last 30 days.
// * The same package namespace and version is still available and not reused for a new package. If the same package namespace
// is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.
// To use this endpoint, you must authenticate using an access token with the read:packages and write:packages scopes. If
// the package_type belongs to a GitHub Packages registry that only supports
// repository-scoped permissions, your token must also include the repo scope. For the list of GitHub Packages registries
// that only support repository-scoped permissions, see "About permissions for
// GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesRestorePackageVersionForAuthenticatedUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.PackagesRestorePackageVersionForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) PackagesRestorePackageVersionForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientPackagesRestorePackageVersionForAuthenticatedUserOptions) (GitHubV3RESTAPIClientPackagesRestorePackageVersionForAuthenticatedUserResponse, error) {
	req, err := client.packagesRestorePackageVersionForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageVersionForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageVersionForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPackagesRestorePackageVersionForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesRestorePackageVersionForAuthenticatedUserHandleResponse(resp)
}

// packagesRestorePackageVersionForAuthenticatedUserCreateRequest creates the PackagesRestorePackageVersionForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) packagesRestorePackageVersionForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesRestorePackageVersionForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	urlPath = strings.ReplaceAll(urlPath, "{package_version_id}", url.PathEscape(strconv.FormatInt(int64(client.packageVersionID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesRestorePackageVersionForAuthenticatedUserHandleResponse handles the PackagesRestorePackageVersionForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) packagesRestorePackageVersionForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesRestorePackageVersionForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientPackagesRestorePackageVersionForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageVersionForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// PackagesRestorePackageVersionForOrg - Restores a specific package version in an organization.
// You can restore a deleted package under the following conditions:
// * The package was deleted within the last 30 days.
// * The same package namespace and version is still available and not reused for a new package. If the same package namespace
// is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.
// To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the
// read:packages and write:packages scopes. In addition:
// * If the package_type belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token
// must also include the repo scope. For the list of these registries, see "About
// permissions for GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// * If the package_type belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions
// to the package whose version you want to restore. For the list of these
// registries, see "About permissions for GitHub Packages
// [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesRestorePackageVersionForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.PackagesRestorePackageVersionForOrg
//     method.
func (client *GitHubV3RESTAPIClient) PackagesRestorePackageVersionForOrg(ctx context.Context, options *GitHubV3RESTAPIClientPackagesRestorePackageVersionForOrgOptions) (GitHubV3RESTAPIClientPackagesRestorePackageVersionForOrgResponse, error) {
	req, err := client.packagesRestorePackageVersionForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageVersionForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageVersionForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPackagesRestorePackageVersionForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesRestorePackageVersionForOrgHandleResponse(resp)
}

// packagesRestorePackageVersionForOrgCreateRequest creates the PackagesRestorePackageVersionForOrg request.
func (client *GitHubV3RESTAPIClient) packagesRestorePackageVersionForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesRestorePackageVersionForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	urlPath = strings.ReplaceAll(urlPath, "{package_version_id}", url.PathEscape(strconv.FormatInt(int64(client.packageVersionID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesRestorePackageVersionForOrgHandleResponse handles the PackagesRestorePackageVersionForOrg response.
func (client *GitHubV3RESTAPIClient) packagesRestorePackageVersionForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesRestorePackageVersionForOrgResponse, error) {
	result := GitHubV3RESTAPIClientPackagesRestorePackageVersionForOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageVersionForOrgResponse{}, err
	}
	return result, nil
}

// PackagesRestorePackageVersionForUser - Restores a specific package version for a user.
// You can restore a deleted package under the following conditions:
// * The package was deleted within the last 30 days.
// * The same package namespace and version is still available and not reused for a new package. If the same package namespace
// is not available, you will not be able to restore your package. In this
// scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.
// To use this endpoint, you must authenticate using an access token with the read:packages and write:packages scopes. In
// addition:
// * If the package_type belongs to a GitHub Packages registry that only supports repository-scoped permissions, your token
// must also include the repo scope. For the list of these registries, see "About
// permissions for GitHub Packages [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages]."
// * If the package_type belongs to a GitHub Packages registry that supports granular permissions, you must have admin permissions
// to the package whose version you want to restore. For the list of these
// registries, see "About permissions for GitHub Packages
// [https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPackagesRestorePackageVersionForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.PackagesRestorePackageVersionForUser
//     method.
func (client *GitHubV3RESTAPIClient) PackagesRestorePackageVersionForUser(ctx context.Context, options *GitHubV3RESTAPIClientPackagesRestorePackageVersionForUserOptions) (GitHubV3RESTAPIClientPackagesRestorePackageVersionForUserResponse, error) {
	req, err := client.packagesRestorePackageVersionForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageVersionForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageVersionForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPackagesRestorePackageVersionForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.packagesRestorePackageVersionForUserHandleResponse(resp)
}

// packagesRestorePackageVersionForUserCreateRequest creates the PackagesRestorePackageVersionForUser request.
func (client *GitHubV3RESTAPIClient) packagesRestorePackageVersionForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPackagesRestorePackageVersionForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
	if client.packageType == "" {
		return nil, errors.New("parameter client.packageType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_type}", url.PathEscape(string(client.packageType)))
	if client.packageName == "" {
		return nil, errors.New("parameter client.packageName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{package_name}", url.PathEscape(client.packageName))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	urlPath = strings.ReplaceAll(urlPath, "{package_version_id}", url.PathEscape(strconv.FormatInt(int64(client.packageVersionID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// packagesRestorePackageVersionForUserHandleResponse handles the PackagesRestorePackageVersionForUser response.
func (client *GitHubV3RESTAPIClient) packagesRestorePackageVersionForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPackagesRestorePackageVersionForUserResponse, error) {
	result := GitHubV3RESTAPIClientPackagesRestorePackageVersionForUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientPackagesRestorePackageVersionForUserResponse{}, err
	}
	return result, nil
}

// ProjectsAddCollaborator - Adds a collaborator to an organization project and sets their permission level. You must be an
// organization owner or a project admin to add a collaborator.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsAddCollaboratorOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsAddCollaborator
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsAddCollaborator(ctx context.Context, body Paths1F5Aw67ProjectsProjectIDCollaboratorsUsernamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsAddCollaboratorOptions) (GitHubV3RESTAPIClientProjectsAddCollaboratorResponse, error) {
	req, err := client.projectsAddCollaboratorCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsAddCollaboratorResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsAddCollaboratorResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientProjectsAddCollaboratorResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsAddCollaboratorHandleResponse(resp)
}

// projectsAddCollaboratorCreateRequest creates the ProjectsAddCollaborator request.
func (client *GitHubV3RESTAPIClient) projectsAddCollaboratorCreateRequest(ctx context.Context, body Paths1F5Aw67ProjectsProjectIDCollaboratorsUsernamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsAddCollaboratorOptions) (*policy.Request, error) {
	urlPath := "/projects/{project_id}/collaborators/{username}"
	urlPath = strings.ReplaceAll(urlPath, "{project_id}", url.PathEscape(strconv.FormatInt(int64(client.projectID), 10)))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// projectsAddCollaboratorHandleResponse handles the ProjectsAddCollaborator response.
func (client *GitHubV3RESTAPIClient) projectsAddCollaboratorHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsAddCollaboratorResponse, error) {
	result := GitHubV3RESTAPIClientProjectsAddCollaboratorResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsAddCollaboratorResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsAddCollaboratorResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsAddCollaboratorResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsAddCollaboratorResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsAddCollaboratorResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsCreateCard - Create a project card
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsCreateCardOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsCreateCard
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsCreateCard(ctx context.Context, body Paths18Rg39SProjectsColumnsColumnIDCardsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsCreateCardOptions) (GitHubV3RESTAPIClientProjectsCreateCardResponse, error) {
	req, err := client.projectsCreateCardCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsCreateCardResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsCreateCardResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusUnprocessableEntity, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientProjectsCreateCardResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsCreateCardHandleResponse(resp)
}

// projectsCreateCardCreateRequest creates the ProjectsCreateCard request.
func (client *GitHubV3RESTAPIClient) projectsCreateCardCreateRequest(ctx context.Context, body Paths18Rg39SProjectsColumnsColumnIDCardsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsCreateCardOptions) (*policy.Request, error) {
	urlPath := "/projects/columns/{column_id}/cards"
	urlPath = strings.ReplaceAll(urlPath, "{column_id}", url.PathEscape(strconv.FormatInt(int64(client.columnID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// projectsCreateCardHandleResponse handles the ProjectsCreateCard response.
func (client *GitHubV3RESTAPIClient) projectsCreateCardHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsCreateCardResponse, error) {
	result := GitHubV3RESTAPIClientProjectsCreateCardResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val ProjectCard
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateCardResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateCardResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateCardResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val Paths6H37GhProjectsColumnsColumnIDCardsPostResponses422ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateCardResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Paths1Hf5OwlProjectsColumnsColumnIDCardsPostResponses503ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateCardResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsCreateCardResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsCreateColumn - Create a project column
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsCreateColumnOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsCreateColumn
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsCreateColumn(ctx context.Context, body Paths1Tcc0VlProjectsProjectIDColumnsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsCreateColumnOptions) (GitHubV3RESTAPIClientProjectsCreateColumnResponse, error) {
	req, err := client.projectsCreateColumnCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsCreateColumnResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsCreateColumnResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientProjectsCreateColumnResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsCreateColumnHandleResponse(resp)
}

// projectsCreateColumnCreateRequest creates the ProjectsCreateColumn request.
func (client *GitHubV3RESTAPIClient) projectsCreateColumnCreateRequest(ctx context.Context, body Paths1Tcc0VlProjectsProjectIDColumnsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsCreateColumnOptions) (*policy.Request, error) {
	urlPath := "/projects/{project_id}/columns"
	urlPath = strings.ReplaceAll(urlPath, "{project_id}", url.PathEscape(strconv.FormatInt(int64(client.projectID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// projectsCreateColumnHandleResponse handles the ProjectsCreateColumn response.
func (client *GitHubV3RESTAPIClient) projectsCreateColumnHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsCreateColumnResponse, error) {
	result := GitHubV3RESTAPIClientProjectsCreateColumnResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val ProjectColumn
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateColumnResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateColumnResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateColumnResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateColumnResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsCreateColumnResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsCreateForAuthenticatedUser - Creates a user project board. Returns a 410 Gone status if the user does not have
// existing classic projects. If you do not have sufficient privileges to perform this action, a 401 Unauthorized or 410
// Gone status is returned.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsCreateForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsCreateForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsCreateForAuthenticatedUser(ctx context.Context, body PathsB91M33UserProjectsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsCreateForAuthenticatedUserOptions) (GitHubV3RESTAPIClientProjectsCreateForAuthenticatedUserResponse, error) {
	req, err := client.projectsCreateForAuthenticatedUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientProjectsCreateForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsCreateForAuthenticatedUserHandleResponse(resp)
}

// projectsCreateForAuthenticatedUserCreateRequest creates the ProjectsCreateForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) projectsCreateForAuthenticatedUserCreateRequest(ctx context.Context, body PathsB91M33UserProjectsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsCreateForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/projects"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// projectsCreateForAuthenticatedUserHandleResponse handles the ProjectsCreateForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) projectsCreateForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsCreateForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientProjectsCreateForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Project
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsCreateForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsCreateForOrg - Creates an organization project board. Returns a 410 Gone status if projects are disabled in the
// organization or if the organization does not have existing classic projects. If you do not have
// sufficient privileges to perform this action, a 401 Unauthorized or 410 Gone status is returned.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsCreateForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsCreateForOrg
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsCreateForOrg(ctx context.Context, body Paths14S7J96OrgsOrgProjectsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsCreateForOrgOptions) (GitHubV3RESTAPIClientProjectsCreateForOrgResponse, error) {
	req, err := client.projectsCreateForOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusGone, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientProjectsCreateForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsCreateForOrgHandleResponse(resp)
}

// projectsCreateForOrgCreateRequest creates the ProjectsCreateForOrg request.
func (client *GitHubV3RESTAPIClient) projectsCreateForOrgCreateRequest(ctx context.Context, body Paths14S7J96OrgsOrgProjectsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsCreateForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/projects"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// projectsCreateForOrgHandleResponse handles the ProjectsCreateForOrg response.
func (client *GitHubV3RESTAPIClient) projectsCreateForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsCreateForOrgResponse, error) {
	result := GitHubV3RESTAPIClientProjectsCreateForOrgResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Project
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsCreateForOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsCreateForRepo - Creates a repository project board. Returns a 410 Gone status if projects are disabled in the repository
// or if the repository does not have existing classic projects. If you do not have sufficient
// privileges to perform this action, a 401 Unauthorized or 410 Gone status is returned.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsCreateForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsCreateForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsCreateForRepo(ctx context.Context, body PathsR9YtfcReposOwnerRepoProjectsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsCreateForRepoOptions) (GitHubV3RESTAPIClientProjectsCreateForRepoResponse, error) {
	req, err := client.projectsCreateForRepoCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusGone, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientProjectsCreateForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsCreateForRepoHandleResponse(resp)
}

// projectsCreateForRepoCreateRequest creates the ProjectsCreateForRepo request.
func (client *GitHubV3RESTAPIClient) projectsCreateForRepoCreateRequest(ctx context.Context, body PathsR9YtfcReposOwnerRepoProjectsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsCreateForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/projects"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// projectsCreateForRepoHandleResponse handles the ProjectsCreateForRepo response.
func (client *GitHubV3RESTAPIClient) projectsCreateForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsCreateForRepoResponse, error) {
	result := GitHubV3RESTAPIClientProjectsCreateForRepoResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Project
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsCreateForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsCreateForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsDelete - Deletes a project board. Returns a 404 Not Found status if projects are disabled.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsDeleteOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsDelete
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsDelete(ctx context.Context, options *GitHubV3RESTAPIClientProjectsDeleteOptions) (GitHubV3RESTAPIClientProjectsDeleteResponse, error) {
	req, err := client.projectsDeleteCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsDeleteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusGone) {
		return GitHubV3RESTAPIClientProjectsDeleteResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsDeleteHandleResponse(resp)
}

// projectsDeleteCreateRequest creates the ProjectsDelete request.
func (client *GitHubV3RESTAPIClient) projectsDeleteCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientProjectsDeleteOptions) (*policy.Request, error) {
	urlPath := "/projects/{project_id}"
	urlPath = strings.ReplaceAll(urlPath, "{project_id}", url.PathEscape(strconv.FormatInt(int64(client.projectID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// projectsDeleteHandleResponse handles the ProjectsDelete response.
func (client *GitHubV3RESTAPIClient) projectsDeleteHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsDeleteResponse, error) {
	result := GitHubV3RESTAPIClientProjectsDeleteResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsDeleteResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val PathsVog3YwProjectsProjectIDDeleteResponses403ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsDeleteResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsDeleteResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsDeleteResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsDeleteResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsDeleteCard - Delete a project card
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsDeleteCardOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsDeleteCard
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsDeleteCard(ctx context.Context, options *GitHubV3RESTAPIClientProjectsDeleteCardOptions) (GitHubV3RESTAPIClientProjectsDeleteCardResponse, error) {
	req, err := client.projectsDeleteCardCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsDeleteCardResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsDeleteCardResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientProjectsDeleteCardResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsDeleteCardHandleResponse(resp)
}

// projectsDeleteCardCreateRequest creates the ProjectsDeleteCard request.
func (client *GitHubV3RESTAPIClient) projectsDeleteCardCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientProjectsDeleteCardOptions) (*policy.Request, error) {
	urlPath := "/projects/columns/cards/{card_id}"
	urlPath = strings.ReplaceAll(urlPath, "{card_id}", url.PathEscape(strconv.FormatInt(int64(client.cardID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// projectsDeleteCardHandleResponse handles the ProjectsDeleteCard response.
func (client *GitHubV3RESTAPIClient) projectsDeleteCardHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsDeleteCardResponse, error) {
	result := GitHubV3RESTAPIClientProjectsDeleteCardResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsDeleteCardResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val Paths7F7VlmProjectsColumnsCardsCardIDDeleteResponses403ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsDeleteCardResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsDeleteCardResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsDeleteCardResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsDeleteColumn - Delete a project column
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsDeleteColumnOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsDeleteColumn
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsDeleteColumn(ctx context.Context, options *GitHubV3RESTAPIClientProjectsDeleteColumnOptions) (GitHubV3RESTAPIClientProjectsDeleteColumnResponse, error) {
	req, err := client.projectsDeleteColumnCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsDeleteColumnResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsDeleteColumnResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientProjectsDeleteColumnResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsDeleteColumnHandleResponse(resp)
}

// projectsDeleteColumnCreateRequest creates the ProjectsDeleteColumn request.
func (client *GitHubV3RESTAPIClient) projectsDeleteColumnCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientProjectsDeleteColumnOptions) (*policy.Request, error) {
	urlPath := "/projects/columns/{column_id}"
	urlPath = strings.ReplaceAll(urlPath, "{column_id}", url.PathEscape(strconv.FormatInt(int64(client.columnID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// projectsDeleteColumnHandleResponse handles the ProjectsDeleteColumn response.
func (client *GitHubV3RESTAPIClient) projectsDeleteColumnHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsDeleteColumnResponse, error) {
	result := GitHubV3RESTAPIClientProjectsDeleteColumnResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientProjectsDeleteColumnResponse{}, err
	}
	return result, nil
}

// ProjectsGet - Gets a project by its id. Returns a 404 Not Found status if projects are disabled. If you do not have sufficient
// privileges to perform this action, a 401 Unauthorized or 410 Gone status is returned.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsGetOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsGet
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsGet(ctx context.Context, options *GitHubV3RESTAPIClientProjectsGetOptions) (GitHubV3RESTAPIClientProjectsGetResponse, error) {
	req, err := client.projectsGetCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientProjectsGetResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsGetHandleResponse(resp)
}

// projectsGetCreateRequest creates the ProjectsGet request.
func (client *GitHubV3RESTAPIClient) projectsGetCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientProjectsGetOptions) (*policy.Request, error) {
	urlPath := "/projects/{project_id}"
	urlPath = strings.ReplaceAll(urlPath, "{project_id}", url.PathEscape(strconv.FormatInt(int64(client.projectID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// projectsGetHandleResponse handles the ProjectsGet response.
func (client *GitHubV3RESTAPIClient) projectsGetHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsGetResponse, error) {
	result := GitHubV3RESTAPIClientProjectsGetResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Project
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsGetResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsGetResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsGetResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsGetResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsGetCard - Get a project card
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsGetCardOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsGetCard
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsGetCard(ctx context.Context, options *GitHubV3RESTAPIClientProjectsGetCardOptions) (GitHubV3RESTAPIClientProjectsGetCardResponse, error) {
	req, err := client.projectsGetCardCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsGetCardResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsGetCardResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientProjectsGetCardResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsGetCardHandleResponse(resp)
}

// projectsGetCardCreateRequest creates the ProjectsGetCard request.
func (client *GitHubV3RESTAPIClient) projectsGetCardCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientProjectsGetCardOptions) (*policy.Request, error) {
	urlPath := "/projects/columns/cards/{card_id}"
	urlPath = strings.ReplaceAll(urlPath, "{card_id}", url.PathEscape(strconv.FormatInt(int64(client.cardID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// projectsGetCardHandleResponse handles the ProjectsGetCard response.
func (client *GitHubV3RESTAPIClient) projectsGetCardHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsGetCardResponse, error) {
	result := GitHubV3RESTAPIClientProjectsGetCardResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProjectCard
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsGetCardResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsGetCardResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsGetCardResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsGetCardResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsGetCardResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsGetColumn - Get a project column
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsGetColumnOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsGetColumn
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsGetColumn(ctx context.Context, options *GitHubV3RESTAPIClientProjectsGetColumnOptions) (GitHubV3RESTAPIClientProjectsGetColumnResponse, error) {
	req, err := client.projectsGetColumnCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsGetColumnResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsGetColumnResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientProjectsGetColumnResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsGetColumnHandleResponse(resp)
}

// projectsGetColumnCreateRequest creates the ProjectsGetColumn request.
func (client *GitHubV3RESTAPIClient) projectsGetColumnCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientProjectsGetColumnOptions) (*policy.Request, error) {
	urlPath := "/projects/columns/{column_id}"
	urlPath = strings.ReplaceAll(urlPath, "{column_id}", url.PathEscape(strconv.FormatInt(int64(client.columnID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// projectsGetColumnHandleResponse handles the ProjectsGetColumn response.
func (client *GitHubV3RESTAPIClient) projectsGetColumnHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsGetColumnResponse, error) {
	result := GitHubV3RESTAPIClientProjectsGetColumnResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProjectColumn
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsGetColumnResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsGetColumnResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsGetColumnResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsGetColumnResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsGetColumnResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsGetPermissionForUser - Returns the collaborator's permission level for an organization project. Possible values
// for the permission key: admin, write, read, none. You must be an organization owner or a project admin to
// review a user's permission level.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsGetPermissionForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsGetPermissionForUser
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsGetPermissionForUser(ctx context.Context, options *GitHubV3RESTAPIClientProjectsGetPermissionForUserOptions) (GitHubV3RESTAPIClientProjectsGetPermissionForUserResponse, error) {
	req, err := client.projectsGetPermissionForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsGetPermissionForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsGetPermissionForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientProjectsGetPermissionForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsGetPermissionForUserHandleResponse(resp)
}

// projectsGetPermissionForUserCreateRequest creates the ProjectsGetPermissionForUser request.
func (client *GitHubV3RESTAPIClient) projectsGetPermissionForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientProjectsGetPermissionForUserOptions) (*policy.Request, error) {
	urlPath := "/projects/{project_id}/collaborators/{username}/permission"
	urlPath = strings.ReplaceAll(urlPath, "{project_id}", url.PathEscape(strconv.FormatInt(int64(client.projectID), 10)))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// projectsGetPermissionForUserHandleResponse handles the ProjectsGetPermissionForUser response.
func (client *GitHubV3RESTAPIClient) projectsGetPermissionForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsGetPermissionForUserResponse, error) {
	result := GitHubV3RESTAPIClientProjectsGetPermissionForUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProjectCollaboratorPermission
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsGetPermissionForUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsGetPermissionForUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsGetPermissionForUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsGetPermissionForUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsGetPermissionForUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsGetPermissionForUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsListCards - List project cards
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsListCardsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsListCards
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsListCards(ctx context.Context, options *GitHubV3RESTAPIClientProjectsListCardsOptions) (GitHubV3RESTAPIClientProjectsListCardsResponse, error) {
	req, err := client.projectsListCardsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsListCardsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsListCardsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientProjectsListCardsResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsListCardsHandleResponse(resp)
}

// projectsListCardsCreateRequest creates the ProjectsListCards request.
func (client *GitHubV3RESTAPIClient) projectsListCardsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientProjectsListCardsOptions) (*policy.Request, error) {
	urlPath := "/projects/columns/{column_id}/cards"
	urlPath = strings.ReplaceAll(urlPath, "{column_id}", url.PathEscape(strconv.FormatInt(int64(client.columnID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ArchivedState != nil {
		reqQP.Set("archived_state", string(*options.ArchivedState))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// projectsListCardsHandleResponse handles the ProjectsListCards response.
func (client *GitHubV3RESTAPIClient) projectsListCardsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsListCardsResponse, error) {
	result := GitHubV3RESTAPIClientProjectsListCardsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*ProjectCard
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListCardsResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListCardsResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListCardsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsListCardsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsListCollaborators - Lists the collaborators for an organization project. For a project, the list of collaborators
// includes outside collaborators, organization members that are direct collaborators, organization members
// with access through team memberships, organization members with access through default organization permissions, and organization
// owners. You must be an organization owner or a project admin to list
// collaborators.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsListCollaboratorsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsListCollaborators
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsListCollaborators(ctx context.Context, options *GitHubV3RESTAPIClientProjectsListCollaboratorsOptions) (GitHubV3RESTAPIClientProjectsListCollaboratorsResponse, error) {
	req, err := client.projectsListCollaboratorsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsListCollaboratorsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsListCollaboratorsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientProjectsListCollaboratorsResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsListCollaboratorsHandleResponse(resp)
}

// projectsListCollaboratorsCreateRequest creates the ProjectsListCollaborators request.
func (client *GitHubV3RESTAPIClient) projectsListCollaboratorsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientProjectsListCollaboratorsOptions) (*policy.Request, error) {
	urlPath := "/projects/{project_id}/collaborators"
	urlPath = strings.ReplaceAll(urlPath, "{project_id}", url.PathEscape(strconv.FormatInt(int64(client.projectID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Affiliation != nil {
		reqQP.Set("affiliation", string(*options.Affiliation))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// projectsListCollaboratorsHandleResponse handles the ProjectsListCollaborators response.
func (client *GitHubV3RESTAPIClient) projectsListCollaboratorsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsListCollaboratorsResponse, error) {
	result := GitHubV3RESTAPIClientProjectsListCollaboratorsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*SimpleUser
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListCollaboratorsResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListCollaboratorsResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListCollaboratorsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListCollaboratorsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListCollaboratorsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsListCollaboratorsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsListColumns - List project columns
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsListColumnsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsListColumns
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsListColumns(ctx context.Context, options *GitHubV3RESTAPIClientProjectsListColumnsOptions) (GitHubV3RESTAPIClientProjectsListColumnsResponse, error) {
	req, err := client.projectsListColumnsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsListColumnsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsListColumnsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientProjectsListColumnsResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsListColumnsHandleResponse(resp)
}

// projectsListColumnsCreateRequest creates the ProjectsListColumns request.
func (client *GitHubV3RESTAPIClient) projectsListColumnsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientProjectsListColumnsOptions) (*policy.Request, error) {
	urlPath := "/projects/{project_id}/columns"
	urlPath = strings.ReplaceAll(urlPath, "{project_id}", url.PathEscape(strconv.FormatInt(int64(client.projectID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// projectsListColumnsHandleResponse handles the ProjectsListColumns response.
func (client *GitHubV3RESTAPIClient) projectsListColumnsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsListColumnsResponse, error) {
	result := GitHubV3RESTAPIClientProjectsListColumnsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*ProjectColumn
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListColumnsResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListColumnsResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListColumnsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsListColumnsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsListForOrg - Lists the projects in an organization. Returns a 404 Not Found status if projects are disabled in
// the organization. If you do not have sufficient privileges to perform this action, a 401 Unauthorized
// or 410 Gone status is returned.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsListForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsListForOrg
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsListForOrg(ctx context.Context, options *GitHubV3RESTAPIClientProjectsListForOrgOptions) (GitHubV3RESTAPIClientProjectsListForOrgResponse, error) {
	req, err := client.projectsListForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsListForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsListForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientProjectsListForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsListForOrgHandleResponse(resp)
}

// projectsListForOrgCreateRequest creates the ProjectsListForOrg request.
func (client *GitHubV3RESTAPIClient) projectsListForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientProjectsListForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/projects"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.State != nil {
		reqQP.Set("state", string(*options.State))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// projectsListForOrgHandleResponse handles the ProjectsListForOrg response.
func (client *GitHubV3RESTAPIClient) projectsListForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsListForOrgResponse, error) {
	result := GitHubV3RESTAPIClientProjectsListForOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Project
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListForOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsListForOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsListForRepo - Lists the projects in a repository. Returns a 404 Not Found status if projects are disabled in the
// repository. If you do not have sufficient privileges to perform this action, a 401 Unauthorized or
// 410 Gone status is returned.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsListForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsListForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsListForRepo(ctx context.Context, options *GitHubV3RESTAPIClientProjectsListForRepoOptions) (GitHubV3RESTAPIClientProjectsListForRepoResponse, error) {
	req, err := client.projectsListForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsListForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsListForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusGone, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientProjectsListForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsListForRepoHandleResponse(resp)
}

// projectsListForRepoCreateRequest creates the ProjectsListForRepo request.
func (client *GitHubV3RESTAPIClient) projectsListForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientProjectsListForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/projects"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.State != nil {
		reqQP.Set("state", string(*options.State))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// projectsListForRepoHandleResponse handles the ProjectsListForRepo response.
func (client *GitHubV3RESTAPIClient) projectsListForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsListForRepoResponse, error) {
	result := GitHubV3RESTAPIClientProjectsListForRepoResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Project
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsListForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsListForUser - List user projects
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsListForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsListForUser
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsListForUser(ctx context.Context, options *GitHubV3RESTAPIClientProjectsListForUserOptions) (GitHubV3RESTAPIClientProjectsListForUserResponse, error) {
	req, err := client.projectsListForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsListForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsListForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientProjectsListForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsListForUserHandleResponse(resp)
}

// projectsListForUserCreateRequest creates the ProjectsListForUser request.
func (client *GitHubV3RESTAPIClient) projectsListForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientProjectsListForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/projects"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.State != nil {
		reqQP.Set("state", string(*options.State))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// projectsListForUserHandleResponse handles the ProjectsListForUser response.
func (client *GitHubV3RESTAPIClient) projectsListForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsListForUserResponse, error) {
	result := GitHubV3RESTAPIClientProjectsListForUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Project
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListForUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsListForUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsListForUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsMoveCard - Move a project card
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsMoveCardOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsMoveCard
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsMoveCard(ctx context.Context, body Paths16D3L0RProjectsColumnsCardsCardIDMovesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsMoveCardOptions) (GitHubV3RESTAPIClientProjectsMoveCardResponse, error) {
	req, err := client.projectsMoveCardCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsMoveCardResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsMoveCardResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusUnprocessableEntity, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientProjectsMoveCardResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsMoveCardHandleResponse(resp)
}

// projectsMoveCardCreateRequest creates the ProjectsMoveCard request.
func (client *GitHubV3RESTAPIClient) projectsMoveCardCreateRequest(ctx context.Context, body Paths16D3L0RProjectsColumnsCardsCardIDMovesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsMoveCardOptions) (*policy.Request, error) {
	urlPath := "/projects/columns/cards/{card_id}/moves"
	urlPath = strings.ReplaceAll(urlPath, "{card_id}", url.PathEscape(strconv.FormatInt(int64(client.cardID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// projectsMoveCardHandleResponse handles the ProjectsMoveCard response.
func (client *GitHubV3RESTAPIClient) projectsMoveCardHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsMoveCardResponse, error) {
	result := GitHubV3RESTAPIClientProjectsMoveCardResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsMoveCardResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsMoveCardResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val Paths1QklxoqProjectsColumnsCardsCardIDMovesPostResponses403ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsMoveCardResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsMoveCardResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Paths1FshfmfProjectsColumnsCardsCardIDMovesPostResponses503ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsMoveCardResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsMoveCardResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsMoveColumn - Move a project column
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsMoveColumnOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsMoveColumn
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsMoveColumn(ctx context.Context, body PathsPf2K8OProjectsColumnsColumnIDMovesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsMoveColumnOptions) (GitHubV3RESTAPIClientProjectsMoveColumnResponse, error) {
	req, err := client.projectsMoveColumnCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsMoveColumnResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsMoveColumnResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientProjectsMoveColumnResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsMoveColumnHandleResponse(resp)
}

// projectsMoveColumnCreateRequest creates the ProjectsMoveColumn request.
func (client *GitHubV3RESTAPIClient) projectsMoveColumnCreateRequest(ctx context.Context, body PathsPf2K8OProjectsColumnsColumnIDMovesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsMoveColumnOptions) (*policy.Request, error) {
	urlPath := "/projects/columns/{column_id}/moves"
	urlPath = strings.ReplaceAll(urlPath, "{column_id}", url.PathEscape(strconv.FormatInt(int64(client.columnID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// projectsMoveColumnHandleResponse handles the ProjectsMoveColumn response.
func (client *GitHubV3RESTAPIClient) projectsMoveColumnHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsMoveColumnResponse, error) {
	result := GitHubV3RESTAPIClientProjectsMoveColumnResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsMoveColumnResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsMoveColumnResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsMoveColumnResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsMoveColumnResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsMoveColumnResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsRemoveCollaborator - Removes a collaborator from an organization project. You must be an organization owner or
// a project admin to remove a collaborator.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsRemoveCollaboratorOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsRemoveCollaborator
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsRemoveCollaborator(ctx context.Context, options *GitHubV3RESTAPIClientProjectsRemoveCollaboratorOptions) (GitHubV3RESTAPIClientProjectsRemoveCollaboratorResponse, error) {
	req, err := client.projectsRemoveCollaboratorCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsRemoveCollaboratorResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsRemoveCollaboratorResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientProjectsRemoveCollaboratorResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsRemoveCollaboratorHandleResponse(resp)
}

// projectsRemoveCollaboratorCreateRequest creates the ProjectsRemoveCollaborator request.
func (client *GitHubV3RESTAPIClient) projectsRemoveCollaboratorCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientProjectsRemoveCollaboratorOptions) (*policy.Request, error) {
	urlPath := "/projects/{project_id}/collaborators/{username}"
	urlPath = strings.ReplaceAll(urlPath, "{project_id}", url.PathEscape(strconv.FormatInt(int64(client.projectID), 10)))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// projectsRemoveCollaboratorHandleResponse handles the ProjectsRemoveCollaborator response.
func (client *GitHubV3RESTAPIClient) projectsRemoveCollaboratorHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsRemoveCollaboratorResponse, error) {
	result := GitHubV3RESTAPIClientProjectsRemoveCollaboratorResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsRemoveCollaboratorResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsRemoveCollaboratorResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsRemoveCollaboratorResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsRemoveCollaboratorResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsRemoveCollaboratorResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsUpdate - Updates a project board's information. Returns a 404 Not Found status if projects are disabled. If you
// do not have sufficient privileges to perform this action, a 401 Unauthorized or 410 Gone status
// is returned.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsUpdateOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsUpdate
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsUpdate(ctx context.Context, body PathsR7QxoqProjectsProjectIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsUpdateOptions) (GitHubV3RESTAPIClientProjectsUpdateResponse, error) {
	req, err := client.projectsUpdateCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusGone, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientProjectsUpdateResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsUpdateHandleResponse(resp)
}

// projectsUpdateCreateRequest creates the ProjectsUpdate request.
func (client *GitHubV3RESTAPIClient) projectsUpdateCreateRequest(ctx context.Context, body PathsR7QxoqProjectsProjectIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsUpdateOptions) (*policy.Request, error) {
	urlPath := "/projects/{project_id}"
	urlPath = strings.ReplaceAll(urlPath, "{project_id}", url.PathEscape(strconv.FormatInt(int64(client.projectID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// projectsUpdateHandleResponse handles the ProjectsUpdate response.
func (client *GitHubV3RESTAPIClient) projectsUpdateHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsUpdateResponse, error) {
	result := GitHubV3RESTAPIClientProjectsUpdateResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Project
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val Paths1Ju8X1ZProjectsProjectIDPatchResponses403ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsUpdateResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsUpdateCard - Update an existing project card
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsUpdateCardOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsUpdateCard
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsUpdateCard(ctx context.Context, body Paths769Nz8ProjectsColumnsCardsCardIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsUpdateCardOptions) (GitHubV3RESTAPIClientProjectsUpdateCardResponse, error) {
	req, err := client.projectsUpdateCardCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateCardResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateCardResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientProjectsUpdateCardResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsUpdateCardHandleResponse(resp)
}

// projectsUpdateCardCreateRequest creates the ProjectsUpdateCard request.
func (client *GitHubV3RESTAPIClient) projectsUpdateCardCreateRequest(ctx context.Context, body Paths769Nz8ProjectsColumnsCardsCardIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsUpdateCardOptions) (*policy.Request, error) {
	urlPath := "/projects/columns/cards/{card_id}"
	urlPath = strings.ReplaceAll(urlPath, "{card_id}", url.PathEscape(strconv.FormatInt(int64(client.cardID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// projectsUpdateCardHandleResponse handles the ProjectsUpdateCard response.
func (client *GitHubV3RESTAPIClient) projectsUpdateCardHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsUpdateCardResponse, error) {
	result := GitHubV3RESTAPIClientProjectsUpdateCardResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProjectCard
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateCardResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateCardResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateCardResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateCardResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateCardResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsUpdateCardResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ProjectsUpdateColumn - Update an existing project column
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientProjectsUpdateColumnOptions contains the optional parameters for the GitHubV3RESTAPIClient.ProjectsUpdateColumn
//     method.
func (client *GitHubV3RESTAPIClient) ProjectsUpdateColumn(ctx context.Context, body Paths1D69UpwProjectsColumnsColumnIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsUpdateColumnOptions) (GitHubV3RESTAPIClientProjectsUpdateColumnResponse, error) {
	req, err := client.projectsUpdateColumnCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateColumnResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateColumnResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientProjectsUpdateColumnResponse{}, runtime.NewResponseError(resp)
	}
	return client.projectsUpdateColumnHandleResponse(resp)
}

// projectsUpdateColumnCreateRequest creates the ProjectsUpdateColumn request.
func (client *GitHubV3RESTAPIClient) projectsUpdateColumnCreateRequest(ctx context.Context, body Paths1D69UpwProjectsColumnsColumnIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientProjectsUpdateColumnOptions) (*policy.Request, error) {
	urlPath := "/projects/columns/{column_id}"
	urlPath = strings.ReplaceAll(urlPath, "{column_id}", url.PathEscape(strconv.FormatInt(int64(client.columnID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// projectsUpdateColumnHandleResponse handles the ProjectsUpdateColumn response.
func (client *GitHubV3RESTAPIClient) projectsUpdateColumnHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientProjectsUpdateColumnResponse, error) {
	result := GitHubV3RESTAPIClientProjectsUpdateColumnResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProjectColumn
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateColumnResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateColumnResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientProjectsUpdateColumnResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientProjectsUpdateColumnResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsCheckIfMerged - Check if a pull request has been merged
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsCheckIfMergedOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsCheckIfMerged
//     method.
func (client *GitHubV3RESTAPIClient) PullsCheckIfMerged(ctx context.Context, options *GitHubV3RESTAPIClientPullsCheckIfMergedOptions) (GitHubV3RESTAPIClientPullsCheckIfMergedResponse, error) {
	req, err := client.pullsCheckIfMergedCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsCheckIfMergedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsCheckIfMergedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPullsCheckIfMergedResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientPullsCheckIfMergedResponse{}, nil
}

// pullsCheckIfMergedCreateRequest creates the PullsCheckIfMerged request.
func (client *GitHubV3RESTAPIClient) pullsCheckIfMergedCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPullsCheckIfMergedOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/merge"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// PullsCreate - Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations,
// GitHub Pro, and legacy per-repository billing plans, and in public and private repositories
// with GitHub Team and GitHub Enterprise Cloud. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help
// documentation.
// To open or update a pull request in a public repository, you must have write access to the head or the source branch. For
// organization-owned repositories, you must be a member of the organization that
// owns the repository to open or update a pull request.
// This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// Creating content too quickly using this endpoint may
// result in secondary rate limiting. See "Secondary rate limits [https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits]"
// and "Dealing with secondary rate limits
// [https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits]" for details.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsCreateOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsCreate
//     method.
func (client *GitHubV3RESTAPIClient) PullsCreate(ctx context.Context, body PathsYvh36LReposOwnerRepoPullsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsCreateOptions) (GitHubV3RESTAPIClientPullsCreateResponse, error) {
	req, err := client.pullsCreateCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsCreateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsCreateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientPullsCreateResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsCreateHandleResponse(resp)
}

// pullsCreateCreateRequest creates the PullsCreate request.
func (client *GitHubV3RESTAPIClient) pullsCreateCreateRequest(ctx context.Context, body PathsYvh36LReposOwnerRepoPullsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsCreateOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// pullsCreateHandleResponse handles the PullsCreate response.
func (client *GitHubV3RESTAPIClient) pullsCreateHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsCreateResponse, error) {
	result := GitHubV3RESTAPIClientPullsCreateResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val PullRequest
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsCreateResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsCreateResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsCreateResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsCreateResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsCreateReplyForReviewComment - Creates a reply to a review comment for a pull request. For the comment_id, provide
// the ID of the review comment you are replying to. This must be the ID of a top-level review comment, not a reply to
// that comment. Replies to replies are not supported.
// This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// Creating content too quickly using this endpoint may
// result in secondary rate limiting. See "Secondary rate limits [https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits]"
// and "Dealing with secondary rate limits
// [https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits]" for details.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsCreateReplyForReviewCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsCreateReplyForReviewComment
//     method.
func (client *GitHubV3RESTAPIClient) PullsCreateReplyForReviewComment(ctx context.Context, body Paths1C6Ln62ReposOwnerRepoPullsPullNumberCommentsCommentIDRepliesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsCreateReplyForReviewCommentOptions) (GitHubV3RESTAPIClientPullsCreateReplyForReviewCommentResponse, error) {
	req, err := client.pullsCreateReplyForReviewCommentCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsCreateReplyForReviewCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsCreateReplyForReviewCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPullsCreateReplyForReviewCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsCreateReplyForReviewCommentHandleResponse(resp)
}

// pullsCreateReplyForReviewCommentCreateRequest creates the PullsCreateReplyForReviewComment request.
func (client *GitHubV3RESTAPIClient) pullsCreateReplyForReviewCommentCreateRequest(ctx context.Context, body Paths1C6Ln62ReposOwnerRepoPullsPullNumberCommentsCommentIDRepliesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsCreateReplyForReviewCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// pullsCreateReplyForReviewCommentHandleResponse handles the PullsCreateReplyForReviewComment response.
func (client *GitHubV3RESTAPIClient) pullsCreateReplyForReviewCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsCreateReplyForReviewCommentResponse, error) {
	result := GitHubV3RESTAPIClientPullsCreateReplyForReviewCommentResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val PullRequestReviewComment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsCreateReplyForReviewCommentResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsCreateReplyForReviewCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsCreateReplyForReviewCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsCreateReview - This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// Creating content too quickly using this endpoint may
// result in secondary rate limiting. See "Secondary rate limits [https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits]"
// and "Dealing with secondary rate limits
// [https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits]" for details.
// Pull request reviews created in the PENDING state are not submitted and therefore do not include the submitted_at property
// in the response. To create a pending review for a pull request, leave the
// event parameter blank. For more information about submitting a PENDING review, see "Submit a review for a pull request
// [https://docs.github.com/rest/pulls#submit-a-review-for-a-pull-request]."
// Note: To comment on a specific line in a file, you need to first determine the position of that line in the diff. The GitHub
// REST API offers the application/vnd.github.v3.diff media type
// [https://docs.github.com/rest/overview/media-types#commits-commit-comparison-and-pull-requests]. To see a pull request
// diff, add this media type to the Accept header of a call to the single pull
// request [https://docs.github.com/rest/reference/pulls#get-a-pull-request] endpoint.
// The position value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment.
// The line just below the "@@" line is position 1, the next line is position 2,
// and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning
// of a new file.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsCreateReviewOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsCreateReview
//     method.
func (client *GitHubV3RESTAPIClient) PullsCreateReview(ctx context.Context, options *GitHubV3RESTAPIClientPullsCreateReviewOptions) (GitHubV3RESTAPIClientPullsCreateReviewResponse, error) {
	req, err := client.pullsCreateReviewCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsCreateReviewResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsCreateReviewResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientPullsCreateReviewResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsCreateReviewHandleResponse(resp)
}

// pullsCreateReviewCreateRequest creates the PullsCreateReview request.
func (client *GitHubV3RESTAPIClient) pullsCreateReviewCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPullsCreateReviewOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/reviews"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// pullsCreateReviewHandleResponse handles the PullsCreateReview response.
func (client *GitHubV3RESTAPIClient) pullsCreateReviewHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsCreateReviewResponse, error) {
	result := GitHubV3RESTAPIClientPullsCreateReviewResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PullRequestReview
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsCreateReviewResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsCreateReviewResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsCreateReviewResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsCreateReviewResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsCreateReviewComment - Creates a review comment in the pull request diff. To add a regular comment to a pull request
// timeline, see "Create an issue comment
// [https://docs.github.com/rest/reference/issues#create-an-issue-comment]." We recommend creating a review comment using
// line, side, and optionally startline and startside if your comment applies to
// more than one line in the pull request diff.
// The position parameter is deprecated. If you use position, the line, side, startline, and startside parameters are not
// required.
// Note: The position value equals the number of lines down from the first "@@" hunk header in the file you want to add a
// comment. The line just below the "@@" line is position 1, the next line is
// position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks
// until the beginning of a new file.
// This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// Creating content too quickly using this endpoint may
// result in secondary rate limiting. See "Secondary rate limits [https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits]"
// and "Dealing with secondary rate limits
// [https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits]" for details.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsCreateReviewCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsCreateReviewComment
//     method.
func (client *GitHubV3RESTAPIClient) PullsCreateReviewComment(ctx context.Context, body Paths2Gex6CReposOwnerRepoPullsPullNumberCommentsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsCreateReviewCommentOptions) (GitHubV3RESTAPIClientPullsCreateReviewCommentResponse, error) {
	req, err := client.pullsCreateReviewCommentCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsCreateReviewCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsCreateReviewCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientPullsCreateReviewCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsCreateReviewCommentHandleResponse(resp)
}

// pullsCreateReviewCommentCreateRequest creates the PullsCreateReviewComment request.
func (client *GitHubV3RESTAPIClient) pullsCreateReviewCommentCreateRequest(ctx context.Context, body Paths2Gex6CReposOwnerRepoPullsPullNumberCommentsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsCreateReviewCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/comments"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// pullsCreateReviewCommentHandleResponse handles the PullsCreateReviewComment response.
func (client *GitHubV3RESTAPIClient) pullsCreateReviewCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsCreateReviewCommentResponse, error) {
	result := GitHubV3RESTAPIClientPullsCreateReviewCommentResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val PullRequestReviewComment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsCreateReviewCommentResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsCreateReviewCommentResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsCreateReviewCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsCreateReviewCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsDeletePendingReview - Delete a pending review for a pull request
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsDeletePendingReviewOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsDeletePendingReview
//     method.
func (client *GitHubV3RESTAPIClient) PullsDeletePendingReview(ctx context.Context, options *GitHubV3RESTAPIClientPullsDeletePendingReviewOptions) (GitHubV3RESTAPIClientPullsDeletePendingReviewResponse, error) {
	req, err := client.pullsDeletePendingReviewCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsDeletePendingReviewResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsDeletePendingReviewResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientPullsDeletePendingReviewResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsDeletePendingReviewHandleResponse(resp)
}

// pullsDeletePendingReviewCreateRequest creates the PullsDeletePendingReview request.
func (client *GitHubV3RESTAPIClient) pullsDeletePendingReviewCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPullsDeletePendingReviewOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{review_id}", url.PathEscape(strconv.FormatInt(int64(client.reviewID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// pullsDeletePendingReviewHandleResponse handles the PullsDeletePendingReview response.
func (client *GitHubV3RESTAPIClient) pullsDeletePendingReviewHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsDeletePendingReviewResponse, error) {
	result := GitHubV3RESTAPIClientPullsDeletePendingReviewResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PullRequestReview
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsDeletePendingReviewResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsDeletePendingReviewResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsDeletePendingReviewResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsDeletePendingReviewResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsDeleteReviewComment - Deletes a review comment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsDeleteReviewCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsDeleteReviewComment
//     method.
func (client *GitHubV3RESTAPIClient) PullsDeleteReviewComment(ctx context.Context, options *GitHubV3RESTAPIClientPullsDeleteReviewCommentOptions) (GitHubV3RESTAPIClientPullsDeleteReviewCommentResponse, error) {
	req, err := client.pullsDeleteReviewCommentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsDeleteReviewCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsDeleteReviewCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPullsDeleteReviewCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsDeleteReviewCommentHandleResponse(resp)
}

// pullsDeleteReviewCommentCreateRequest creates the PullsDeleteReviewComment request.
func (client *GitHubV3RESTAPIClient) pullsDeleteReviewCommentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPullsDeleteReviewCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/comments/{comment_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// pullsDeleteReviewCommentHandleResponse handles the PullsDeleteReviewComment response.
func (client *GitHubV3RESTAPIClient) pullsDeleteReviewCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsDeleteReviewCommentResponse, error) {
	result := GitHubV3RESTAPIClientPullsDeleteReviewCommentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientPullsDeleteReviewCommentResponse{}, err
	}
	return result, nil
}

// PullsDismissReview - Note: To dismiss a pull request review on a protected branch [https://docs.github.com/rest/reference/repos#branches],
// you must be a repository administrator or be included in the list of people or
// teams who can dismiss pull request reviews.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsDismissReviewOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsDismissReview
//     method.
func (client *GitHubV3RESTAPIClient) PullsDismissReview(ctx context.Context, body Paths1T38XacReposOwnerRepoPullsPullNumberReviewsReviewIDDismissalsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsDismissReviewOptions) (GitHubV3RESTAPIClientPullsDismissReviewResponse, error) {
	req, err := client.pullsDismissReviewCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsDismissReviewResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsDismissReviewResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientPullsDismissReviewResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsDismissReviewHandleResponse(resp)
}

// pullsDismissReviewCreateRequest creates the PullsDismissReview request.
func (client *GitHubV3RESTAPIClient) pullsDismissReviewCreateRequest(ctx context.Context, body Paths1T38XacReposOwnerRepoPullsPullNumberReviewsReviewIDDismissalsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsDismissReviewOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{review_id}", url.PathEscape(strconv.FormatInt(int64(client.reviewID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// pullsDismissReviewHandleResponse handles the PullsDismissReview response.
func (client *GitHubV3RESTAPIClient) pullsDismissReviewHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsDismissReviewResponse, error) {
	result := GitHubV3RESTAPIClientPullsDismissReviewResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PullRequestReview
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsDismissReviewResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsDismissReviewResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsDismissReviewResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsDismissReviewResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsGet - Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations,
// GitHub Pro, and legacy per-repository billing plans, and in public and private repositories
// with GitHub Team and GitHub Enterprise Cloud. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help
// documentation.
// Lists details of a pull request by providing its number.
// When you get, create [https://docs.github.com/rest/reference/pulls/#create-a-pull-request], or edit [https://docs.github.com/rest/reference/pulls#update-a-pull-request]
// a pull request, GitHub creates
// a merge commit to test whether the pull request can be automatically merged into the base branch. This test commit is not
// added to the base branch or the head branch. You can review the status of the
// test commit using the mergeable key. For more information, see "Checking mergeability of pull requests
// [https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests]".
// The value of the mergeable attribute can be true, false, or null. If the value is null, then GitHub has started a background
// job to compute the mergeability. After giving the job time to complete,
// resubmit the request. When the job finishes, you will see a non-null value for the mergeable attribute in the response.
// If mergeable is true, then mergecommitsha will be the SHA of the test merge
// commit.
// The value of the mergecommitsha attribute changes depending on the state of the pull request. Before merging a pull request,
// the mergecommitsha attribute holds the SHA of the test merge commit. After
// merging a pull request, the mergecommitsha attribute changes depending on how you merged the pull request:
// * If merged as a merge commit [https://docs.github.com/articles/about-merge-methods-on-github/], mergecommitsha represents
// the SHA of the merge commit.
// * If merged via a squash [https://docs.github.com/articles/about-merge-methods-on-github/#squashing-your-merge-commits],
// mergecommitsha represents the SHA of the squashed commit on the base branch.
// * If rebased [https://docs.github.com/articles/about-merge-methods-on-github/#rebasing-and-merging-your-commits], mergecommitsha
// represents the commit that the base branch was updated to.
// Pass the appropriate media type [https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests]
// to fetch diff and patch formats.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsGetOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsGet
//     method.
func (client *GitHubV3RESTAPIClient) PullsGet(ctx context.Context, options *GitHubV3RESTAPIClientPullsGetOptions) (GitHubV3RESTAPIClientPullsGetResponse, error) {
	req, err := client.pullsGetCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusNotFound, http.StatusInternalServerError, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientPullsGetResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsGetHandleResponse(resp)
}

// pullsGetCreateRequest creates the PullsGet request.
func (client *GitHubV3RESTAPIClient) pullsGetCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPullsGetOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// pullsGetHandleResponse handles the PullsGet response.
func (client *GitHubV3RESTAPIClient) pullsGetHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsGetResponse, error) {
	result := GitHubV3RESTAPIClientPullsGetResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PullRequest
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsGetResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsGetResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsGetResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsGetResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsGetResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsGetReview - Get a review for a pull request
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsGetReviewOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsGetReview
//     method.
func (client *GitHubV3RESTAPIClient) PullsGetReview(ctx context.Context, options *GitHubV3RESTAPIClientPullsGetReviewOptions) (GitHubV3RESTAPIClientPullsGetReviewResponse, error) {
	req, err := client.pullsGetReviewCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsGetReviewResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsGetReviewResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPullsGetReviewResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsGetReviewHandleResponse(resp)
}

// pullsGetReviewCreateRequest creates the PullsGetReview request.
func (client *GitHubV3RESTAPIClient) pullsGetReviewCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPullsGetReviewOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{review_id}", url.PathEscape(strconv.FormatInt(int64(client.reviewID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// pullsGetReviewHandleResponse handles the PullsGetReview response.
func (client *GitHubV3RESTAPIClient) pullsGetReviewHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsGetReviewResponse, error) {
	result := GitHubV3RESTAPIClientPullsGetReviewResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PullRequestReview
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsGetReviewResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsGetReviewResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsGetReviewResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsGetReviewComment - Provides details for a review comment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsGetReviewCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsGetReviewComment
//     method.
func (client *GitHubV3RESTAPIClient) PullsGetReviewComment(ctx context.Context, options *GitHubV3RESTAPIClientPullsGetReviewCommentOptions) (GitHubV3RESTAPIClientPullsGetReviewCommentResponse, error) {
	req, err := client.pullsGetReviewCommentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsGetReviewCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsGetReviewCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPullsGetReviewCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsGetReviewCommentHandleResponse(resp)
}

// pullsGetReviewCommentCreateRequest creates the PullsGetReviewComment request.
func (client *GitHubV3RESTAPIClient) pullsGetReviewCommentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPullsGetReviewCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/comments/{comment_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// pullsGetReviewCommentHandleResponse handles the PullsGetReviewComment response.
func (client *GitHubV3RESTAPIClient) pullsGetReviewCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsGetReviewCommentResponse, error) {
	result := GitHubV3RESTAPIClientPullsGetReviewCommentResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PullRequestReviewComment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsGetReviewCommentResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsGetReviewCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsGetReviewCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsList - Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations,
// GitHub Pro, and legacy per-repository billing plans, and in public and private repositories
// with GitHub Team and GitHub Enterprise Cloud. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help
// documentation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsListOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsList
//     method.
func (client *GitHubV3RESTAPIClient) PullsList(ctx context.Context, options *GitHubV3RESTAPIClientPullsListOptions) (GitHubV3RESTAPIClientPullsListResponse, error) {
	req, err := client.pullsListCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientPullsListResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsListHandleResponse(resp)
}

// pullsListCreateRequest creates the PullsList request.
func (client *GitHubV3RESTAPIClient) pullsListCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPullsListOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.State != nil {
		reqQP.Set("state", string(*options.State))
	}
	if options != nil && options.Head != nil {
		reqQP.Set("head", *options.Head)
	}
	if options != nil && options.Base != nil {
		reqQP.Set("base", *options.Base)
	}
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if options != nil && options.Direction != nil {
		reqQP.Set("direction", string(*options.Direction))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// pullsListHandleResponse handles the PullsList response.
func (client *GitHubV3RESTAPIClient) pullsListHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsListResponse, error) {
	result := GitHubV3RESTAPIClientPullsListResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*PullRequestSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsListResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsListResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsListResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsListCommentsForReview - List comments for a specific pull request review.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsListCommentsForReviewOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsListCommentsForReview
//     method.
func (client *GitHubV3RESTAPIClient) PullsListCommentsForReview(ctx context.Context, options *GitHubV3RESTAPIClientPullsListCommentsForReviewOptions) (GitHubV3RESTAPIClientPullsListCommentsForReviewResponse, error) {
	req, err := client.pullsListCommentsForReviewCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsListCommentsForReviewResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsListCommentsForReviewResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientPullsListCommentsForReviewResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsListCommentsForReviewHandleResponse(resp)
}

// pullsListCommentsForReviewCreateRequest creates the PullsListCommentsForReview request.
func (client *GitHubV3RESTAPIClient) pullsListCommentsForReviewCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPullsListCommentsForReviewOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{review_id}", url.PathEscape(strconv.FormatInt(int64(client.reviewID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// pullsListCommentsForReviewHandleResponse handles the PullsListCommentsForReview response.
func (client *GitHubV3RESTAPIClient) pullsListCommentsForReviewHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsListCommentsForReviewResponse, error) {
	result := GitHubV3RESTAPIClientPullsListCommentsForReviewResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*ReviewComment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsListCommentsForReviewResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsListCommentsForReviewResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsListCommentsForReviewResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsListCommits - Lists a maximum of 250 commits for a pull request. To receive a complete commit list for pull requests
// with more than 250 commits, use the List commits
// [https://docs.github.com/rest/reference/repos#list-commits] endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsListCommitsOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsListCommits
//     method.
func (client *GitHubV3RESTAPIClient) PullsListCommits(ctx context.Context, options *GitHubV3RESTAPIClientPullsListCommitsOptions) (GitHubV3RESTAPIClientPullsListCommitsResponse, error) {
	req, err := client.pullsListCommitsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsListCommitsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsListCommitsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientPullsListCommitsResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsListCommitsHandleResponse(resp)
}

// pullsListCommitsCreateRequest creates the PullsListCommits request.
func (client *GitHubV3RESTAPIClient) pullsListCommitsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPullsListCommitsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/commits"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// pullsListCommitsHandleResponse handles the PullsListCommits response.
func (client *GitHubV3RESTAPIClient) pullsListCommitsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsListCommitsResponse, error) {
	result := GitHubV3RESTAPIClientPullsListCommitsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.CommitArray); err != nil {
		return GitHubV3RESTAPIClientPullsListCommitsResponse{}, err
	}
	return result, nil
}

// PullsListFiles - Note: Responses include a maximum of 3000 files. The paginated response returns 30 files per page by default.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsListFilesOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsListFiles
//     method.
func (client *GitHubV3RESTAPIClient) PullsListFiles(ctx context.Context, options *GitHubV3RESTAPIClientPullsListFilesOptions) (GitHubV3RESTAPIClientPullsListFilesResponse, error) {
	req, err := client.pullsListFilesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsListFilesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsListFilesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity, http.StatusInternalServerError, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientPullsListFilesResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsListFilesHandleResponse(resp)
}

// pullsListFilesCreateRequest creates the PullsListFiles request.
func (client *GitHubV3RESTAPIClient) pullsListFilesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPullsListFilesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/files"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// pullsListFilesHandleResponse handles the PullsListFiles response.
func (client *GitHubV3RESTAPIClient) pullsListFilesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsListFilesResponse, error) {
	result := GitHubV3RESTAPIClientPullsListFilesResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*DiffEntry
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsListFilesResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsListFilesResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsListFilesResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsListFilesResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsListFilesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsListRequestedReviewers - Gets the users or teams whose review is requested for a pull request. Once a requested reviewer
// submits a review, they are no longer considered a requested reviewer. Their review will instead be
// returned by the List reviews for a pull request [https://docs.github.com/rest/pulls/reviews#list-reviews-for-a-pull-request]
// operation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsListRequestedReviewersOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsListRequestedReviewers
//     method.
func (client *GitHubV3RESTAPIClient) PullsListRequestedReviewers(ctx context.Context, options *GitHubV3RESTAPIClientPullsListRequestedReviewersOptions) (GitHubV3RESTAPIClientPullsListRequestedReviewersResponse, error) {
	req, err := client.pullsListRequestedReviewersCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsListRequestedReviewersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsListRequestedReviewersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientPullsListRequestedReviewersResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsListRequestedReviewersHandleResponse(resp)
}

// pullsListRequestedReviewersCreateRequest creates the PullsListRequestedReviewers request.
func (client *GitHubV3RESTAPIClient) pullsListRequestedReviewersCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPullsListRequestedReviewersOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// pullsListRequestedReviewersHandleResponse handles the PullsListRequestedReviewers response.
func (client *GitHubV3RESTAPIClient) pullsListRequestedReviewersHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsListRequestedReviewersResponse, error) {
	result := GitHubV3RESTAPIClientPullsListRequestedReviewersResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PullRequestReviewRequest); err != nil {
		return GitHubV3RESTAPIClientPullsListRequestedReviewersResponse{}, err
	}
	return result, nil
}

// PullsListReviewComments - Lists all review comments for a pull request. By default, review comments are in ascending order
// by ID.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsListReviewCommentsOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsListReviewComments
//     method.
func (client *GitHubV3RESTAPIClient) PullsListReviewComments(ctx context.Context, options *GitHubV3RESTAPIClientPullsListReviewCommentsOptions) (GitHubV3RESTAPIClientPullsListReviewCommentsResponse, error) {
	req, err := client.pullsListReviewCommentsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsListReviewCommentsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsListReviewCommentsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientPullsListReviewCommentsResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsListReviewCommentsHandleResponse(resp)
}

// pullsListReviewCommentsCreateRequest creates the PullsListReviewComments request.
func (client *GitHubV3RESTAPIClient) pullsListReviewCommentsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPullsListReviewCommentsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/comments"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.sortParam != nil {
		reqQP.Set("sort", string(*client.sortParam))
	}
	if options != nil && options.Direction != nil {
		reqQP.Set("direction", string(*options.Direction))
	}
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// pullsListReviewCommentsHandleResponse handles the PullsListReviewComments response.
func (client *GitHubV3RESTAPIClient) pullsListReviewCommentsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsListReviewCommentsResponse, error) {
	result := GitHubV3RESTAPIClientPullsListReviewCommentsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PullRequestReviewCommentArray); err != nil {
		return GitHubV3RESTAPIClientPullsListReviewCommentsResponse{}, err
	}
	return result, nil
}

// PullsListReviewCommentsForRepo - Lists review comments for all pull requests in a repository. By default, review comments
// are in ascending order by ID.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsListReviewCommentsForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsListReviewCommentsForRepo
//     method.
func (client *GitHubV3RESTAPIClient) PullsListReviewCommentsForRepo(ctx context.Context, options *GitHubV3RESTAPIClientPullsListReviewCommentsForRepoOptions) (GitHubV3RESTAPIClientPullsListReviewCommentsForRepoResponse, error) {
	req, err := client.pullsListReviewCommentsForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsListReviewCommentsForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsListReviewCommentsForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientPullsListReviewCommentsForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsListReviewCommentsForRepoHandleResponse(resp)
}

// pullsListReviewCommentsForRepoCreateRequest creates the PullsListReviewCommentsForRepo request.
func (client *GitHubV3RESTAPIClient) pullsListReviewCommentsForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPullsListReviewCommentsForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/comments"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if options != nil && options.Direction != nil {
		reqQP.Set("direction", string(*options.Direction))
	}
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// pullsListReviewCommentsForRepoHandleResponse handles the PullsListReviewCommentsForRepo response.
func (client *GitHubV3RESTAPIClient) pullsListReviewCommentsForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsListReviewCommentsForRepoResponse, error) {
	result := GitHubV3RESTAPIClientPullsListReviewCommentsForRepoResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PullRequestReviewCommentArray); err != nil {
		return GitHubV3RESTAPIClientPullsListReviewCommentsForRepoResponse{}, err
	}
	return result, nil
}

// PullsListReviews - The list of reviews returns in chronological order.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsListReviewsOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsListReviews
//     method.
func (client *GitHubV3RESTAPIClient) PullsListReviews(ctx context.Context, options *GitHubV3RESTAPIClientPullsListReviewsOptions) (GitHubV3RESTAPIClientPullsListReviewsResponse, error) {
	req, err := client.pullsListReviewsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsListReviewsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsListReviewsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientPullsListReviewsResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsListReviewsHandleResponse(resp)
}

// pullsListReviewsCreateRequest creates the PullsListReviews request.
func (client *GitHubV3RESTAPIClient) pullsListReviewsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPullsListReviewsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/reviews"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// pullsListReviewsHandleResponse handles the PullsListReviews response.
func (client *GitHubV3RESTAPIClient) pullsListReviewsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsListReviewsResponse, error) {
	result := GitHubV3RESTAPIClientPullsListReviewsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PullRequestReviewArray); err != nil {
		return GitHubV3RESTAPIClientPullsListReviewsResponse{}, err
	}
	return result, nil
}

// PullsMerge - This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// Creating content too quickly using this endpoint may
// result in secondary rate limiting. See "Secondary rate limits [https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits]"
// and "Dealing with secondary rate limits
// [https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits]" for details.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsMergeOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsMerge
//     method.
func (client *GitHubV3RESTAPIClient) PullsMerge(ctx context.Context, body Paths1K251OqReposOwnerRepoPullsPullNumberMergePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsMergeOptions) (GitHubV3RESTAPIClientPullsMergeResponse, error) {
	req, err := client.pullsMergeCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsMergeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsMergeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusMethodNotAllowed, http.StatusConflict, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientPullsMergeResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsMergeHandleResponse(resp)
}

// pullsMergeCreateRequest creates the PullsMerge request.
func (client *GitHubV3RESTAPIClient) pullsMergeCreateRequest(ctx context.Context, body Paths1K251OqReposOwnerRepoPullsPullNumberMergePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsMergeOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/merge"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// pullsMergeHandleResponse handles the PullsMerge response.
func (client *GitHubV3RESTAPIClient) pullsMergeHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsMergeResponse, error) {
	result := GitHubV3RESTAPIClientPullsMergeResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PullRequestMergeResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsMergeResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsMergeResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsMergeResponse{}, err
	}
	result.Value = val
	case http.StatusMethodNotAllowed:
	var val Paths1W7I1J9ReposOwnerRepoPullsPullNumberMergePutResponses405ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsMergeResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val Paths1Rc6Uv8ReposOwnerRepoPullsPullNumberMergePutResponses409ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsMergeResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsMergeResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsMergeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsRemoveRequestedReviewers - Remove requested reviewers from a pull request
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsRemoveRequestedReviewersOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsRemoveRequestedReviewers
//     method.
func (client *GitHubV3RESTAPIClient) PullsRemoveRequestedReviewers(ctx context.Context, body PathsDurjnhReposOwnerRepoPullsPullNumberRequestedReviewersDeleteRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsRemoveRequestedReviewersOptions) (GitHubV3RESTAPIClientPullsRemoveRequestedReviewersResponse, error) {
	req, err := client.pullsRemoveRequestedReviewersCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsRemoveRequestedReviewersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsRemoveRequestedReviewersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientPullsRemoveRequestedReviewersResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsRemoveRequestedReviewersHandleResponse(resp)
}

// pullsRemoveRequestedReviewersCreateRequest creates the PullsRemoveRequestedReviewers request.
func (client *GitHubV3RESTAPIClient) pullsRemoveRequestedReviewersCreateRequest(ctx context.Context, body PathsDurjnhReposOwnerRepoPullsPullNumberRequestedReviewersDeleteRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsRemoveRequestedReviewersOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// pullsRemoveRequestedReviewersHandleResponse handles the PullsRemoveRequestedReviewers response.
func (client *GitHubV3RESTAPIClient) pullsRemoveRequestedReviewersHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsRemoveRequestedReviewersResponse, error) {
	result := GitHubV3RESTAPIClientPullsRemoveRequestedReviewersResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PullRequestSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsRemoveRequestedReviewersResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsRemoveRequestedReviewersResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsRemoveRequestedReviewersResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsRequestReviewers - This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// Creating content too quickly using this endpoint may
// result in secondary rate limiting. See "Secondary rate limits [https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits]"
// and "Dealing with secondary rate limits
// [https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits]" for details.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsRequestReviewersOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsRequestReviewers
//     method.
func (client *GitHubV3RESTAPIClient) PullsRequestReviewers(ctx context.Context, options *GitHubV3RESTAPIClientPullsRequestReviewersOptions) (GitHubV3RESTAPIClientPullsRequestReviewersResponse, error) {
	req, err := client.pullsRequestReviewersCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsRequestReviewersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsRequestReviewersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientPullsRequestReviewersResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsRequestReviewersHandleResponse(resp)
}

// pullsRequestReviewersCreateRequest creates the PullsRequestReviewers request.
func (client *GitHubV3RESTAPIClient) pullsRequestReviewersCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientPullsRequestReviewersOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// pullsRequestReviewersHandleResponse handles the PullsRequestReviewers response.
func (client *GitHubV3RESTAPIClient) pullsRequestReviewersHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsRequestReviewersResponse, error) {
	result := GitHubV3RESTAPIClientPullsRequestReviewersResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val PullRequestSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsRequestReviewersResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsRequestReviewersResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	default:
		return GitHubV3RESTAPIClientPullsRequestReviewersResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsSubmitReview - Submits a pending review for a pull request. For more information about creating a pending review for
// a pull request, see "Create a review for a pull request
// [https://docs.github.com/rest/pulls#create-a-review-for-a-pull-request]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsSubmitReviewOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsSubmitReview
//     method.
func (client *GitHubV3RESTAPIClient) PullsSubmitReview(ctx context.Context, body Paths6UfbcbReposOwnerRepoPullsPullNumberReviewsReviewIDEventsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsSubmitReviewOptions) (GitHubV3RESTAPIClientPullsSubmitReviewResponse, error) {
	req, err := client.pullsSubmitReviewCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsSubmitReviewResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsSubmitReviewResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientPullsSubmitReviewResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsSubmitReviewHandleResponse(resp)
}

// pullsSubmitReviewCreateRequest creates the PullsSubmitReview request.
func (client *GitHubV3RESTAPIClient) pullsSubmitReviewCreateRequest(ctx context.Context, body Paths6UfbcbReposOwnerRepoPullsPullNumberReviewsReviewIDEventsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsSubmitReviewOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{review_id}", url.PathEscape(strconv.FormatInt(int64(client.reviewID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// pullsSubmitReviewHandleResponse handles the PullsSubmitReview response.
func (client *GitHubV3RESTAPIClient) pullsSubmitReviewHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsSubmitReviewResponse, error) {
	result := GitHubV3RESTAPIClientPullsSubmitReviewResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PullRequestReview
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsSubmitReviewResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsSubmitReviewResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsSubmitReviewResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsSubmitReviewResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsSubmitReviewResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsUpdate - Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations,
// GitHub Pro, and legacy per-repository billing plans, and in public and private repositories
// with GitHub Team and GitHub Enterprise Cloud. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help
// documentation.
// To open or update a pull request in a public repository, you must have write access to the head or the source branch. For
// organization-owned repositories, you must be a member of the organization that
// owns the repository to open or update a pull request.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsUpdateOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsUpdate
//     method.
func (client *GitHubV3RESTAPIClient) PullsUpdate(ctx context.Context, body Paths1Vjcr70ReposOwnerRepoPullsPullNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsUpdateOptions) (GitHubV3RESTAPIClientPullsUpdateResponse, error) {
	req, err := client.pullsUpdateCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientPullsUpdateResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsUpdateHandleResponse(resp)
}

// pullsUpdateCreateRequest creates the PullsUpdate request.
func (client *GitHubV3RESTAPIClient) pullsUpdateCreateRequest(ctx context.Context, body Paths1Vjcr70ReposOwnerRepoPullsPullNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsUpdateOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// pullsUpdateHandleResponse handles the PullsUpdate response.
func (client *GitHubV3RESTAPIClient) pullsUpdateHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsUpdateResponse, error) {
	result := GitHubV3RESTAPIClientPullsUpdateResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PullRequest
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsUpdateResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsUpdateResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsUpdateBranch - Updates the pull request branch with the latest upstream changes by merging HEAD from the base branch
// into the pull request branch.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsUpdateBranchOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsUpdateBranch
//     method.
func (client *GitHubV3RESTAPIClient) PullsUpdateBranch(ctx context.Context, body Paths1VaofhnReposOwnerRepoPullsPullNumberUpdateBranchPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsUpdateBranchOptions) (GitHubV3RESTAPIClientPullsUpdateBranchResponse, error) {
	req, err := client.pullsUpdateBranchCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsUpdateBranchResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsUpdateBranchResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientPullsUpdateBranchResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsUpdateBranchHandleResponse(resp)
}

// pullsUpdateBranchCreateRequest creates the PullsUpdateBranch request.
func (client *GitHubV3RESTAPIClient) pullsUpdateBranchCreateRequest(ctx context.Context, body Paths1VaofhnReposOwnerRepoPullsPullNumberUpdateBranchPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsUpdateBranchOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// pullsUpdateBranchHandleResponse handles the PullsUpdateBranch response.
func (client *GitHubV3RESTAPIClient) pullsUpdateBranchHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsUpdateBranchResponse, error) {
	result := GitHubV3RESTAPIClientPullsUpdateBranchResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val PathsZoffozReposOwnerRepoPullsPullNumberUpdateBranchPutResponses202ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsUpdateBranchResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsUpdateBranchResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsUpdateBranchResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsUpdateBranchResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsUpdateReview - Update the review summary comment with new text.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsUpdateReviewOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsUpdateReview
//     method.
func (client *GitHubV3RESTAPIClient) PullsUpdateReview(ctx context.Context, body PathsWxrvxnReposOwnerRepoPullsPullNumberReviewsReviewIDPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsUpdateReviewOptions) (GitHubV3RESTAPIClientPullsUpdateReviewResponse, error) {
	req, err := client.pullsUpdateReviewCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsUpdateReviewResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsUpdateReviewResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientPullsUpdateReviewResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsUpdateReviewHandleResponse(resp)
}

// pullsUpdateReviewCreateRequest creates the PullsUpdateReview request.
func (client *GitHubV3RESTAPIClient) pullsUpdateReviewCreateRequest(ctx context.Context, body PathsWxrvxnReposOwnerRepoPullsPullNumberReviewsReviewIDPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsUpdateReviewOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{pull_number}", url.PathEscape(strconv.FormatInt(int64(client.pullNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{review_id}", url.PathEscape(strconv.FormatInt(int64(client.reviewID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// pullsUpdateReviewHandleResponse handles the PullsUpdateReview response.
func (client *GitHubV3RESTAPIClient) pullsUpdateReviewHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsUpdateReviewResponse, error) {
	result := GitHubV3RESTAPIClientPullsUpdateReviewResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PullRequestReview
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsUpdateReviewResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientPullsUpdateReviewResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientPullsUpdateReviewResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// PullsUpdateReviewComment - Enables you to edit a review comment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientPullsUpdateReviewCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.PullsUpdateReviewComment
//     method.
func (client *GitHubV3RESTAPIClient) PullsUpdateReviewComment(ctx context.Context, body PathsH71AocReposOwnerRepoPullsCommentsCommentIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsUpdateReviewCommentOptions) (GitHubV3RESTAPIClientPullsUpdateReviewCommentResponse, error) {
	req, err := client.pullsUpdateReviewCommentCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientPullsUpdateReviewCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientPullsUpdateReviewCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientPullsUpdateReviewCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.pullsUpdateReviewCommentHandleResponse(resp)
}

// pullsUpdateReviewCommentCreateRequest creates the PullsUpdateReviewComment request.
func (client *GitHubV3RESTAPIClient) pullsUpdateReviewCommentCreateRequest(ctx context.Context, body PathsH71AocReposOwnerRepoPullsCommentsCommentIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientPullsUpdateReviewCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/comments/{comment_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// pullsUpdateReviewCommentHandleResponse handles the PullsUpdateReviewComment response.
func (client *GitHubV3RESTAPIClient) pullsUpdateReviewCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientPullsUpdateReviewCommentResponse, error) {
	result := GitHubV3RESTAPIClientPullsUpdateReviewCommentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PullRequestReviewComment); err != nil {
		return GitHubV3RESTAPIClientPullsUpdateReviewCommentResponse{}, err
	}
	return result, nil
}

// RateLimitGet - Note: Accessing this endpoint does not count against your REST API rate limit.
// Note: The rate object is deprecated. If you're writing new API client code or updating existing code, you should use the
// core object instead of the rate object. The core object contains the same
// information that is present in the rate object.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientRateLimitGetOptions contains the optional parameters for the GitHubV3RESTAPIClient.RateLimitGet
//     method.
func (client *GitHubV3RESTAPIClient) RateLimitGet(ctx context.Context, options *GitHubV3RESTAPIClientRateLimitGetOptions) (GitHubV3RESTAPIClientRateLimitGetResponse, error) {
	req, err := client.rateLimitGetCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientRateLimitGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientRateLimitGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusNotFound) {
		return GitHubV3RESTAPIClientRateLimitGetResponse{}, runtime.NewResponseError(resp)
	}
	return client.rateLimitGetHandleResponse(resp)
}

// rateLimitGetCreateRequest creates the RateLimitGet request.
func (client *GitHubV3RESTAPIClient) rateLimitGetCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientRateLimitGetOptions) (*policy.Request, error) {
	urlPath := "/rate_limit"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// rateLimitGetHandleResponse handles the RateLimitGet response.
func (client *GitHubV3RESTAPIClient) rateLimitGetHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientRateLimitGetResponse, error) {
	result := GitHubV3RESTAPIClientRateLimitGetResponse{}
	if val := resp.Header.Get("X-RateLimit-Limit"); val != "" {
		xRateLimit32, err := strconv.ParseInt(val, 10, 32)
		xRateLimit := int32(xRateLimit32)
		if err != nil {
			return GitHubV3RESTAPIClientRateLimitGetResponse{}, err
		}
		result.XRateLimit = &xRateLimit
	}
	if val := resp.Header.Get("X-RateLimit-Remaining"); val != "" {
		xRateLimitRemaining32, err := strconv.ParseInt(val, 10, 32)
		xRateLimitRemaining := int32(xRateLimitRemaining32)
		if err != nil {
			return GitHubV3RESTAPIClientRateLimitGetResponse{}, err
		}
		result.XRateLimitRemaining = &xRateLimitRemaining
	}
	if val := resp.Header.Get("X-RateLimit-Reset"); val != "" {
		xRateLimitReset32, err := strconv.ParseInt(val, 10, 32)
		xRateLimitReset := int32(xRateLimitReset32)
		if err != nil {
			return GitHubV3RESTAPIClientRateLimitGetResponse{}, err
		}
		result.XRateLimitReset = &xRateLimitReset
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val RateLimitOverview
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientRateLimitGetResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientRateLimitGetResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientRateLimitGetResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReactionsCreateForCommitComment - Create a reaction to a commit comment [https://docs.github.com/rest/reference/repos#comments].
// A response with an HTTP 200 status means that you already added the reaction type to this commit comment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsCreateForCommitCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsCreateForCommitComment
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsCreateForCommitComment(ctx context.Context, body PathsMpanbzReposOwnerRepoCommentsCommentIDReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForCommitCommentOptions) (GitHubV3RESTAPIClientReactionsCreateForCommitCommentResponse, error) {
	req, err := client.reactionsCreateForCommitCommentCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForCommitCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForCommitCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReactionsCreateForCommitCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsCreateForCommitCommentHandleResponse(resp)
}

// reactionsCreateForCommitCommentCreateRequest creates the ReactionsCreateForCommitComment request.
func (client *GitHubV3RESTAPIClient) reactionsCreateForCommitCommentCreateRequest(ctx context.Context, body PathsMpanbzReposOwnerRepoCommentsCommentIDReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForCommitCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/comments/{comment_id}/reactions"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reactionsCreateForCommitCommentHandleResponse handles the ReactionsCreateForCommitComment response.
func (client *GitHubV3RESTAPIClient) reactionsCreateForCommitCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsCreateForCommitCommentResponse, error) {
	result := GitHubV3RESTAPIClientReactionsCreateForCommitCommentResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Reaction
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForCommitCommentResponse{}, err
	}
	result.Value = val
	case http.StatusCreated:
	var val Reaction
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForCommitCommentResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForCommitCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReactionsCreateForCommitCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReactionsCreateForIssue - Create a reaction to an issue [https://docs.github.com/rest/reference/issues/]. A response with
// an HTTP 200 status means that you already added the reaction type to this issue.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsCreateForIssueOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsCreateForIssue
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsCreateForIssue(ctx context.Context, body Paths31Uss8ReposOwnerRepoIssuesIssueNumberReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForIssueOptions) (GitHubV3RESTAPIClientReactionsCreateForIssueResponse, error) {
	req, err := client.reactionsCreateForIssueCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForIssueResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForIssueResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReactionsCreateForIssueResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsCreateForIssueHandleResponse(resp)
}

// reactionsCreateForIssueCreateRequest creates the ReactionsCreateForIssue request.
func (client *GitHubV3RESTAPIClient) reactionsCreateForIssueCreateRequest(ctx context.Context, body Paths31Uss8ReposOwnerRepoIssuesIssueNumberReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForIssueOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/reactions"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reactionsCreateForIssueHandleResponse handles the ReactionsCreateForIssue response.
func (client *GitHubV3RESTAPIClient) reactionsCreateForIssueHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsCreateForIssueResponse, error) {
	result := GitHubV3RESTAPIClientReactionsCreateForIssueResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Reaction
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForIssueResponse{}, err
	}
	result.Value = val
	case http.StatusCreated:
	var val Reaction
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForIssueResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForIssueResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReactionsCreateForIssueResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReactionsCreateForIssueComment - Create a reaction to an issue comment [https://docs.github.com/rest/reference/issues#comments].
// A response with an HTTP 200 status means that you already added the reaction type to this issue comment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsCreateForIssueCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsCreateForIssueComment
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsCreateForIssueComment(ctx context.Context, body PathsJteklmReposOwnerRepoIssuesCommentsCommentIDReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForIssueCommentOptions) (GitHubV3RESTAPIClientReactionsCreateForIssueCommentResponse, error) {
	req, err := client.reactionsCreateForIssueCommentCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForIssueCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForIssueCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReactionsCreateForIssueCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsCreateForIssueCommentHandleResponse(resp)
}

// reactionsCreateForIssueCommentCreateRequest creates the ReactionsCreateForIssueComment request.
func (client *GitHubV3RESTAPIClient) reactionsCreateForIssueCommentCreateRequest(ctx context.Context, body PathsJteklmReposOwnerRepoIssuesCommentsCommentIDReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForIssueCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reactionsCreateForIssueCommentHandleResponse handles the ReactionsCreateForIssueComment response.
func (client *GitHubV3RESTAPIClient) reactionsCreateForIssueCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsCreateForIssueCommentResponse, error) {
	result := GitHubV3RESTAPIClientReactionsCreateForIssueCommentResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Reaction
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForIssueCommentResponse{}, err
	}
	result.Value = val
	case http.StatusCreated:
	var val Reaction
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForIssueCommentResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForIssueCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReactionsCreateForIssueCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReactionsCreateForPullRequestReviewComment - Create a reaction to a pull request review comment [https://docs.github.com/rest/reference/pulls#comments].
// A response with an HTTP 200 status means that you already added the reaction type to this
// pull request review comment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsCreateForPullRequestReviewCommentOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ReactionsCreateForPullRequestReviewComment method.
func (client *GitHubV3RESTAPIClient) ReactionsCreateForPullRequestReviewComment(ctx context.Context, body Paths10Lwna0ReposOwnerRepoPullsCommentsCommentIDReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForPullRequestReviewCommentOptions) (GitHubV3RESTAPIClientReactionsCreateForPullRequestReviewCommentResponse, error) {
	req, err := client.reactionsCreateForPullRequestReviewCommentCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForPullRequestReviewCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForPullRequestReviewCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReactionsCreateForPullRequestReviewCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsCreateForPullRequestReviewCommentHandleResponse(resp)
}

// reactionsCreateForPullRequestReviewCommentCreateRequest creates the ReactionsCreateForPullRequestReviewComment request.
func (client *GitHubV3RESTAPIClient) reactionsCreateForPullRequestReviewCommentCreateRequest(ctx context.Context, body Paths10Lwna0ReposOwnerRepoPullsCommentsCommentIDReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForPullRequestReviewCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reactionsCreateForPullRequestReviewCommentHandleResponse handles the ReactionsCreateForPullRequestReviewComment response.
func (client *GitHubV3RESTAPIClient) reactionsCreateForPullRequestReviewCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsCreateForPullRequestReviewCommentResponse, error) {
	result := GitHubV3RESTAPIClientReactionsCreateForPullRequestReviewCommentResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Reaction
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForPullRequestReviewCommentResponse{}, err
	}
	result.Value = val
	case http.StatusCreated:
	var val Reaction
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForPullRequestReviewCommentResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForPullRequestReviewCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReactionsCreateForPullRequestReviewCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReactionsCreateForRelease - Create a reaction to a release [https://docs.github.com/rest/reference/repos#releases]. A response
// with a Status: 200 OK means that you already added the reaction type to this release.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsCreateForReleaseOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsCreateForRelease
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsCreateForRelease(ctx context.Context, body PathsJbjkraReposOwnerRepoReleasesReleaseIDReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForReleaseOptions) (GitHubV3RESTAPIClientReactionsCreateForReleaseResponse, error) {
	req, err := client.reactionsCreateForReleaseCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForReleaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForReleaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReactionsCreateForReleaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsCreateForReleaseHandleResponse(resp)
}

// reactionsCreateForReleaseCreateRequest creates the ReactionsCreateForRelease request.
func (client *GitHubV3RESTAPIClient) reactionsCreateForReleaseCreateRequest(ctx context.Context, body PathsJbjkraReposOwnerRepoReleasesReleaseIDReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForReleaseOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/releases/{release_id}/reactions"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{release_id}", url.PathEscape(strconv.FormatInt(int64(client.releaseID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reactionsCreateForReleaseHandleResponse handles the ReactionsCreateForRelease response.
func (client *GitHubV3RESTAPIClient) reactionsCreateForReleaseHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsCreateForReleaseResponse, error) {
	result := GitHubV3RESTAPIClientReactionsCreateForReleaseResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Reaction
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForReleaseResponse{}, err
	}
	result.Value = val
	case http.StatusCreated:
	var val Reaction
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForReleaseResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForReleaseResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReactionsCreateForReleaseResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReactionsCreateForTeamDiscussionCommentInOrg - Create a reaction to a team discussion comment [https://docs.github.com/rest/reference/teams#discussion-comments].
// OAuth access tokens require the write:discussion scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/]. A response with an HTTP 200 status
// means that you already added the reaction type to this team discussion
// comment.
// Note: You can also specify a team by orgid and teamid using the route POST /organizations/:orgid/team/:teamid/discussions/:discussionnumber/comments/:commentnumber/reactions.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentInOrgOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.ReactionsCreateForTeamDiscussionCommentInOrg method.
func (client *GitHubV3RESTAPIClient) ReactionsCreateForTeamDiscussionCommentInOrg(ctx context.Context, body PathsV5LgmhOrgsOrgTeamsTeamSlugDiscussionsDiscussionNumberCommentsCommentNumberReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentInOrgOptions) (GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentInOrgResponse, error) {
	req, err := client.reactionsCreateForTeamDiscussionCommentInOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsCreateForTeamDiscussionCommentInOrgHandleResponse(resp)
}

// reactionsCreateForTeamDiscussionCommentInOrgCreateRequest creates the ReactionsCreateForTeamDiscussionCommentInOrg request.
func (client *GitHubV3RESTAPIClient) reactionsCreateForTeamDiscussionCommentInOrgCreateRequest(ctx context.Context, body PathsV5LgmhOrgsOrgTeamsTeamSlugDiscussionsDiscussionNumberCommentsCommentNumberReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{comment_number}", url.PathEscape(strconv.FormatInt(int64(client.commentNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reactionsCreateForTeamDiscussionCommentInOrgHandleResponse handles the ReactionsCreateForTeamDiscussionCommentInOrg response.
func (client *GitHubV3RESTAPIClient) reactionsCreateForTeamDiscussionCommentInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentInOrgResponse, error) {
	result := GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentInOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Reaction); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentInOrgResponse{}, err
	}
	return result, nil
}

// ReactionsCreateForTeamDiscussionCommentLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed
// from the Teams API. We recommend migrating your existing code to use the new "Create reaction for a team discussion comment
// [https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion-comment]" endpoint.
// Create a reaction to a team discussion comment [https://docs.github.com/rest/reference/teams#discussion-comments]. OAuth
// access tokens require the write:discussion scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/]. A response with an HTTP 200 status
// means that you already added the reaction type to this team discussion
// comment.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentLegacyOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.ReactionsCreateForTeamDiscussionCommentLegacy method.
func (client *GitHubV3RESTAPIClient) ReactionsCreateForTeamDiscussionCommentLegacy(ctx context.Context, body Paths1Am7T21TeamsTeamIDDiscussionsDiscussionNumberCommentsCommentNumberReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentLegacyOptions) (GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentLegacyResponse, error) {
	req, err := client.reactionsCreateForTeamDiscussionCommentLegacyCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsCreateForTeamDiscussionCommentLegacyHandleResponse(resp)
}

// reactionsCreateForTeamDiscussionCommentLegacyCreateRequest creates the ReactionsCreateForTeamDiscussionCommentLegacy request.
func (client *GitHubV3RESTAPIClient) reactionsCreateForTeamDiscussionCommentLegacyCreateRequest(ctx context.Context, body Paths1Am7T21TeamsTeamIDDiscussionsDiscussionNumberCommentsCommentNumberReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{comment_number}", url.PathEscape(strconv.FormatInt(int64(client.commentNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reactionsCreateForTeamDiscussionCommentLegacyHandleResponse handles the ReactionsCreateForTeamDiscussionCommentLegacy response.
func (client *GitHubV3RESTAPIClient) reactionsCreateForTeamDiscussionCommentLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentLegacyResponse, error) {
	result := GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentLegacyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Reaction); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionCommentLegacyResponse{}, err
	}
	return result, nil
}

// ReactionsCreateForTeamDiscussionInOrg - Create a reaction to a team discussion [https://docs.github.com/rest/reference/teams#discussions].
// OAuth access tokens require the write:discussion scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/]. A response with an HTTP 200 status
// means that you already added the reaction type to this team discussion.
// Note: You can also specify a team by orgid and teamid using the route POST /organizations/:orgid/team/:teamid/discussions/:discussion_number/reactions.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsCreateForTeamDiscussionInOrg
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsCreateForTeamDiscussionInOrg(ctx context.Context, body PathsTfi7RdOrgsOrgTeamsTeamSlugDiscussionsDiscussionNumberReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionInOrgOptions) (GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionInOrgResponse, error) {
	req, err := client.reactionsCreateForTeamDiscussionInOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsCreateForTeamDiscussionInOrgHandleResponse(resp)
}

// reactionsCreateForTeamDiscussionInOrgCreateRequest creates the ReactionsCreateForTeamDiscussionInOrg request.
func (client *GitHubV3RESTAPIClient) reactionsCreateForTeamDiscussionInOrgCreateRequest(ctx context.Context, body PathsTfi7RdOrgsOrgTeamsTeamSlugDiscussionsDiscussionNumberReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reactionsCreateForTeamDiscussionInOrgHandleResponse handles the ReactionsCreateForTeamDiscussionInOrg response.
func (client *GitHubV3RESTAPIClient) reactionsCreateForTeamDiscussionInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionInOrgResponse, error) {
	result := GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionInOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Reaction); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionInOrgResponse{}, err
	}
	return result, nil
}

// ReactionsCreateForTeamDiscussionLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from
// the Teams API. We recommend migrating your existing code to use the new Create reaction for a team discussion
// [https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion] endpoint.
// Create a reaction to a team discussion [https://docs.github.com/rest/reference/teams#discussions]. OAuth access tokens
// require the write:discussion scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/]. A response with an HTTP 200 status
// means that you already added the reaction type to this team discussion.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsCreateForTeamDiscussionLegacy
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsCreateForTeamDiscussionLegacy(ctx context.Context, body Paths1Z0XvfeTeamsTeamIDDiscussionsDiscussionNumberReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionLegacyOptions) (GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionLegacyResponse, error) {
	req, err := client.reactionsCreateForTeamDiscussionLegacyCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsCreateForTeamDiscussionLegacyHandleResponse(resp)
}

// reactionsCreateForTeamDiscussionLegacyCreateRequest creates the ReactionsCreateForTeamDiscussionLegacy request.
func (client *GitHubV3RESTAPIClient) reactionsCreateForTeamDiscussionLegacyCreateRequest(ctx context.Context, body Paths1Z0XvfeTeamsTeamIDDiscussionsDiscussionNumberReactionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/discussions/{discussion_number}/reactions"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reactionsCreateForTeamDiscussionLegacyHandleResponse handles the ReactionsCreateForTeamDiscussionLegacy response.
func (client *GitHubV3RESTAPIClient) reactionsCreateForTeamDiscussionLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionLegacyResponse, error) {
	result := GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionLegacyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Reaction); err != nil {
		return GitHubV3RESTAPIClientReactionsCreateForTeamDiscussionLegacyResponse{}, err
	}
	return result, nil
}

// ReactionsDeleteForCommitComment - Note: You can also specify a repository by repositoryid using the route DELETE /repositories/:repositoryid/comments/:commentid/reactions/:reactionid.
// Delete a reaction to a commit comment [https://docs.github.com/rest/reference/repos#comments].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsDeleteForCommitCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsDeleteForCommitComment
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsDeleteForCommitComment(ctx context.Context, options *GitHubV3RESTAPIClientReactionsDeleteForCommitCommentOptions) (GitHubV3RESTAPIClientReactionsDeleteForCommitCommentResponse, error) {
	req, err := client.reactionsDeleteForCommitCommentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsDeleteForCommitCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsDeleteForCommitCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReactionsDeleteForCommitCommentResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReactionsDeleteForCommitCommentResponse{}, nil
}

// reactionsDeleteForCommitCommentCreateRequest creates the ReactionsDeleteForCommitComment request.
func (client *GitHubV3RESTAPIClient) reactionsDeleteForCommitCommentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReactionsDeleteForCommitCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{reaction_id}", url.PathEscape(strconv.FormatInt(int64(client.reactionID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReactionsDeleteForIssue - Note: You can also specify a repository by repositoryid using the route DELETE /repositories/:repositoryid/issues/:issuenumber/reactions/:reactionid.
// Delete a reaction to an issue [https://docs.github.com/rest/reference/issues/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsDeleteForIssueOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsDeleteForIssue
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsDeleteForIssue(ctx context.Context, options *GitHubV3RESTAPIClientReactionsDeleteForIssueOptions) (GitHubV3RESTAPIClientReactionsDeleteForIssueResponse, error) {
	req, err := client.reactionsDeleteForIssueCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsDeleteForIssueResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsDeleteForIssueResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReactionsDeleteForIssueResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReactionsDeleteForIssueResponse{}, nil
}

// reactionsDeleteForIssueCreateRequest creates the ReactionsDeleteForIssue request.
func (client *GitHubV3RESTAPIClient) reactionsDeleteForIssueCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReactionsDeleteForIssueOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{reaction_id}", url.PathEscape(strconv.FormatInt(int64(client.reactionID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReactionsDeleteForIssueComment - Note: You can also specify a repository by repositoryid using the route DELETE delete
// /repositories/:repositoryid/issues/comments/:commentid/reactions/:reactionid.
// Delete a reaction to an issue comment [https://docs.github.com/rest/reference/issues#comments].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsDeleteForIssueCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsDeleteForIssueComment
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsDeleteForIssueComment(ctx context.Context, options *GitHubV3RESTAPIClientReactionsDeleteForIssueCommentOptions) (GitHubV3RESTAPIClientReactionsDeleteForIssueCommentResponse, error) {
	req, err := client.reactionsDeleteForIssueCommentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsDeleteForIssueCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsDeleteForIssueCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReactionsDeleteForIssueCommentResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReactionsDeleteForIssueCommentResponse{}, nil
}

// reactionsDeleteForIssueCommentCreateRequest creates the ReactionsDeleteForIssueComment request.
func (client *GitHubV3RESTAPIClient) reactionsDeleteForIssueCommentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReactionsDeleteForIssueCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{reaction_id}", url.PathEscape(strconv.FormatInt(int64(client.reactionID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReactionsDeleteForPullRequestComment - Note: You can also specify a repository by repositoryid using the route DELETE /repositories/:repositoryid/pulls/comments/:commentid/reactions/:reactionid.
// Delete a reaction to a pull request review comment [https://docs.github.com/rest/reference/pulls#review-comments].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsDeleteForPullRequestCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsDeleteForPullRequestComment
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsDeleteForPullRequestComment(ctx context.Context, options *GitHubV3RESTAPIClientReactionsDeleteForPullRequestCommentOptions) (GitHubV3RESTAPIClientReactionsDeleteForPullRequestCommentResponse, error) {
	req, err := client.reactionsDeleteForPullRequestCommentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsDeleteForPullRequestCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsDeleteForPullRequestCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReactionsDeleteForPullRequestCommentResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReactionsDeleteForPullRequestCommentResponse{}, nil
}

// reactionsDeleteForPullRequestCommentCreateRequest creates the ReactionsDeleteForPullRequestComment request.
func (client *GitHubV3RESTAPIClient) reactionsDeleteForPullRequestCommentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReactionsDeleteForPullRequestCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{reaction_id}", url.PathEscape(strconv.FormatInt(int64(client.reactionID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReactionsDeleteForRelease - Note: You can also specify a repository by repositoryid using the route DELETE delete /repositories/:repositoryid/releases/:releaseid/reactions/:reactionid.
// Delete a reaction to a release [https://docs.github.com/rest/reference/repos#releases].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsDeleteForReleaseOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsDeleteForRelease
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsDeleteForRelease(ctx context.Context, options *GitHubV3RESTAPIClientReactionsDeleteForReleaseOptions) (GitHubV3RESTAPIClientReactionsDeleteForReleaseResponse, error) {
	req, err := client.reactionsDeleteForReleaseCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsDeleteForReleaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsDeleteForReleaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReactionsDeleteForReleaseResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReactionsDeleteForReleaseResponse{}, nil
}

// reactionsDeleteForReleaseCreateRequest creates the ReactionsDeleteForRelease request.
func (client *GitHubV3RESTAPIClient) reactionsDeleteForReleaseCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReactionsDeleteForReleaseOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{release_id}", url.PathEscape(strconv.FormatInt(int64(client.releaseID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{reaction_id}", url.PathEscape(strconv.FormatInt(int64(client.reactionID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReactionsDeleteForTeamDiscussion - Note: You can also specify a team or organization with teamid and orgid using the route
// DELETE /organizations/:orgid/team/:teamid/discussions/:discussionnumber/reactions/:reactionid.
// Delete a reaction to a team discussion [https://docs.github.com/rest/reference/teams#discussions]. OAuth access tokens
// require the write:discussion scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsDeleteForTeamDiscussionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsDeleteForTeamDiscussion
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsDeleteForTeamDiscussion(ctx context.Context, options *GitHubV3RESTAPIClientReactionsDeleteForTeamDiscussionOptions) (GitHubV3RESTAPIClientReactionsDeleteForTeamDiscussionResponse, error) {
	req, err := client.reactionsDeleteForTeamDiscussionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsDeleteForTeamDiscussionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsDeleteForTeamDiscussionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReactionsDeleteForTeamDiscussionResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReactionsDeleteForTeamDiscussionResponse{}, nil
}

// reactionsDeleteForTeamDiscussionCreateRequest creates the ReactionsDeleteForTeamDiscussion request.
func (client *GitHubV3RESTAPIClient) reactionsDeleteForTeamDiscussionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReactionsDeleteForTeamDiscussionOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{reaction_id}", url.PathEscape(strconv.FormatInt(int64(client.reactionID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReactionsDeleteForTeamDiscussionComment - Note: You can also specify a team or organization with teamid and orgid using
// the route DELETE /organizations/:orgid/team/:teamid/discussions/:discussionnumber/comments/:comment
// number/reactions/:reaction_id.
// Delete a reaction to a team discussion comment [https://docs.github.com/rest/reference/teams#discussion-comments]. OAuth
// access tokens require the write:discussion scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsDeleteForTeamDiscussionCommentOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ReactionsDeleteForTeamDiscussionComment method.
func (client *GitHubV3RESTAPIClient) ReactionsDeleteForTeamDiscussionComment(ctx context.Context, options *GitHubV3RESTAPIClientReactionsDeleteForTeamDiscussionCommentOptions) (GitHubV3RESTAPIClientReactionsDeleteForTeamDiscussionCommentResponse, error) {
	req, err := client.reactionsDeleteForTeamDiscussionCommentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsDeleteForTeamDiscussionCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsDeleteForTeamDiscussionCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReactionsDeleteForTeamDiscussionCommentResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReactionsDeleteForTeamDiscussionCommentResponse{}, nil
}

// reactionsDeleteForTeamDiscussionCommentCreateRequest creates the ReactionsDeleteForTeamDiscussionComment request.
func (client *GitHubV3RESTAPIClient) reactionsDeleteForTeamDiscussionCommentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReactionsDeleteForTeamDiscussionCommentOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{comment_number}", url.PathEscape(strconv.FormatInt(int64(client.commentNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{reaction_id}", url.PathEscape(strconv.FormatInt(int64(client.reactionID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReactionsListForCommitComment - List the reactions to a commit comment [https://docs.github.com/rest/reference/repos#comments].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsListForCommitCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsListForCommitComment
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsListForCommitComment(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForCommitCommentOptions) (GitHubV3RESTAPIClientReactionsListForCommitCommentResponse, error) {
	req, err := client.reactionsListForCommitCommentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForCommitCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForCommitCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReactionsListForCommitCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsListForCommitCommentHandleResponse(resp)
}

// reactionsListForCommitCommentCreateRequest creates the ReactionsListForCommitComment request.
func (client *GitHubV3RESTAPIClient) reactionsListForCommitCommentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForCommitCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/comments/{comment_id}/reactions"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Content != nil {
		reqQP.Set("content", string(*options.Content))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reactionsListForCommitCommentHandleResponse handles the ReactionsListForCommitComment response.
func (client *GitHubV3RESTAPIClient) reactionsListForCommitCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsListForCommitCommentResponse, error) {
	result := GitHubV3RESTAPIClientReactionsListForCommitCommentResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Reaction
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsListForCommitCommentResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsListForCommitCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReactionsListForCommitCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReactionsListForIssue - List the reactions to an issue [https://docs.github.com/rest/reference/issues].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsListForIssueOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsListForIssue
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsListForIssue(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForIssueOptions) (GitHubV3RESTAPIClientReactionsListForIssueResponse, error) {
	req, err := client.reactionsListForIssueCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForIssueResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForIssueResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusGone) {
		return GitHubV3RESTAPIClientReactionsListForIssueResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsListForIssueHandleResponse(resp)
}

// reactionsListForIssueCreateRequest creates the ReactionsListForIssue request.
func (client *GitHubV3RESTAPIClient) reactionsListForIssueCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForIssueOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/{issue_number}/reactions"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{issue_number}", url.PathEscape(strconv.FormatInt(int64(client.issueNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Content != nil {
		reqQP.Set("content", string(*options.Content))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reactionsListForIssueHandleResponse handles the ReactionsListForIssue response.
func (client *GitHubV3RESTAPIClient) reactionsListForIssueHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsListForIssueResponse, error) {
	result := GitHubV3RESTAPIClientReactionsListForIssueResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Reaction
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsListForIssueResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsListForIssueResponse{}, err
	}
	result.Value = val
	case http.StatusGone:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsListForIssueResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReactionsListForIssueResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReactionsListForIssueComment - List the reactions to an issue comment [https://docs.github.com/rest/reference/issues#comments].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsListForIssueCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsListForIssueComment
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsListForIssueComment(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForIssueCommentOptions) (GitHubV3RESTAPIClientReactionsListForIssueCommentResponse, error) {
	req, err := client.reactionsListForIssueCommentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForIssueCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForIssueCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReactionsListForIssueCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsListForIssueCommentHandleResponse(resp)
}

// reactionsListForIssueCommentCreateRequest creates the ReactionsListForIssueComment request.
func (client *GitHubV3RESTAPIClient) reactionsListForIssueCommentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForIssueCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Content != nil {
		reqQP.Set("content", string(*options.Content))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reactionsListForIssueCommentHandleResponse handles the ReactionsListForIssueComment response.
func (client *GitHubV3RESTAPIClient) reactionsListForIssueCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsListForIssueCommentResponse, error) {
	result := GitHubV3RESTAPIClientReactionsListForIssueCommentResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Reaction
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsListForIssueCommentResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsListForIssueCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReactionsListForIssueCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReactionsListForPullRequestReviewComment - List the reactions to a pull request review comment [https://docs.github.com/rest/reference/pulls#review-comments].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsListForPullRequestReviewCommentOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ReactionsListForPullRequestReviewComment method.
func (client *GitHubV3RESTAPIClient) ReactionsListForPullRequestReviewComment(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForPullRequestReviewCommentOptions) (GitHubV3RESTAPIClientReactionsListForPullRequestReviewCommentResponse, error) {
	req, err := client.reactionsListForPullRequestReviewCommentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForPullRequestReviewCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForPullRequestReviewCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReactionsListForPullRequestReviewCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsListForPullRequestReviewCommentHandleResponse(resp)
}

// reactionsListForPullRequestReviewCommentCreateRequest creates the ReactionsListForPullRequestReviewComment request.
func (client *GitHubV3RESTAPIClient) reactionsListForPullRequestReviewCommentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForPullRequestReviewCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Content != nil {
		reqQP.Set("content", string(*options.Content))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reactionsListForPullRequestReviewCommentHandleResponse handles the ReactionsListForPullRequestReviewComment response.
func (client *GitHubV3RESTAPIClient) reactionsListForPullRequestReviewCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsListForPullRequestReviewCommentResponse, error) {
	result := GitHubV3RESTAPIClientReactionsListForPullRequestReviewCommentResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Reaction
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsListForPullRequestReviewCommentResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsListForPullRequestReviewCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReactionsListForPullRequestReviewCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReactionsListForRelease - List the reactions to a release [https://docs.github.com/rest/reference/repos#releases].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsListForReleaseOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsListForRelease
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsListForRelease(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForReleaseOptions) (GitHubV3RESTAPIClientReactionsListForReleaseResponse, error) {
	req, err := client.reactionsListForReleaseCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForReleaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForReleaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReactionsListForReleaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsListForReleaseHandleResponse(resp)
}

// reactionsListForReleaseCreateRequest creates the ReactionsListForRelease request.
func (client *GitHubV3RESTAPIClient) reactionsListForReleaseCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForReleaseOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/releases/{release_id}/reactions"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{release_id}", url.PathEscape(strconv.FormatInt(int64(client.releaseID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Content != nil {
		reqQP.Set("content", string(*options.Content))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reactionsListForReleaseHandleResponse handles the ReactionsListForRelease response.
func (client *GitHubV3RESTAPIClient) reactionsListForReleaseHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsListForReleaseResponse, error) {
	result := GitHubV3RESTAPIClientReactionsListForReleaseResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Reaction
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsListForReleaseResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReactionsListForReleaseResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReactionsListForReleaseResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReactionsListForTeamDiscussionCommentInOrg - List the reactions to a team discussion comment [https://docs.github.com/rest/reference/teams#discussion-comments/].
// OAuth access tokens require the read:discussion scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// Note: You can also specify a team by orgid and teamid using the route GET /organizations/:orgid/team/:teamid/discussions/:discussionnumber/comments/:commentnumber/reactions.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentInOrgOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ReactionsListForTeamDiscussionCommentInOrg method.
func (client *GitHubV3RESTAPIClient) ReactionsListForTeamDiscussionCommentInOrg(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentInOrgOptions) (GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentInOrgResponse, error) {
	req, err := client.reactionsListForTeamDiscussionCommentInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsListForTeamDiscussionCommentInOrgHandleResponse(resp)
}

// reactionsListForTeamDiscussionCommentInOrgCreateRequest creates the ReactionsListForTeamDiscussionCommentInOrg request.
func (client *GitHubV3RESTAPIClient) reactionsListForTeamDiscussionCommentInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{comment_number}", url.PathEscape(strconv.FormatInt(int64(client.commentNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Content != nil {
		reqQP.Set("content", string(*options.Content))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reactionsListForTeamDiscussionCommentInOrgHandleResponse handles the ReactionsListForTeamDiscussionCommentInOrg response.
func (client *GitHubV3RESTAPIClient) reactionsListForTeamDiscussionCommentInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentInOrgResponse, error) {
	result := GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentInOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ReactionArray); err != nil {
		return GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentInOrgResponse{}, err
	}
	return result, nil
}

// ReactionsListForTeamDiscussionCommentLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed
// from the Teams API. We recommend migrating your existing code to use the new List reactions for a team discussion comment
// [https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion-comment] endpoint.
// List the reactions to a team discussion comment [https://docs.github.com/rest/reference/teams#discussion-comments]. OAuth
// access tokens require the read:discussion scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentLegacyOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.ReactionsListForTeamDiscussionCommentLegacy method.
func (client *GitHubV3RESTAPIClient) ReactionsListForTeamDiscussionCommentLegacy(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentLegacyOptions) (GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentLegacyResponse, error) {
	req, err := client.reactionsListForTeamDiscussionCommentLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsListForTeamDiscussionCommentLegacyHandleResponse(resp)
}

// reactionsListForTeamDiscussionCommentLegacyCreateRequest creates the ReactionsListForTeamDiscussionCommentLegacy request.
func (client *GitHubV3RESTAPIClient) reactionsListForTeamDiscussionCommentLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{comment_number}", url.PathEscape(strconv.FormatInt(int64(client.commentNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Content != nil {
		reqQP.Set("content", string(*options.Content))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reactionsListForTeamDiscussionCommentLegacyHandleResponse handles the ReactionsListForTeamDiscussionCommentLegacy response.
func (client *GitHubV3RESTAPIClient) reactionsListForTeamDiscussionCommentLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentLegacyResponse, error) {
	result := GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentLegacyResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ReactionArray); err != nil {
		return GitHubV3RESTAPIClientReactionsListForTeamDiscussionCommentLegacyResponse{}, err
	}
	return result, nil
}

// ReactionsListForTeamDiscussionInOrg - List the reactions to a team discussion [https://docs.github.com/rest/reference/teams#discussions].
// OAuth access tokens require the read:discussion scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// Note: You can also specify a team by orgid and teamid using the route GET /organizations/:orgid/team/:teamid/discussions/:discussion_number/reactions.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsListForTeamDiscussionInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsListForTeamDiscussionInOrg
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsListForTeamDiscussionInOrg(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForTeamDiscussionInOrgOptions) (GitHubV3RESTAPIClientReactionsListForTeamDiscussionInOrgResponse, error) {
	req, err := client.reactionsListForTeamDiscussionInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForTeamDiscussionInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForTeamDiscussionInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReactionsListForTeamDiscussionInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsListForTeamDiscussionInOrgHandleResponse(resp)
}

// reactionsListForTeamDiscussionInOrgCreateRequest creates the ReactionsListForTeamDiscussionInOrg request.
func (client *GitHubV3RESTAPIClient) reactionsListForTeamDiscussionInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForTeamDiscussionInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Content != nil {
		reqQP.Set("content", string(*options.Content))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reactionsListForTeamDiscussionInOrgHandleResponse handles the ReactionsListForTeamDiscussionInOrg response.
func (client *GitHubV3RESTAPIClient) reactionsListForTeamDiscussionInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsListForTeamDiscussionInOrgResponse, error) {
	result := GitHubV3RESTAPIClientReactionsListForTeamDiscussionInOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ReactionArray); err != nil {
		return GitHubV3RESTAPIClientReactionsListForTeamDiscussionInOrgResponse{}, err
	}
	return result, nil
}

// ReactionsListForTeamDiscussionLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the
// Teams API. We recommend migrating your existing code to use the new List reactions for a team discussion
// [https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion] endpoint.
// List the reactions to a team discussion [https://docs.github.com/rest/reference/teams#discussions]. OAuth access tokens
// require the read:discussion scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReactionsListForTeamDiscussionLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReactionsListForTeamDiscussionLegacy
//     method.
func (client *GitHubV3RESTAPIClient) ReactionsListForTeamDiscussionLegacy(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForTeamDiscussionLegacyOptions) (GitHubV3RESTAPIClientReactionsListForTeamDiscussionLegacyResponse, error) {
	req, err := client.reactionsListForTeamDiscussionLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForTeamDiscussionLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReactionsListForTeamDiscussionLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReactionsListForTeamDiscussionLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.reactionsListForTeamDiscussionLegacyHandleResponse(resp)
}

// reactionsListForTeamDiscussionLegacyCreateRequest creates the ReactionsListForTeamDiscussionLegacy request.
func (client *GitHubV3RESTAPIClient) reactionsListForTeamDiscussionLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReactionsListForTeamDiscussionLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/discussions/{discussion_number}/reactions"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Content != nil {
		reqQP.Set("content", string(*options.Content))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reactionsListForTeamDiscussionLegacyHandleResponse handles the ReactionsListForTeamDiscussionLegacy response.
func (client *GitHubV3RESTAPIClient) reactionsListForTeamDiscussionLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReactionsListForTeamDiscussionLegacyResponse, error) {
	result := GitHubV3RESTAPIClientReactionsListForTeamDiscussionLegacyResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ReactionArray); err != nil {
		return GitHubV3RESTAPIClientReactionsListForTeamDiscussionLegacyResponse{}, err
	}
	return result, nil
}

// ReposAcceptInvitationForAuthenticatedUser - Accept a repository invitation
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposAcceptInvitationForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ReposAcceptInvitationForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) ReposAcceptInvitationForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientReposAcceptInvitationForAuthenticatedUserOptions) (GitHubV3RESTAPIClientReposAcceptInvitationForAuthenticatedUserResponse, error) {
	req, err := client.reposAcceptInvitationForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposAcceptInvitationForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposAcceptInvitationForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound, http.StatusConflict) {
		return GitHubV3RESTAPIClientReposAcceptInvitationForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposAcceptInvitationForAuthenticatedUserHandleResponse(resp)
}

// reposAcceptInvitationForAuthenticatedUserCreateRequest creates the ReposAcceptInvitationForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) reposAcceptInvitationForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposAcceptInvitationForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/repository_invitations/{invitation_id}"
	urlPath = strings.ReplaceAll(urlPath, "{invitation_id}", url.PathEscape(strconv.FormatInt(int64(client.invitationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposAcceptInvitationForAuthenticatedUserHandleResponse handles the ReposAcceptInvitationForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) reposAcceptInvitationForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposAcceptInvitationForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientReposAcceptInvitationForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientReposAcceptInvitationForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// ReposAddAppAccessRestrictions - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Grants the specified apps push access for this branch. Only installed GitHub Apps with write access to the contents permission
// can be added as authorized actors on a protected branch.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposAddAppAccessRestrictionsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposAddAppAccessRestrictions
//     method.
func (client *GitHubV3RESTAPIClient) ReposAddAppAccessRestrictions(ctx context.Context, options *GitHubV3RESTAPIClientReposAddAppAccessRestrictionsOptions) (GitHubV3RESTAPIClientReposAddAppAccessRestrictionsResponse, error) {
	req, err := client.reposAddAppAccessRestrictionsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposAddAppAccessRestrictionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposAddAppAccessRestrictionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposAddAppAccessRestrictionsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposAddAppAccessRestrictionsHandleResponse(resp)
}

// reposAddAppAccessRestrictionsCreateRequest creates the ReposAddAppAccessRestrictions request.
func (client *GitHubV3RESTAPIClient) reposAddAppAccessRestrictionsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposAddAppAccessRestrictionsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// reposAddAppAccessRestrictionsHandleResponse handles the ReposAddAppAccessRestrictions response.
func (client *GitHubV3RESTAPIClient) reposAddAppAccessRestrictionsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposAddAppAccessRestrictionsResponse, error) {
	result := GitHubV3RESTAPIClientReposAddAppAccessRestrictionsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Integration
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposAddAppAccessRestrictionsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposAddAppAccessRestrictionsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposAddAppAccessRestrictionsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposAddCollaborator - This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// Creating content too quickly using this endpoint may
// result in secondary rate limiting. See "Secondary rate limits [https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits]"
// and "Dealing with secondary rate limits
// [https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits]" for details.
// Adding an outside collaborator may be restricted by enterprise administrators. For more information, see "Enforcing repository
// management policies in your enterprise
// [https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories]
// ."
// For more information on permission levels, see "Repository permission levels for an organization
// [https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization]".
// There
// are restrictions on which permissions can be granted to organization members when an organization base role is in place.
// In this case, the permission being given must be equal to or higher than the
// org base permission. Otherwise, the request will fail with:
// Cannot assign {member} permission of {role name}
// Note that, if you choose not to pass any parameters, you'll need to set Content-Length to zero when calling out to this
// endpoint. For more information, see "HTTP verbs
// [https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs]."
// The invitee will receive a notification that they have been invited to the repository, which they must accept or decline.
// They may do this via the notifications page, the email they receive, or by
// using the repository invitations API endpoints [https://docs.github.com/rest/reference/repos#invitations].
// Updating an existing collaborator's permission level
// The endpoint can also be used to change the permissions of an existing collaborator without first removing and re-adding
// the collaborator. To change the permissions, use the same endpoint and pass a
// different permission parameter. The response will be a 204, with no other indication that the permission level changed.
// Rate limits
// You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no limit if you are inviting
// organization members to an organization repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposAddCollaboratorOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposAddCollaborator
//     method.
func (client *GitHubV3RESTAPIClient) ReposAddCollaborator(ctx context.Context, body Paths1Vyck9EReposOwnerRepoCollaboratorsUsernamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposAddCollaboratorOptions) (GitHubV3RESTAPIClientReposAddCollaboratorResponse, error) {
	req, err := client.reposAddCollaboratorCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposAddCollaboratorResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposAddCollaboratorResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNoContent, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposAddCollaboratorResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposAddCollaboratorHandleResponse(resp)
}

// reposAddCollaboratorCreateRequest creates the ReposAddCollaborator request.
func (client *GitHubV3RESTAPIClient) reposAddCollaboratorCreateRequest(ctx context.Context, body Paths1Vyck9EReposOwnerRepoCollaboratorsUsernamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposAddCollaboratorOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/collaborators/{username}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposAddCollaboratorHandleResponse handles the ReposAddCollaborator response.
func (client *GitHubV3RESTAPIClient) reposAddCollaboratorHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposAddCollaboratorResponse, error) {
	result := GitHubV3RESTAPIClientReposAddCollaboratorResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val RepositoryInvitation
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposAddCollaboratorResponse{}, err
	}
	result.Value = val
	case http.StatusNoContent:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposAddCollaboratorResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposAddCollaboratorResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposAddCollaboratorResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposAddStatusCheckContexts - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposAddStatusCheckContextsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposAddStatusCheckContexts
//     method.
func (client *GitHubV3RESTAPIClient) ReposAddStatusCheckContexts(ctx context.Context, options *GitHubV3RESTAPIClientReposAddStatusCheckContextsOptions) (GitHubV3RESTAPIClientReposAddStatusCheckContextsResponse, error) {
	req, err := client.reposAddStatusCheckContextsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposAddStatusCheckContextsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposAddStatusCheckContextsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposAddStatusCheckContextsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposAddStatusCheckContextsHandleResponse(resp)
}

// reposAddStatusCheckContextsCreateRequest creates the ReposAddStatusCheckContexts request.
func (client *GitHubV3RESTAPIClient) reposAddStatusCheckContextsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposAddStatusCheckContextsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// reposAddStatusCheckContextsHandleResponse handles the ReposAddStatusCheckContexts response.
func (client *GitHubV3RESTAPIClient) reposAddStatusCheckContextsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposAddStatusCheckContextsResponse, error) {
	result := GitHubV3RESTAPIClientReposAddStatusCheckContextsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*string
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposAddStatusCheckContextsResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposAddStatusCheckContextsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposAddStatusCheckContextsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposAddStatusCheckContextsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposAddStatusCheckContextsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposAddTeamAccessRestrictions - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Grants the specified teams push access for this branch. You can also give push access to child teams.
// TYPE DESCRIPTION
// array The teams that can have push access. Use the team's slug. Note: The list of users, apps, and teams in total is limited
// to 100 items.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposAddTeamAccessRestrictionsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposAddTeamAccessRestrictions
//     method.
func (client *GitHubV3RESTAPIClient) ReposAddTeamAccessRestrictions(ctx context.Context, options *GitHubV3RESTAPIClientReposAddTeamAccessRestrictionsOptions) (GitHubV3RESTAPIClientReposAddTeamAccessRestrictionsResponse, error) {
	req, err := client.reposAddTeamAccessRestrictionsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposAddTeamAccessRestrictionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposAddTeamAccessRestrictionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposAddTeamAccessRestrictionsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposAddTeamAccessRestrictionsHandleResponse(resp)
}

// reposAddTeamAccessRestrictionsCreateRequest creates the ReposAddTeamAccessRestrictions request.
func (client *GitHubV3RESTAPIClient) reposAddTeamAccessRestrictionsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposAddTeamAccessRestrictionsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// reposAddTeamAccessRestrictionsHandleResponse handles the ReposAddTeamAccessRestrictions response.
func (client *GitHubV3RESTAPIClient) reposAddTeamAccessRestrictionsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposAddTeamAccessRestrictionsResponse, error) {
	result := GitHubV3RESTAPIClientReposAddTeamAccessRestrictionsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Team
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposAddTeamAccessRestrictionsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposAddTeamAccessRestrictionsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposAddTeamAccessRestrictionsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposAddUserAccessRestrictions - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Grants the specified people push access for this branch.
// TYPE DESCRIPTION
// array Usernames for people who can have push access. Note: The list of users, apps, and teams in total is limited to 100
// items.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposAddUserAccessRestrictionsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposAddUserAccessRestrictions
//     method.
func (client *GitHubV3RESTAPIClient) ReposAddUserAccessRestrictions(ctx context.Context, options *GitHubV3RESTAPIClientReposAddUserAccessRestrictionsOptions) (GitHubV3RESTAPIClientReposAddUserAccessRestrictionsResponse, error) {
	req, err := client.reposAddUserAccessRestrictionsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposAddUserAccessRestrictionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposAddUserAccessRestrictionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposAddUserAccessRestrictionsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposAddUserAccessRestrictionsHandleResponse(resp)
}

// reposAddUserAccessRestrictionsCreateRequest creates the ReposAddUserAccessRestrictions request.
func (client *GitHubV3RESTAPIClient) reposAddUserAccessRestrictionsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposAddUserAccessRestrictionsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// reposAddUserAccessRestrictionsHandleResponse handles the ReposAddUserAccessRestrictions response.
func (client *GitHubV3RESTAPIClient) reposAddUserAccessRestrictionsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposAddUserAccessRestrictionsResponse, error) {
	result := GitHubV3RESTAPIClientReposAddUserAccessRestrictionsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*SimpleUser
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposAddUserAccessRestrictionsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposAddUserAccessRestrictionsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposAddUserAccessRestrictionsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCheckCollaborator - For organization-owned repositories, the list of collaborators includes outside collaborators,
// organization members that are direct collaborators, organization members with access through team
// memberships, organization members with access through default organization permissions, and organization owners.
// Team members will include the members of child teams.
// You must authenticate using an access token with the read:org and repo scopes with push access to use this endpoint. GitHub
// Apps must have the members organization permission and metadata repository
// permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCheckCollaboratorOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCheckCollaborator
//     method.
func (client *GitHubV3RESTAPIClient) ReposCheckCollaborator(ctx context.Context, options *GitHubV3RESTAPIClientReposCheckCollaboratorOptions) (GitHubV3RESTAPIClientReposCheckCollaboratorResponse, error) {
	req, err := client.reposCheckCollaboratorCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCheckCollaboratorResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCheckCollaboratorResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposCheckCollaboratorResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposCheckCollaboratorResponse{}, nil
}

// reposCheckCollaboratorCreateRequest creates the ReposCheckCollaborator request.
func (client *GitHubV3RESTAPIClient) reposCheckCollaboratorCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposCheckCollaboratorOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/collaborators/{username}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReposCheckVulnerabilityAlerts - Shows whether dependency alerts are enabled or disabled for a repository. The authenticated
// user must have admin read access to the repository. For more information, see "About security alerts for
// vulnerable dependencies [https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies]".
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCheckVulnerabilityAlertsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCheckVulnerabilityAlerts
//     method.
func (client *GitHubV3RESTAPIClient) ReposCheckVulnerabilityAlerts(ctx context.Context, options *GitHubV3RESTAPIClientReposCheckVulnerabilityAlertsOptions) (GitHubV3RESTAPIClientReposCheckVulnerabilityAlertsResponse, error) {
	req, err := client.reposCheckVulnerabilityAlertsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCheckVulnerabilityAlertsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCheckVulnerabilityAlertsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposCheckVulnerabilityAlertsResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposCheckVulnerabilityAlertsResponse{}, nil
}

// reposCheckVulnerabilityAlertsCreateRequest creates the ReposCheckVulnerabilityAlerts request.
func (client *GitHubV3RESTAPIClient) reposCheckVulnerabilityAlertsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposCheckVulnerabilityAlertsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/vulnerability-alerts"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReposCodeownersErrors - List any syntax errors that are detected in the CODEOWNERS file.
// For more information about the correct CODEOWNERS syntax, see "About code owners
// [https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCodeownersErrorsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCodeownersErrors
//     method.
func (client *GitHubV3RESTAPIClient) ReposCodeownersErrors(ctx context.Context, options *GitHubV3RESTAPIClientReposCodeownersErrorsOptions) (GitHubV3RESTAPIClientReposCodeownersErrorsResponse, error) {
	req, err := client.reposCodeownersErrorsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCodeownersErrorsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCodeownersErrorsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposCodeownersErrorsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCodeownersErrorsHandleResponse(resp)
}

// reposCodeownersErrorsCreateRequest creates the ReposCodeownersErrors request.
func (client *GitHubV3RESTAPIClient) reposCodeownersErrorsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposCodeownersErrorsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/codeowners/errors"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Ref != nil {
		reqQP.Set("ref", *options.Ref)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposCodeownersErrorsHandleResponse handles the ReposCodeownersErrors response.
func (client *GitHubV3RESTAPIClient) reposCodeownersErrorsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCodeownersErrorsResponse, error) {
	result := GitHubV3RESTAPIClientReposCodeownersErrorsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CodeownersErrors); err != nil {
		return GitHubV3RESTAPIClientReposCodeownersErrorsResponse{}, err
	}
	return result, nil
}

// ReposCompareCommits - Compares two commits against one another. You can compare branches in the same repository, or you
// can compare branches that exist in different repositories within the same repository network,
// including fork branches. For more information about how to view a repository's network, see "Understanding connections
// between repositories
// [https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository/understanding-connections-between-repositories]."
// This endpoint is equivalent to running the git log BASEHEAD command, but it returns commits in a different order. The
// git log BASEHEAD command returns commits in reverse chronological order, whereas
// the API returns commits in chronological order. You can pass the appropriate media type [https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests]
// to fetch diff
// and patch formats.
// The API response includes details about the files that were changed between the two commits. This includes the status of
// the change (if a file was added, removed, modified, or renamed), and details of
// the change itself. For example, files with a renamed status have a previous_filename field showing the previous filename
// of the file, and files with a modified status have a patch field showing the
// changes made to the file.
// When calling this endpoint without any paging parameter (per_page or page), the returned list is limited to 250 commits,
// and the last commit in the list is the most recent of the entire comparison.
// Working with large comparisons
// To process a response with a large number of commits, use a query parameter (per_page or page) to paginate the results.
// When using pagination:
// * The list of changed files is only shown on the first page of results, but it includes all changed files for the entire
// comparison.
// * The results are returned in chronological order, but the last commit in the returned list may not be the most recent
// one in the entire set if there are more pages of results.
// For more information on working with pagination, see "Using pagination in the REST API [https://docs.github.com/rest/guides/using-pagination-in-the-rest-api]."
// Signature verification object
// The response will include a verification object that describes the result of verifying the commit's signature. The verification
// object includes the following fields:
// NAME TYPE DESCRIPTION
// verified boolean Indicates whether GitHub considers the signature in this commit to be verified.
// reason string The reason for verified value. Possible values and their meanings are enumerated in table below.
// signature string The signature that was extracted from the commit.
// payload string The value that was signed.
// These are the possible values for reason in the verification object:
// VALUE DESCRIPTION
// expiredkey The key that made the signature is expired. notsigningkey The "signing" flag is not among the usage flags in
// the GPG key that made the signature. gpgverifyerror There was an error
// communicating with the signature verification service.
// gpgverifyunavailable The signature verification service is currently unavailable. unsigned The object does not include
// a signature. unknownsignaturetype A non-PGP signature was found in the commit. no
// user No user was associated with the committer email address in the commit.
// unverifiedemail The committer email address in the commit was associated with a user, but the email address is not verified
// on her/his account. bademail The committer email address in the commit is
// not included in the identities of the PGP key that made the signature.
// unknownkey The key that made the signature has not been registered with any user's account. malformedsignature There was
// an error parsing the signature.
// invalid The signature could not be cryptographically verified using the key whose key-id was found in the signature.
// valid None of the above errors applied, so the signature is considered to be verified.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - basehead - The base branch and head branch to compare. This parameter expects the format BASE...HEAD. Both must be branch
//     names in repo. To compare with a branch that exists in a different repository in the same
//     network as repo, the basehead parameter expects the format USERNAME:BASE...USERNAME:HEAD.
//   - options - GitHubV3RESTAPIClientReposCompareCommitsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCompareCommits
//     method.
func (client *GitHubV3RESTAPIClient) ReposCompareCommits(ctx context.Context, basehead string, options *GitHubV3RESTAPIClientReposCompareCommitsOptions) (GitHubV3RESTAPIClientReposCompareCommitsResponse, error) {
	req, err := client.reposCompareCommitsCreateRequest(ctx, basehead, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCompareCommitsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCompareCommitsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusInternalServerError, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientReposCompareCommitsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCompareCommitsHandleResponse(resp)
}

// reposCompareCommitsCreateRequest creates the ReposCompareCommits request.
func (client *GitHubV3RESTAPIClient) reposCompareCommitsCreateRequest(ctx context.Context, basehead string, options *GitHubV3RESTAPIClientReposCompareCommitsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/compare/{basehead}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if basehead == "" {
		return nil, errors.New("parameter basehead cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{basehead}", url.PathEscape(basehead))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposCompareCommitsHandleResponse handles the ReposCompareCommits response.
func (client *GitHubV3RESTAPIClient) reposCompareCommitsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCompareCommitsResponse, error) {
	result := GitHubV3RESTAPIClientReposCompareCommitsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val CommitComparison
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCompareCommitsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCompareCommitsResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCompareCommitsResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCompareCommitsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCompareCommitsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCreateAutolink - Users with admin access to the repository can create an autolink.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateAutolinkOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateAutolink
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateAutolink(ctx context.Context, body Paths1M0Y2P5ReposOwnerRepoAutolinksPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateAutolinkOptions) (GitHubV3RESTAPIClientReposCreateAutolinkResponse, error) {
	req, err := client.reposCreateAutolinkCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateAutolinkResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateAutolinkResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposCreateAutolinkResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateAutolinkHandleResponse(resp)
}

// reposCreateAutolinkCreateRequest creates the ReposCreateAutolink request.
func (client *GitHubV3RESTAPIClient) reposCreateAutolinkCreateRequest(ctx context.Context, body Paths1M0Y2P5ReposOwnerRepoAutolinksPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateAutolinkOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/autolinks"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreateAutolinkHandleResponse handles the ReposCreateAutolink response.
func (client *GitHubV3RESTAPIClient) reposCreateAutolinkHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateAutolinkResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateAutolinkResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Autolink
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateAutolinkResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateAutolinkResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCreateAutolinkResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCreateCommitComment - Create a comment for a commit using its :commit_sha.
// This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// Creating content too quickly using this endpoint may
// result in secondary rate limiting. See "Secondary rate limits [https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits]"
// and "Dealing with secondary rate limits
// [https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits]" for details.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateCommitCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateCommitComment
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateCommitComment(ctx context.Context, body PathsByukk6ReposOwnerRepoCommitsCommitSHACommentsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateCommitCommentOptions) (GitHubV3RESTAPIClientReposCreateCommitCommentResponse, error) {
	req, err := client.reposCreateCommitCommentCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateCommitCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateCommitCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposCreateCommitCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateCommitCommentHandleResponse(resp)
}

// reposCreateCommitCommentCreateRequest creates the ReposCreateCommitComment request.
func (client *GitHubV3RESTAPIClient) reposCreateCommitCommentCreateRequest(ctx context.Context, body PathsByukk6ReposOwnerRepoCommitsCommitSHACommentsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateCommitCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/commits/{commit_sha}/comments"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.commitSHA == "" {
		return nil, errors.New("parameter client.commitSHA cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{commit_sha}", url.PathEscape(client.commitSHA))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreateCommitCommentHandleResponse handles the ReposCreateCommitComment response.
func (client *GitHubV3RESTAPIClient) reposCreateCommitCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateCommitCommentResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateCommitCommentResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val CommitComment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateCommitCommentResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateCommitCommentResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateCommitCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCreateCommitCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCreateCommitSignatureProtection - Protected branches are available in public repositories with GitHub Free and GitHub
// Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// When authenticated with admin or owner permissions to the repository, you can use this endpoint to require signed commits
// on a branch. You must enable branch protection to require signed commits.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateCommitSignatureProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateCommitSignatureProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateCommitSignatureProtection(ctx context.Context, options *GitHubV3RESTAPIClientReposCreateCommitSignatureProtectionOptions) (GitHubV3RESTAPIClientReposCreateCommitSignatureProtectionResponse, error) {
	req, err := client.reposCreateCommitSignatureProtectionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateCommitSignatureProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateCommitSignatureProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposCreateCommitSignatureProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateCommitSignatureProtectionHandleResponse(resp)
}

// reposCreateCommitSignatureProtectionCreateRequest creates the ReposCreateCommitSignatureProtection request.
func (client *GitHubV3RESTAPIClient) reposCreateCommitSignatureProtectionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposCreateCommitSignatureProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposCreateCommitSignatureProtectionHandleResponse handles the ReposCreateCommitSignatureProtection response.
func (client *GitHubV3RESTAPIClient) reposCreateCommitSignatureProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateCommitSignatureProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateCommitSignatureProtectionResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProtectedBranchAdminEnforced
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateCommitSignatureProtectionResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateCommitSignatureProtectionResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCreateCommitSignatureProtectionResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCreateCommitStatus - Users with push access in a repository can create commit statuses for a given SHA.
// Note: there is a limit of 1000 statuses per sha and context within a repository. Attempts to create more than 1000 statuses
// will result in a validation error.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateCommitStatusOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateCommitStatus
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateCommitStatus(ctx context.Context, sha string, body Paths1HyzeaaReposOwnerRepoStatusesSHAPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateCommitStatusOptions) (GitHubV3RESTAPIClientReposCreateCommitStatusResponse, error) {
	req, err := client.reposCreateCommitStatusCreateRequest(ctx, sha, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateCommitStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateCommitStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientReposCreateCommitStatusResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateCommitStatusHandleResponse(resp)
}

// reposCreateCommitStatusCreateRequest creates the ReposCreateCommitStatus request.
func (client *GitHubV3RESTAPIClient) reposCreateCommitStatusCreateRequest(ctx context.Context, sha string, body Paths1HyzeaaReposOwnerRepoStatusesSHAPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateCommitStatusOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/statuses/{sha}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if sha == "" {
		return nil, errors.New("parameter sha cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sha}", url.PathEscape(sha))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreateCommitStatusHandleResponse handles the ReposCreateCommitStatus response.
func (client *GitHubV3RESTAPIClient) reposCreateCommitStatusHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateCommitStatusResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateCommitStatusResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Status); err != nil {
		return GitHubV3RESTAPIClientReposCreateCommitStatusResponse{}, err
	}
	return result, nil
}

// ReposCreateDeployKey - You can create a read-only deploy key.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateDeployKeyOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateDeployKey
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateDeployKey(ctx context.Context, body Paths129Ps5JReposOwnerRepoKeysPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateDeployKeyOptions) (GitHubV3RESTAPIClientReposCreateDeployKeyResponse, error) {
	req, err := client.reposCreateDeployKeyCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateDeployKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateDeployKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposCreateDeployKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateDeployKeyHandleResponse(resp)
}

// reposCreateDeployKeyCreateRequest creates the ReposCreateDeployKey request.
func (client *GitHubV3RESTAPIClient) reposCreateDeployKeyCreateRequest(ctx context.Context, body Paths129Ps5JReposOwnerRepoKeysPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateDeployKeyOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/keys"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreateDeployKeyHandleResponse handles the ReposCreateDeployKey response.
func (client *GitHubV3RESTAPIClient) reposCreateDeployKeyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateDeployKeyResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateDeployKeyResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val DeployKey
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateDeployKeyResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateDeployKeyResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCreateDeployKeyResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCreateDeployment - Deployments offer a few configurable parameters with certain defaults.
// The ref parameter can be any named branch, tag, or SHA. At GitHub we often deploy branches and verify them before we merge
// a pull request.
// The environment parameter allows deployments to be issued to different runtime environments. Teams often have multiple
// environments for verifying their applications, such as production, staging, and
// qa. This parameter makes it easier to track which environments have requested deployments. The default environment is production.
// The auto_merge parameter is used to ensure that the requested ref is not behind the repository's default branch. If the
// ref is behind the default branch for the repository, we will attempt to merge it
// for you. If the merge succeeds, the API will return a successful merge commit. If merge conflicts prevent the merge from
// succeeding, the API will return a failure response.
// By default, commit statuses [https://docs.github.com/rest/commits/statuses] for every submitted context must be in a successstate.
// The required_contexts parameter allows you to specify a subset of
// contexts that must be success, or to specify contexts that have not yet been submitted. You are not required to use commit
// statuses to deploy. If you do not require any contexts or create any commit
// statuses, the deployment will always succeed.
// The payload parameter is available for any extra information that a deployment system might need. It is a JSON text field
// that will be passed on when a deployment event is dispatched.
// The task parameter is used by the deployment system to allow different execution paths. In the web world this might be
// deploy:migrations to run schema changes on the system. In the compiled world this
// could be a flag to compile an application with debugging enabled.
// Users with repo or repo_deployment scopes can create a deployment for a given ref.
// MERGED BRANCH RESPONSE You will see this response when GitHub automatically merges the base branch into the topic branch
// instead of creating a deployment. This auto-merge happens when:
// * Auto-merge option is enabled in the repository
// * Topic branch does not include the latest changes on the base branch, which is master in the response example
// * There are no merge conflicts
// If there are no new commits in the base branch, a new request to create a deployment should give a successful response.
// MERGE CONFLICT RESPONSE This error happens when the auto_merge option is enabled and when the default branch (in this case
// master), can't be merged into the branch that's being deployed (in this case
// topic-branch), due to merge conflicts.
// FAILED COMMIT STATUS CHECKS This error happens when the required_contexts parameter indicates that one or more contexts
// need to have a successstatus for the commit to be deployed, but one or more of
// the required contexts do not have a state of success.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateDeploymentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateDeployment
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateDeployment(ctx context.Context, body Paths1Sk9Ql7ReposOwnerRepoDeploymentsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateDeploymentOptions) (GitHubV3RESTAPIClientReposCreateDeploymentResponse, error) {
	req, err := client.reposCreateDeploymentCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateDeploymentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateDeploymentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusAccepted, http.StatusConflict, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposCreateDeploymentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateDeploymentHandleResponse(resp)
}

// reposCreateDeploymentCreateRequest creates the ReposCreateDeployment request.
func (client *GitHubV3RESTAPIClient) reposCreateDeploymentCreateRequest(ctx context.Context, body Paths1Sk9Ql7ReposOwnerRepoDeploymentsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateDeploymentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/deployments"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreateDeploymentHandleResponse handles the ReposCreateDeployment response.
func (client *GitHubV3RESTAPIClient) reposCreateDeploymentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateDeploymentResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateDeploymentResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Deployment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateDeploymentResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val PathsDo27ImReposOwnerRepoDeploymentsPostResponses202ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateDeploymentResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateDeploymentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCreateDeploymentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCreateDeploymentBranchPolicy - Creates a deployment branch policy for an environment.
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the administration:write
// permission for the repository to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateDeploymentBranchPolicyOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateDeploymentBranchPolicy
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateDeploymentBranchPolicy(ctx context.Context, body DeploymentBranchPolicyNamePattern, options *GitHubV3RESTAPIClientReposCreateDeploymentBranchPolicyOptions) (GitHubV3RESTAPIClientReposCreateDeploymentBranchPolicyResponse, error) {
	req, err := client.reposCreateDeploymentBranchPolicyCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateDeploymentBranchPolicyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateDeploymentBranchPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusSeeOther, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposCreateDeploymentBranchPolicyResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateDeploymentBranchPolicyHandleResponse(resp)
}

// reposCreateDeploymentBranchPolicyCreateRequest creates the ReposCreateDeploymentBranchPolicy request.
func (client *GitHubV3RESTAPIClient) reposCreateDeploymentBranchPolicyCreateRequest(ctx context.Context, body DeploymentBranchPolicyNamePattern, options *GitHubV3RESTAPIClientReposCreateDeploymentBranchPolicyOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreateDeploymentBranchPolicyHandleResponse handles the ReposCreateDeploymentBranchPolicy response.
func (client *GitHubV3RESTAPIClient) reposCreateDeploymentBranchPolicyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateDeploymentBranchPolicyResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateDeploymentBranchPolicyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentBranchPolicy); err != nil {
		return GitHubV3RESTAPIClientReposCreateDeploymentBranchPolicyResponse{}, err
	}
	return result, nil
}

// ReposCreateDeploymentStatus - Users with push access can create deployment statuses for a given deployment.
// GitHub Apps require read & write access to "Deployments" and read-only access to "Repo contents" (for private repos). OAuth
// Apps require the repo_deployment scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateDeploymentStatusOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateDeploymentStatus
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateDeploymentStatus(ctx context.Context, body Paths1W1Jdo3ReposOwnerRepoDeploymentsDeploymentIDStatusesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateDeploymentStatusOptions) (GitHubV3RESTAPIClientReposCreateDeploymentStatusResponse, error) {
	req, err := client.reposCreateDeploymentStatusCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateDeploymentStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateDeploymentStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposCreateDeploymentStatusResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateDeploymentStatusHandleResponse(resp)
}

// reposCreateDeploymentStatusCreateRequest creates the ReposCreateDeploymentStatus request.
func (client *GitHubV3RESTAPIClient) reposCreateDeploymentStatusCreateRequest(ctx context.Context, body Paths1W1Jdo3ReposOwnerRepoDeploymentsDeploymentIDStatusesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateDeploymentStatusOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{deployment_id}", url.PathEscape(strconv.FormatInt(int64(client.deploymentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreateDeploymentStatusHandleResponse handles the ReposCreateDeploymentStatus response.
func (client *GitHubV3RESTAPIClient) reposCreateDeploymentStatusHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateDeploymentStatusResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateDeploymentStatusResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val DeploymentStatus
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateDeploymentStatusResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateDeploymentStatusResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCreateDeploymentStatusResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCreateDispatchEvent - You can use this endpoint to trigger a webhook event called repositorydispatch when you want
// activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook. You
// must configure your GitHub Actions workflow or GitHub App to run when the repositorydispatch event occurs. For an example
// repositorydispatch webhook payload, see "RepositoryDispatchEvent
// [https://docs.github.com/webhooks/event-payloads/#repositorydispatch]."
// The clientpayload parameter is available for any extra information that your workflow might need. This parameter is a JSON
// payload that will be passed on when the webhook event is dispatched. For
// example, the clientpayload can include a message that a user would like to send using a GitHub Actions workflow. Or the
// client_payload can be used as a test to debug your workflow.
// This endpoint requires write access to the repository by providing either:
// * Personal access tokens with repo scope. For more information, see "Creating a personal access token for the command line
// [https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line]" in the GitHub Help documentation.
// * GitHub Apps with both metadata:read and contents:read&write permissions.
// This input example shows how you can use the client_payload as a test to debug your workflow.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateDispatchEventOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateDispatchEvent
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateDispatchEvent(ctx context.Context, body Paths1Fqvg6ZReposOwnerRepoDispatchesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateDispatchEventOptions) (GitHubV3RESTAPIClientReposCreateDispatchEventResponse, error) {
	req, err := client.reposCreateDispatchEventCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateDispatchEventResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateDispatchEventResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposCreateDispatchEventResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateDispatchEventHandleResponse(resp)
}

// reposCreateDispatchEventCreateRequest creates the ReposCreateDispatchEvent request.
func (client *GitHubV3RESTAPIClient) reposCreateDispatchEventCreateRequest(ctx context.Context, body Paths1Fqvg6ZReposOwnerRepoDispatchesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateDispatchEventOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/dispatches"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreateDispatchEventHandleResponse handles the ReposCreateDispatchEvent response.
func (client *GitHubV3RESTAPIClient) reposCreateDispatchEventHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateDispatchEventResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateDispatchEventResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ValidationError); err != nil {
		return GitHubV3RESTAPIClientReposCreateDispatchEventResponse{}, err
	}
	return result, nil
}

// ReposCreateForAuthenticatedUser - Creates a new repository for the authenticated user.
// OAuth scope requirements
// When using OAuth [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/], authorizations
// must include:
// * public_repo scope or repo scope to create a public repository. Note: For GitHub AE, use repo scope to create an internal
// repository.
// * repo scope to create a private repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateForAuthenticatedUser(ctx context.Context, body PathsSereltUserReposPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateForAuthenticatedUserOptions) (GitHubV3RESTAPIClientReposCreateForAuthenticatedUserResponse, error) {
	req, err := client.reposCreateForAuthenticatedUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotModified, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposCreateForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateForAuthenticatedUserHandleResponse(resp)
}

// reposCreateForAuthenticatedUserCreateRequest creates the ReposCreateForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) reposCreateForAuthenticatedUserCreateRequest(ctx context.Context, body PathsSereltUserReposPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/repos"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreateForAuthenticatedUserHandleResponse handles the ReposCreateForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) reposCreateForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Repository
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCreateForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCreateFork - Create a fork for the authenticated user.
// Note: Forking a Repository happens asynchronously. You may have to wait a short period of time before you can access the
// git objects. If this takes longer than 5 minutes, be sure to contact GitHub
// Support [https://support.github.com/contact?tags=dotcom-rest-api].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateForkOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateFork
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateFork(ctx context.Context, options *GitHubV3RESTAPIClientReposCreateForkOptions) (GitHubV3RESTAPIClientReposCreateForkResponse, error) {
	req, err := client.reposCreateForkCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateForkResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateForkResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusBadRequest, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposCreateForkResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateForkHandleResponse(resp)
}

// reposCreateForkCreateRequest creates the ReposCreateFork request.
func (client *GitHubV3RESTAPIClient) reposCreateForkCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposCreateForkOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/forks"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// reposCreateForkHandleResponse handles the ReposCreateFork response.
func (client *GitHubV3RESTAPIClient) reposCreateForkHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateForkResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateForkResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val FullRepository
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateForkResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateForkResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateForkResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateForkResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateForkResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCreateForkResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCreateInOrg - Creates a new repository in the specified organization. The authenticated user must be a member of the
// organization.
// OAuth scope requirements
// When using OAuth [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/], authorizations
// must include:
// * public_repo scope or repo scope to create a public repository. Note: For GitHub AE, use repo scope to create an internal
// repository.
// * repo scope to create a private repository
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateInOrg
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateInOrg(ctx context.Context, body PathsXyx0QiOrgsOrgReposPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateInOrgOptions) (GitHubV3RESTAPIClientReposCreateInOrgResponse, error) {
	req, err := client.reposCreateInOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposCreateInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateInOrgHandleResponse(resp)
}

// reposCreateInOrgCreateRequest creates the ReposCreateInOrg request.
func (client *GitHubV3RESTAPIClient) reposCreateInOrgCreateRequest(ctx context.Context, body PathsXyx0QiOrgsOrgReposPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/repos"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreateInOrgHandleResponse handles the ReposCreateInOrg response.
func (client *GitHubV3RESTAPIClient) reposCreateInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateInOrgResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateInOrgResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Repository
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateInOrgResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateInOrgResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateInOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCreateInOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCreateOrUpdateEnvironment - Create or update an environment with protection rules, such as required reviewers. For
// more information about environment protection rules, see "Environments
// [/actions/reference/environments#environment-protection-rules]."
// Note: To create or update name patterns that branches must match in order to deploy to this environment, see "Deployment
// branch policies [/rest/deployments/branch-policies]."
// Note: To create or update secrets for an environment, see "Secrets [/rest/reference/actions#secrets]."
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the administration:write
// permission for the repository to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateOrUpdateEnvironmentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateOrUpdateEnvironment
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateOrUpdateEnvironment(ctx context.Context, body Paths1Pleh5PReposOwnerRepoEnvironmentsEnvironmentNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateOrUpdateEnvironmentOptions) (GitHubV3RESTAPIClientReposCreateOrUpdateEnvironmentResponse, error) {
	req, err := client.reposCreateOrUpdateEnvironmentCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateOrUpdateEnvironmentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateOrUpdateEnvironmentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposCreateOrUpdateEnvironmentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateOrUpdateEnvironmentHandleResponse(resp)
}

// reposCreateOrUpdateEnvironmentCreateRequest creates the ReposCreateOrUpdateEnvironment request.
func (client *GitHubV3RESTAPIClient) reposCreateOrUpdateEnvironmentCreateRequest(ctx context.Context, body Paths1Pleh5PReposOwnerRepoEnvironmentsEnvironmentNamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateOrUpdateEnvironmentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/environments/{environment_name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreateOrUpdateEnvironmentHandleResponse handles the ReposCreateOrUpdateEnvironment response.
func (client *GitHubV3RESTAPIClient) reposCreateOrUpdateEnvironmentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateOrUpdateEnvironmentResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateOrUpdateEnvironmentResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Environment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateOrUpdateEnvironmentResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateOrUpdateEnvironmentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCreateOrUpdateEnvironmentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCreateOrUpdateFileContents - Creates a new file or replaces an existing file in a repository. You must authenticate
// using an access token with the workflow scope to use this endpoint.
// Note: If you use this endpoint and the "Delete a file [https://docs.github.com/rest/reference/repos/#delete-file]" endpoint
// in parallel, the concurrent requests will conflict and you will receive
// errors. You must use these endpoints serially instead.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - pathParam - path parameter
//   - options - GitHubV3RESTAPIClientReposCreateOrUpdateFileContentsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateOrUpdateFileContents
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateOrUpdateFileContents(ctx context.Context, pathParam string, body Paths1Ipyvj6ReposOwnerRepoContentsPathPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateOrUpdateFileContentsOptions) (GitHubV3RESTAPIClientReposCreateOrUpdateFileContentsResponse, error) {
	req, err := client.reposCreateOrUpdateFileContentsCreateRequest(ctx, pathParam, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateOrUpdateFileContentsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateOrUpdateFileContentsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusNotFound, http.StatusConflict, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposCreateOrUpdateFileContentsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateOrUpdateFileContentsHandleResponse(resp)
}

// reposCreateOrUpdateFileContentsCreateRequest creates the ReposCreateOrUpdateFileContents request.
func (client *GitHubV3RESTAPIClient) reposCreateOrUpdateFileContentsCreateRequest(ctx context.Context, pathParam string, body Paths1Ipyvj6ReposOwnerRepoContentsPathPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateOrUpdateFileContentsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/contents/{path}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if pathParam == "" {
		return nil, errors.New("parameter pathParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{path}", url.PathEscape(pathParam))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreateOrUpdateFileContentsHandleResponse handles the ReposCreateOrUpdateFileContents response.
func (client *GitHubV3RESTAPIClient) reposCreateOrUpdateFileContentsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateOrUpdateFileContentsResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateOrUpdateFileContentsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val FileCommit
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateOrUpdateFileContentsResponse{}, err
	}
	result.Value = val
	case http.StatusCreated:
	var val FileCommit
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateOrUpdateFileContentsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateOrUpdateFileContentsResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateOrUpdateFileContentsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateOrUpdateFileContentsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCreateOrUpdateFileContentsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCreatePagesDeployment - Create a GitHub Pages deployment for a repository.
// Users must have write permissions. GitHub Apps must have the pages:write permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreatePagesDeploymentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreatePagesDeployment
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreatePagesDeployment(ctx context.Context, body PathsD66GtpReposOwnerRepoPagesDeploymentPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreatePagesDeploymentOptions) (GitHubV3RESTAPIClientReposCreatePagesDeploymentResponse, error) {
	req, err := client.reposCreatePagesDeploymentCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreatePagesDeploymentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreatePagesDeploymentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposCreatePagesDeploymentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreatePagesDeploymentHandleResponse(resp)
}

// reposCreatePagesDeploymentCreateRequest creates the ReposCreatePagesDeployment request.
func (client *GitHubV3RESTAPIClient) reposCreatePagesDeploymentCreateRequest(ctx context.Context, body PathsD66GtpReposOwnerRepoPagesDeploymentPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreatePagesDeploymentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pages/deployment"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreatePagesDeploymentHandleResponse handles the ReposCreatePagesDeployment response.
func (client *GitHubV3RESTAPIClient) reposCreatePagesDeploymentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreatePagesDeploymentResponse, error) {
	result := GitHubV3RESTAPIClientReposCreatePagesDeploymentResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PageDeployment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreatePagesDeploymentResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreatePagesDeploymentResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreatePagesDeploymentResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreatePagesDeploymentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCreatePagesDeploymentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCreatePagesSite - Configures a GitHub Pages site. For more information, see "About GitHub Pages [/github/working-with-github-pages/about-github-pages]."
// To use this endpoint, you must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.
// A token with the repo scope or Pages write permission is required.
// GitHub Apps must have the administration:write and pages:write permissions.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreatePagesSiteOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreatePagesSite
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreatePagesSite(ctx context.Context, body PathsHsyzflReposOwnerRepoPagesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreatePagesSiteOptions) (GitHubV3RESTAPIClientReposCreatePagesSiteResponse, error) {
	req, err := client.reposCreatePagesSiteCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreatePagesSiteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreatePagesSiteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusConflict, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposCreatePagesSiteResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreatePagesSiteHandleResponse(resp)
}

// reposCreatePagesSiteCreateRequest creates the ReposCreatePagesSite request.
func (client *GitHubV3RESTAPIClient) reposCreatePagesSiteCreateRequest(ctx context.Context, body PathsHsyzflReposOwnerRepoPagesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreatePagesSiteOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pages"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreatePagesSiteHandleResponse handles the ReposCreatePagesSite response.
func (client *GitHubV3RESTAPIClient) reposCreatePagesSiteHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreatePagesSiteResponse, error) {
	result := GitHubV3RESTAPIClientReposCreatePagesSiteResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Page
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreatePagesSiteResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreatePagesSiteResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreatePagesSiteResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCreatePagesSiteResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCreateRelease - Users with push access to the repository can create a release.
// This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// Creating content too quickly using this endpoint may
// result in secondary rate limiting. See "Secondary rate limits [https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits]"
// and "Dealing with secondary rate limits
// [https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits]" for details.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateReleaseOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateRelease
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateRelease(ctx context.Context, body PathsB37Lt6ReposOwnerRepoReleasesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateReleaseOptions) (GitHubV3RESTAPIClientReposCreateReleaseResponse, error) {
	req, err := client.reposCreateReleaseCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateReleaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateReleaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposCreateReleaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateReleaseHandleResponse(resp)
}

// reposCreateReleaseCreateRequest creates the ReposCreateRelease request.
func (client *GitHubV3RESTAPIClient) reposCreateReleaseCreateRequest(ctx context.Context, body PathsB37Lt6ReposOwnerRepoReleasesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateReleaseOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/releases"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreateReleaseHandleResponse handles the ReposCreateRelease response.
func (client *GitHubV3RESTAPIClient) reposCreateReleaseHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateReleaseResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateReleaseResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Release
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateReleaseResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateReleaseResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateReleaseResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCreateReleaseResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCreateTagProtection - This creates a tag protection state for a repository. This endpoint is only available to repository
// administrators.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateTagProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateTagProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateTagProtection(ctx context.Context, body Paths5LakcmReposOwnerRepoTagsProtectionPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateTagProtectionOptions) (GitHubV3RESTAPIClientReposCreateTagProtectionResponse, error) {
	req, err := client.reposCreateTagProtectionCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateTagProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateTagProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposCreateTagProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateTagProtectionHandleResponse(resp)
}

// reposCreateTagProtectionCreateRequest creates the ReposCreateTagProtection request.
func (client *GitHubV3RESTAPIClient) reposCreateTagProtectionCreateRequest(ctx context.Context, body Paths5LakcmReposOwnerRepoTagsProtectionPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateTagProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/tags/protection"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreateTagProtectionHandleResponse handles the ReposCreateTagProtection response.
func (client *GitHubV3RESTAPIClient) reposCreateTagProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateTagProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateTagProtectionResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val TagProtection
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateTagProtectionResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateTagProtectionResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateTagProtectionResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCreateTagProtectionResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposCreateUsingTemplate - Creates a new repository using a repository template. Use the templateowner and templaterepo
// route parameters to specify the repository to use as the template. If the repository is not public, the
// authenticated user must own or be a member of an organization that owns the repository. To check if a repository is available
// to use as a template, get the repository's information using the Get a
// repository [https://docs.github.com/rest/reference/repos#get-a-repository] endpoint and check that the is_template key
// is true.
// OAuth scope requirements
// When using OAuth [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/], authorizations
// must include:
// * public_repo scope or repo scope to create a public repository. Note: For GitHub AE, use repo scope to create an internal
// repository.
// * repo scope to create a private repository
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateUsingTemplateOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateUsingTemplate
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateUsingTemplate(ctx context.Context, templateOwner string, templateRepo string, body PathsSia9ThReposTemplateOwnerTemplateRepoGeneratePostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateUsingTemplateOptions) (GitHubV3RESTAPIClientReposCreateUsingTemplateResponse, error) {
	req, err := client.reposCreateUsingTemplateCreateRequest(ctx, templateOwner, templateRepo, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateUsingTemplateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateUsingTemplateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientReposCreateUsingTemplateResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateUsingTemplateHandleResponse(resp)
}

// reposCreateUsingTemplateCreateRequest creates the ReposCreateUsingTemplate request.
func (client *GitHubV3RESTAPIClient) reposCreateUsingTemplateCreateRequest(ctx context.Context, templateOwner string, templateRepo string, body PathsSia9ThReposTemplateOwnerTemplateRepoGeneratePostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposCreateUsingTemplateOptions) (*policy.Request, error) {
	urlPath := "/repos/{template_owner}/{template_repo}/generate"
	if templateOwner == "" {
		return nil, errors.New("parameter templateOwner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{template_owner}", url.PathEscape(templateOwner))
	if templateRepo == "" {
		return nil, errors.New("parameter templateRepo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{template_repo}", url.PathEscape(templateRepo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposCreateUsingTemplateHandleResponse handles the ReposCreateUsingTemplate response.
func (client *GitHubV3RESTAPIClient) reposCreateUsingTemplateHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateUsingTemplateResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateUsingTemplateResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Repository); err != nil {
		return GitHubV3RESTAPIClientReposCreateUsingTemplateResponse{}, err
	}
	return result, nil
}

// ReposCreateWebhook - Repositories can have multiple webhooks installed. Each webhook should have a unique config. Multiple
// webhooks can share the same config as long as those webhooks do not have any events that overlap.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposCreateWebhookOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposCreateWebhook
//     method.
func (client *GitHubV3RESTAPIClient) ReposCreateWebhook(ctx context.Context, options *GitHubV3RESTAPIClientReposCreateWebhookOptions) (GitHubV3RESTAPIClientReposCreateWebhookResponse, error) {
	req, err := client.reposCreateWebhookCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateWebhookResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposCreateWebhookResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposCreateWebhookResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposCreateWebhookHandleResponse(resp)
}

// reposCreateWebhookCreateRequest creates the ReposCreateWebhook request.
func (client *GitHubV3RESTAPIClient) reposCreateWebhookCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposCreateWebhookOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/hooks"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// reposCreateWebhookHandleResponse handles the ReposCreateWebhook response.
func (client *GitHubV3RESTAPIClient) reposCreateWebhookHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposCreateWebhookResponse, error) {
	result := GitHubV3RESTAPIClientReposCreateWebhookResponse{}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Hook
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateWebhookResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateWebhookResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateWebhookResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposCreateWebhookResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposCreateWebhookResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposDeclineInvitationForAuthenticatedUser - Decline a repository invitation
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeclineInvitationForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ReposDeclineInvitationForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) ReposDeclineInvitationForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientReposDeclineInvitationForAuthenticatedUserOptions) (GitHubV3RESTAPIClientReposDeclineInvitationForAuthenticatedUserResponse, error) {
	req, err := client.reposDeclineInvitationForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeclineInvitationForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeclineInvitationForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound, http.StatusConflict) {
		return GitHubV3RESTAPIClientReposDeclineInvitationForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposDeclineInvitationForAuthenticatedUserHandleResponse(resp)
}

// reposDeclineInvitationForAuthenticatedUserCreateRequest creates the ReposDeclineInvitationForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) reposDeclineInvitationForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeclineInvitationForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/repository_invitations/{invitation_id}"
	urlPath = strings.ReplaceAll(urlPath, "{invitation_id}", url.PathEscape(strconv.FormatInt(int64(client.invitationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposDeclineInvitationForAuthenticatedUserHandleResponse handles the ReposDeclineInvitationForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) reposDeclineInvitationForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposDeclineInvitationForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientReposDeclineInvitationForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientReposDeclineInvitationForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// ReposDelete - Deleting a repository requires admin access. If OAuth is used, the delete_repo scope is required.
// If an organization owner has configured the organization to prevent members from deleting organization-owned repositories,
// you will get a 403 Forbidden response.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeleteOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDelete
//     method.
func (client *GitHubV3RESTAPIClient) ReposDelete(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteOptions) (GitHubV3RESTAPIClientReposDeleteResponse, error) {
	req, err := client.reposDeleteCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposDeleteResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposDeleteHandleResponse(resp)
}

// reposDeleteCreateRequest creates the ReposDelete request.
func (client *GitHubV3RESTAPIClient) reposDeleteCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposDeleteHandleResponse handles the ReposDelete response.
func (client *GitHubV3RESTAPIClient) reposDeleteHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposDeleteResponse, error) {
	result := GitHubV3RESTAPIClientReposDeleteResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusForbidden:
	var val Paths1Ckzl6WReposOwnerRepoDeleteResponses403ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposDeleteResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposDeleteResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposDeleteResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposDeleteAccessRestrictions - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Disables the ability to restrict who can push to this branch.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeleteAccessRestrictionsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeleteAccessRestrictions
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeleteAccessRestrictions(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteAccessRestrictionsOptions) (GitHubV3RESTAPIClientReposDeleteAccessRestrictionsResponse, error) {
	req, err := client.reposDeleteAccessRestrictionsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteAccessRestrictionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteAccessRestrictionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposDeleteAccessRestrictionsResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposDeleteAccessRestrictionsResponse{}, nil
}

// reposDeleteAccessRestrictionsCreateRequest creates the ReposDeleteAccessRestrictions request.
func (client *GitHubV3RESTAPIClient) reposDeleteAccessRestrictionsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteAccessRestrictionsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// ReposDeleteAdminBranchProtection - Protected branches are available in public repositories with GitHub Free and GitHub
// Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Removing admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeleteAdminBranchProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeleteAdminBranchProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeleteAdminBranchProtection(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteAdminBranchProtectionOptions) (GitHubV3RESTAPIClientReposDeleteAdminBranchProtectionResponse, error) {
	req, err := client.reposDeleteAdminBranchProtectionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteAdminBranchProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteAdminBranchProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposDeleteAdminBranchProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposDeleteAdminBranchProtectionHandleResponse(resp)
}

// reposDeleteAdminBranchProtectionCreateRequest creates the ReposDeleteAdminBranchProtection request.
func (client *GitHubV3RESTAPIClient) reposDeleteAdminBranchProtectionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteAdminBranchProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposDeleteAdminBranchProtectionHandleResponse handles the ReposDeleteAdminBranchProtection response.
func (client *GitHubV3RESTAPIClient) reposDeleteAdminBranchProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposDeleteAdminBranchProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposDeleteAdminBranchProtectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientReposDeleteAdminBranchProtectionResponse{}, err
	}
	return result, nil
}

// ReposDeleteAnEnvironment - You must authenticate using an access token with the repo scope to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeleteAnEnvironmentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeleteAnEnvironment
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeleteAnEnvironment(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteAnEnvironmentOptions) (GitHubV3RESTAPIClientReposDeleteAnEnvironmentResponse, error) {
	req, err := client.reposDeleteAnEnvironmentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteAnEnvironmentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteAnEnvironmentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposDeleteAnEnvironmentResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposDeleteAnEnvironmentResponse{}, nil
}

// reposDeleteAnEnvironmentCreateRequest creates the ReposDeleteAnEnvironment request.
func (client *GitHubV3RESTAPIClient) reposDeleteAnEnvironmentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteAnEnvironmentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/environments/{environment_name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReposDeleteAutolink - This deletes a single autolink reference by ID that was configured for the given repository.
// Information about autolinks are only available to repository administrators.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeleteAutolinkOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeleteAutolink
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeleteAutolink(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteAutolinkOptions) (GitHubV3RESTAPIClientReposDeleteAutolinkResponse, error) {
	req, err := client.reposDeleteAutolinkCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteAutolinkResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteAutolinkResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposDeleteAutolinkResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposDeleteAutolinkHandleResponse(resp)
}

// reposDeleteAutolinkCreateRequest creates the ReposDeleteAutolink request.
func (client *GitHubV3RESTAPIClient) reposDeleteAutolinkCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteAutolinkOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/autolinks/{autolink_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{autolink_id}", url.PathEscape(strconv.FormatInt(int64(client.autolinkID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposDeleteAutolinkHandleResponse handles the ReposDeleteAutolink response.
func (client *GitHubV3RESTAPIClient) reposDeleteAutolinkHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposDeleteAutolinkResponse, error) {
	result := GitHubV3RESTAPIClientReposDeleteAutolinkResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientReposDeleteAutolinkResponse{}, err
	}
	return result, nil
}

// ReposDeleteBranchProtection - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeleteBranchProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeleteBranchProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeleteBranchProtection(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteBranchProtectionOptions) (GitHubV3RESTAPIClientReposDeleteBranchProtectionResponse, error) {
	req, err := client.reposDeleteBranchProtectionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteBranchProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteBranchProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusForbidden) {
		return GitHubV3RESTAPIClientReposDeleteBranchProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposDeleteBranchProtectionHandleResponse(resp)
}

// reposDeleteBranchProtectionCreateRequest creates the ReposDeleteBranchProtection request.
func (client *GitHubV3RESTAPIClient) reposDeleteBranchProtectionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteBranchProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposDeleteBranchProtectionHandleResponse handles the ReposDeleteBranchProtection response.
func (client *GitHubV3RESTAPIClient) reposDeleteBranchProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposDeleteBranchProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposDeleteBranchProtectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientReposDeleteBranchProtectionResponse{}, err
	}
	return result, nil
}

// ReposDeleteCommitComment - Delete a commit comment
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeleteCommitCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeleteCommitComment
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeleteCommitComment(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteCommitCommentOptions) (GitHubV3RESTAPIClientReposDeleteCommitCommentResponse, error) {
	req, err := client.reposDeleteCommitCommentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteCommitCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteCommitCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposDeleteCommitCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposDeleteCommitCommentHandleResponse(resp)
}

// reposDeleteCommitCommentCreateRequest creates the ReposDeleteCommitComment request.
func (client *GitHubV3RESTAPIClient) reposDeleteCommitCommentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteCommitCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/comments/{comment_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposDeleteCommitCommentHandleResponse handles the ReposDeleteCommitComment response.
func (client *GitHubV3RESTAPIClient) reposDeleteCommitCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposDeleteCommitCommentResponse, error) {
	result := GitHubV3RESTAPIClientReposDeleteCommitCommentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientReposDeleteCommitCommentResponse{}, err
	}
	return result, nil
}

// ReposDeleteCommitSignatureProtection - Protected branches are available in public repositories with GitHub Free and GitHub
// Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// When authenticated with admin or owner permissions to the repository, you can use this endpoint to disable required signed
// commits on a branch. You must enable branch protection to require signed
// commits.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeleteCommitSignatureProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeleteCommitSignatureProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeleteCommitSignatureProtection(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteCommitSignatureProtectionOptions) (GitHubV3RESTAPIClientReposDeleteCommitSignatureProtectionResponse, error) {
	req, err := client.reposDeleteCommitSignatureProtectionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteCommitSignatureProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteCommitSignatureProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposDeleteCommitSignatureProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposDeleteCommitSignatureProtectionHandleResponse(resp)
}

// reposDeleteCommitSignatureProtectionCreateRequest creates the ReposDeleteCommitSignatureProtection request.
func (client *GitHubV3RESTAPIClient) reposDeleteCommitSignatureProtectionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteCommitSignatureProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposDeleteCommitSignatureProtectionHandleResponse handles the ReposDeleteCommitSignatureProtection response.
func (client *GitHubV3RESTAPIClient) reposDeleteCommitSignatureProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposDeleteCommitSignatureProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposDeleteCommitSignatureProtectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientReposDeleteCommitSignatureProtectionResponse{}, err
	}
	return result, nil
}

// ReposDeleteDeployKey - Deploy keys are immutable. If you need to update a key, remove the key and create a new one instead.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeleteDeployKeyOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeleteDeployKey
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeleteDeployKey(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteDeployKeyOptions) (GitHubV3RESTAPIClientReposDeleteDeployKeyResponse, error) {
	req, err := client.reposDeleteDeployKeyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteDeployKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteDeployKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposDeleteDeployKeyResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposDeleteDeployKeyResponse{}, nil
}

// reposDeleteDeployKeyCreateRequest creates the ReposDeleteDeployKey request.
func (client *GitHubV3RESTAPIClient) reposDeleteDeployKeyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteDeployKeyOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/keys/{key_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{key_id}", url.PathEscape(strconv.FormatInt(int64(client.keyID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReposDeleteDeployment - If the repository only has one deployment, you can delete the deployment regardless of its status.
// If the repository has more than one deployment, you can only delete inactive deployments. This
// ensures that repositories with multiple deployments will always have an active deployment. Anyone with repo or repo_deployment
// scopes can delete a deployment.
// To set a deployment as inactive, you must:
// * Create a new deployment that is active so that the system has a record of the current state, then delete the previously
// active deployment.
// * Mark the active deployment as inactive by adding any non-successful deployment status.
// For more information, see "Create a deployment [https://docs.github.com/rest/deployments/deployments/#create-a-deployment]"
// and "Create a deployment status
// [https://docs.github.com/rest/deployments/deployment-statuses#create-a-deployment-status]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeleteDeploymentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeleteDeployment
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeleteDeployment(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteDeploymentOptions) (GitHubV3RESTAPIClientReposDeleteDeploymentResponse, error) {
	req, err := client.reposDeleteDeploymentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteDeploymentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteDeploymentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposDeleteDeploymentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposDeleteDeploymentHandleResponse(resp)
}

// reposDeleteDeploymentCreateRequest creates the ReposDeleteDeployment request.
func (client *GitHubV3RESTAPIClient) reposDeleteDeploymentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteDeploymentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/deployments/{deployment_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{deployment_id}", url.PathEscape(strconv.FormatInt(int64(client.deploymentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposDeleteDeploymentHandleResponse handles the ReposDeleteDeployment response.
func (client *GitHubV3RESTAPIClient) reposDeleteDeploymentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposDeleteDeploymentResponse, error) {
	result := GitHubV3RESTAPIClientReposDeleteDeploymentResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposDeleteDeploymentResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposDeleteDeploymentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposDeleteDeploymentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposDeleteDeploymentBranchPolicy - Deletes a deployment branch policy for an environment.
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the administration:write
// permission for the repository to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeleteDeploymentBranchPolicyOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeleteDeploymentBranchPolicy
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeleteDeploymentBranchPolicy(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteDeploymentBranchPolicyOptions) (GitHubV3RESTAPIClientReposDeleteDeploymentBranchPolicyResponse, error) {
	req, err := client.reposDeleteDeploymentBranchPolicyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteDeploymentBranchPolicyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteDeploymentBranchPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposDeleteDeploymentBranchPolicyResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposDeleteDeploymentBranchPolicyResponse{}, nil
}

// reposDeleteDeploymentBranchPolicyCreateRequest creates the ReposDeleteDeploymentBranchPolicy request.
func (client *GitHubV3RESTAPIClient) reposDeleteDeploymentBranchPolicyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteDeploymentBranchPolicyOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	urlPath = strings.ReplaceAll(urlPath, "{branch_policy_id}", url.PathEscape(strconv.FormatInt(int64(client.branchPolicyID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReposDeleteFile - Deletes a file in a repository.
// You can provide an additional committer parameter, which is an object containing information about the committer. Or, you
// can provide an author parameter, which is an object containing information
// about the author.
// The author section is optional and is filled in with the committer information if omitted. If the committer information
// is omitted, the authenticated user's information is used.
// You must provide values for both name and email, whether you choose to use author or committer. Otherwise, you'll receive
// a 422 status code.
// Note: If you use this endpoint and the "Create or update file contents [https://docs.github.com/rest/reference/repos/#create-or-update-file-contents]"
// endpoint in parallel, the concurrent requests
// will conflict and you will receive errors. You must use these endpoints serially instead.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - pathParam - path parameter
//   - options - GitHubV3RESTAPIClientReposDeleteFileOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeleteFile
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeleteFile(ctx context.Context, pathParam string, body Paths1Kt5AynReposOwnerRepoContentsPathDeleteRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposDeleteFileOptions) (GitHubV3RESTAPIClientReposDeleteFileResponse, error) {
	req, err := client.reposDeleteFileCreateRequest(ctx, pathParam, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteFileResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteFileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusConflict, http.StatusUnprocessableEntity, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientReposDeleteFileResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposDeleteFileHandleResponse(resp)
}

// reposDeleteFileCreateRequest creates the ReposDeleteFile request.
func (client *GitHubV3RESTAPIClient) reposDeleteFileCreateRequest(ctx context.Context, pathParam string, body Paths1Kt5AynReposOwnerRepoContentsPathDeleteRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposDeleteFileOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/contents/{path}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if pathParam == "" {
		return nil, errors.New("parameter pathParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{path}", url.PathEscape(pathParam))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposDeleteFileHandleResponse handles the ReposDeleteFile response.
func (client *GitHubV3RESTAPIClient) reposDeleteFileHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposDeleteFileResponse, error) {
	result := GitHubV3RESTAPIClientReposDeleteFileResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val FileCommit
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposDeleteFileResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposDeleteFileResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposDeleteFileResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposDeleteFileResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposDeleteFileResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposDeleteFileResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposDeleteInvitation - Delete a repository invitation
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeleteInvitationOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeleteInvitation
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeleteInvitation(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteInvitationOptions) (GitHubV3RESTAPIClientReposDeleteInvitationResponse, error) {
	req, err := client.reposDeleteInvitationCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteInvitationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteInvitationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposDeleteInvitationResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposDeleteInvitationResponse{}, nil
}

// reposDeleteInvitationCreateRequest creates the ReposDeleteInvitation request.
func (client *GitHubV3RESTAPIClient) reposDeleteInvitationCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteInvitationOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/invitations/{invitation_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{invitation_id}", url.PathEscape(strconv.FormatInt(int64(client.invitationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReposDeletePagesSite - Deletes a GitHub Pages site. For more information, see "About GitHub Pages [/github/working-with-github-pages/about-github-pages].
// To use this endpoint, you must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.
// A token with the repo scope or Pages write permission is required.
// GitHub Apps must have the administration:write and pages:write permissions.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeletePagesSiteOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeletePagesSite
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeletePagesSite(ctx context.Context, options *GitHubV3RESTAPIClientReposDeletePagesSiteOptions) (GitHubV3RESTAPIClientReposDeletePagesSiteResponse, error) {
	req, err := client.reposDeletePagesSiteCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeletePagesSiteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeletePagesSiteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound, http.StatusConflict, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposDeletePagesSiteResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposDeletePagesSiteHandleResponse(resp)
}

// reposDeletePagesSiteCreateRequest creates the ReposDeletePagesSite request.
func (client *GitHubV3RESTAPIClient) reposDeletePagesSiteCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeletePagesSiteOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pages"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposDeletePagesSiteHandleResponse handles the ReposDeletePagesSite response.
func (client *GitHubV3RESTAPIClient) reposDeletePagesSiteHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposDeletePagesSiteResponse, error) {
	result := GitHubV3RESTAPIClientReposDeletePagesSiteResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposDeletePagesSiteResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposDeletePagesSiteResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposDeletePagesSiteResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposDeletePagesSiteResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposDeletePullRequestReviewProtection - Protected branches are available in public repositories with GitHub Free and GitHub
// Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeletePullRequestReviewProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeletePullRequestReviewProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeletePullRequestReviewProtection(ctx context.Context, options *GitHubV3RESTAPIClientReposDeletePullRequestReviewProtectionOptions) (GitHubV3RESTAPIClientReposDeletePullRequestReviewProtectionResponse, error) {
	req, err := client.reposDeletePullRequestReviewProtectionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeletePullRequestReviewProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeletePullRequestReviewProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposDeletePullRequestReviewProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposDeletePullRequestReviewProtectionHandleResponse(resp)
}

// reposDeletePullRequestReviewProtectionCreateRequest creates the ReposDeletePullRequestReviewProtection request.
func (client *GitHubV3RESTAPIClient) reposDeletePullRequestReviewProtectionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeletePullRequestReviewProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposDeletePullRequestReviewProtectionHandleResponse handles the ReposDeletePullRequestReviewProtection response.
func (client *GitHubV3RESTAPIClient) reposDeletePullRequestReviewProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposDeletePullRequestReviewProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposDeletePullRequestReviewProtectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientReposDeletePullRequestReviewProtectionResponse{}, err
	}
	return result, nil
}

// ReposDeleteRelease - Users with push access to the repository can delete a release.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeleteReleaseOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeleteRelease
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeleteRelease(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteReleaseOptions) (GitHubV3RESTAPIClientReposDeleteReleaseResponse, error) {
	req, err := client.reposDeleteReleaseCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteReleaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteReleaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposDeleteReleaseResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposDeleteReleaseResponse{}, nil
}

// reposDeleteReleaseCreateRequest creates the ReposDeleteRelease request.
func (client *GitHubV3RESTAPIClient) reposDeleteReleaseCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteReleaseOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/releases/{release_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{release_id}", url.PathEscape(strconv.FormatInt(int64(client.releaseID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReposDeleteReleaseAsset - Delete a release asset
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeleteReleaseAssetOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeleteReleaseAsset
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeleteReleaseAsset(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteReleaseAssetOptions) (GitHubV3RESTAPIClientReposDeleteReleaseAssetResponse, error) {
	req, err := client.reposDeleteReleaseAssetCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteReleaseAssetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteReleaseAssetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposDeleteReleaseAssetResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposDeleteReleaseAssetResponse{}, nil
}

// reposDeleteReleaseAssetCreateRequest creates the ReposDeleteReleaseAsset request.
func (client *GitHubV3RESTAPIClient) reposDeleteReleaseAssetCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteReleaseAssetOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/releases/assets/{asset_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{asset_id}", url.PathEscape(strconv.FormatInt(int64(client.assetID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReposDeleteTagProtection - This deletes a tag protection state for a repository. This endpoint is only available to repository
// administrators.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeleteTagProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeleteTagProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeleteTagProtection(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteTagProtectionOptions) (GitHubV3RESTAPIClientReposDeleteTagProtectionResponse, error) {
	req, err := client.reposDeleteTagProtectionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteTagProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteTagProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposDeleteTagProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposDeleteTagProtectionHandleResponse(resp)
}

// reposDeleteTagProtectionCreateRequest creates the ReposDeleteTagProtection request.
func (client *GitHubV3RESTAPIClient) reposDeleteTagProtectionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteTagProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{tag_protection_id}", url.PathEscape(strconv.FormatInt(int64(client.tagProtectionID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposDeleteTagProtectionHandleResponse handles the ReposDeleteTagProtection response.
func (client *GitHubV3RESTAPIClient) reposDeleteTagProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposDeleteTagProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposDeleteTagProtectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientReposDeleteTagProtectionResponse{}, err
	}
	return result, nil
}

// ReposDeleteWebhook - Delete a repository webhook
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDeleteWebhookOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDeleteWebhook
//     method.
func (client *GitHubV3RESTAPIClient) ReposDeleteWebhook(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteWebhookOptions) (GitHubV3RESTAPIClientReposDeleteWebhookResponse, error) {
	req, err := client.reposDeleteWebhookCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteWebhookResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDeleteWebhookResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposDeleteWebhookResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposDeleteWebhookHandleResponse(resp)
}

// reposDeleteWebhookCreateRequest creates the ReposDeleteWebhook request.
func (client *GitHubV3RESTAPIClient) reposDeleteWebhookCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDeleteWebhookOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/hooks/{hook_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposDeleteWebhookHandleResponse handles the ReposDeleteWebhook response.
func (client *GitHubV3RESTAPIClient) reposDeleteWebhookHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposDeleteWebhookResponse, error) {
	result := GitHubV3RESTAPIClientReposDeleteWebhookResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientReposDeleteWebhookResponse{}, err
	}
	return result, nil
}

// ReposDisableAutomatedSecurityFixes - Disables automated security fixes for a repository. The authenticated user must have
// admin access to the repository. For more information, see "Configuring automated security fixes
// [https://docs.github.com/articles/configuring-automated-security-fixes]".
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDisableAutomatedSecurityFixesOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDisableAutomatedSecurityFixes
//     method.
func (client *GitHubV3RESTAPIClient) ReposDisableAutomatedSecurityFixes(ctx context.Context, options *GitHubV3RESTAPIClientReposDisableAutomatedSecurityFixesOptions) (GitHubV3RESTAPIClientReposDisableAutomatedSecurityFixesResponse, error) {
	req, err := client.reposDisableAutomatedSecurityFixesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDisableAutomatedSecurityFixesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDisableAutomatedSecurityFixesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposDisableAutomatedSecurityFixesResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposDisableAutomatedSecurityFixesResponse{}, nil
}

// reposDisableAutomatedSecurityFixesCreateRequest creates the ReposDisableAutomatedSecurityFixes request.
func (client *GitHubV3RESTAPIClient) reposDisableAutomatedSecurityFixesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDisableAutomatedSecurityFixesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/automated-security-fixes"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReposDisableLfsForRepo - Disables Git LFS for a repository. Access tokens must have the admin:enterprise scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDisableLfsForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDisableLfsForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ReposDisableLfsForRepo(ctx context.Context, options *GitHubV3RESTAPIClientReposDisableLfsForRepoOptions) (GitHubV3RESTAPIClientReposDisableLfsForRepoResponse, error) {
	req, err := client.reposDisableLfsForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDisableLfsForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDisableLfsForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposDisableLfsForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposDisableLfsForRepoResponse{}, nil
}

// reposDisableLfsForRepoCreateRequest creates the ReposDisableLfsForRepo request.
func (client *GitHubV3RESTAPIClient) reposDisableLfsForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDisableLfsForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/lfs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReposDisableVulnerabilityAlerts - Disables dependency alerts and the dependency graph for a repository. The authenticated
// user must have admin access to the repository. For more information, see "About security alerts for vulnerable
// dependencies [https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies]".
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDisableVulnerabilityAlertsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDisableVulnerabilityAlerts
//     method.
func (client *GitHubV3RESTAPIClient) ReposDisableVulnerabilityAlerts(ctx context.Context, options *GitHubV3RESTAPIClientReposDisableVulnerabilityAlertsOptions) (GitHubV3RESTAPIClientReposDisableVulnerabilityAlertsResponse, error) {
	req, err := client.reposDisableVulnerabilityAlertsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDisableVulnerabilityAlertsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDisableVulnerabilityAlertsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposDisableVulnerabilityAlertsResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposDisableVulnerabilityAlertsResponse{}, nil
}

// reposDisableVulnerabilityAlertsCreateRequest creates the ReposDisableVulnerabilityAlerts request.
func (client *GitHubV3RESTAPIClient) reposDisableVulnerabilityAlertsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposDisableVulnerabilityAlertsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/vulnerability-alerts"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReposDownloadTarballArchive - Gets a redirect URL to download a tar archive for a repository. If you omit :ref, the repositorys
// default branch (usuallymain) will be used. Please make sure your HTTP framework is configured to
// follow redirects or you will need to use the Location header to make a second GET request.Note: For private repositories,
// these links are temporary and expire after five minutes.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDownloadTarballArchiveOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDownloadTarballArchive
//     method.
func (client *GitHubV3RESTAPIClient) ReposDownloadTarballArchive(ctx context.Context, ref string, options *GitHubV3RESTAPIClientReposDownloadTarballArchiveOptions) (GitHubV3RESTAPIClientReposDownloadTarballArchiveResponse, error) {
	req, err := client.reposDownloadTarballArchiveCreateRequest(ctx, ref, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDownloadTarballArchiveResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDownloadTarballArchiveResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposDownloadTarballArchiveResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposDownloadTarballArchiveResponse{}, nil
}

// reposDownloadTarballArchiveCreateRequest creates the ReposDownloadTarballArchive request.
func (client *GitHubV3RESTAPIClient) reposDownloadTarballArchiveCreateRequest(ctx context.Context, ref string, options *GitHubV3RESTAPIClientReposDownloadTarballArchiveOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/tarball/{ref}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if ref == "" {
		return nil, errors.New("parameter ref cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{ref}", url.PathEscape(ref))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReposDownloadZipballArchive - Gets a redirect URL to download a zip archive for a repository. If you omit :ref, the repositorys
// default branch (usuallymain) will be used. Please make sure your HTTP framework is configured to
// follow redirects or you will need to use the Location header to make a second GET request.
// Note: For private repositories, these links are temporary and expire after five minutes. If the repository is empty, you
// will receive a 404 when you follow the redirect.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposDownloadZipballArchiveOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposDownloadZipballArchive
//     method.
func (client *GitHubV3RESTAPIClient) ReposDownloadZipballArchive(ctx context.Context, ref string, options *GitHubV3RESTAPIClientReposDownloadZipballArchiveOptions) (GitHubV3RESTAPIClientReposDownloadZipballArchiveResponse, error) {
	req, err := client.reposDownloadZipballArchiveCreateRequest(ctx, ref, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposDownloadZipballArchiveResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposDownloadZipballArchiveResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposDownloadZipballArchiveResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposDownloadZipballArchiveResponse{}, nil
}

// reposDownloadZipballArchiveCreateRequest creates the ReposDownloadZipballArchive request.
func (client *GitHubV3RESTAPIClient) reposDownloadZipballArchiveCreateRequest(ctx context.Context, ref string, options *GitHubV3RESTAPIClientReposDownloadZipballArchiveOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/zipball/{ref}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if ref == "" {
		return nil, errors.New("parameter ref cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{ref}", url.PathEscape(ref))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReposEnableAutomatedSecurityFixes - Enables automated security fixes for a repository. The authenticated user must have
// admin access to the repository. For more information, see "Configuring automated security fixes
// [https://docs.github.com/articles/configuring-automated-security-fixes]".
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposEnableAutomatedSecurityFixesOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposEnableAutomatedSecurityFixes
//     method.
func (client *GitHubV3RESTAPIClient) ReposEnableAutomatedSecurityFixes(ctx context.Context, options *GitHubV3RESTAPIClientReposEnableAutomatedSecurityFixesOptions) (GitHubV3RESTAPIClientReposEnableAutomatedSecurityFixesResponse, error) {
	req, err := client.reposEnableAutomatedSecurityFixesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposEnableAutomatedSecurityFixesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposEnableAutomatedSecurityFixesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposEnableAutomatedSecurityFixesResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposEnableAutomatedSecurityFixesResponse{}, nil
}

// reposEnableAutomatedSecurityFixesCreateRequest creates the ReposEnableAutomatedSecurityFixes request.
func (client *GitHubV3RESTAPIClient) reposEnableAutomatedSecurityFixesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposEnableAutomatedSecurityFixesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/automated-security-fixes"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReposEnableLfsForRepo - Enables Git LFS for a repository. Access tokens must have the admin:enterprise scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposEnableLfsForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposEnableLfsForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ReposEnableLfsForRepo(ctx context.Context, options *GitHubV3RESTAPIClientReposEnableLfsForRepoOptions) (GitHubV3RESTAPIClientReposEnableLfsForRepoResponse, error) {
	req, err := client.reposEnableLfsForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposEnableLfsForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposEnableLfsForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusForbidden) {
		return GitHubV3RESTAPIClientReposEnableLfsForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposEnableLfsForRepoHandleResponse(resp)
}

// reposEnableLfsForRepoCreateRequest creates the ReposEnableLfsForRepo request.
func (client *GitHubV3RESTAPIClient) reposEnableLfsForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposEnableLfsForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/lfs"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposEnableLfsForRepoHandleResponse handles the ReposEnableLfsForRepo response.
func (client *GitHubV3RESTAPIClient) reposEnableLfsForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposEnableLfsForRepoResponse, error) {
	result := GitHubV3RESTAPIClientReposEnableLfsForRepoResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return GitHubV3RESTAPIClientReposEnableLfsForRepoResponse{}, err
	}
	return result, nil
}

// ReposEnableVulnerabilityAlerts - Enables dependency alerts and the dependency graph for a repository. The authenticated
// user must have admin access to the repository. For more information, see "About security alerts for vulnerable
// dependencies [https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies]".
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposEnableVulnerabilityAlertsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposEnableVulnerabilityAlerts
//     method.
func (client *GitHubV3RESTAPIClient) ReposEnableVulnerabilityAlerts(ctx context.Context, options *GitHubV3RESTAPIClientReposEnableVulnerabilityAlertsOptions) (GitHubV3RESTAPIClientReposEnableVulnerabilityAlertsResponse, error) {
	req, err := client.reposEnableVulnerabilityAlertsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposEnableVulnerabilityAlertsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposEnableVulnerabilityAlertsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposEnableVulnerabilityAlertsResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposEnableVulnerabilityAlertsResponse{}, nil
}

// reposEnableVulnerabilityAlertsCreateRequest creates the ReposEnableVulnerabilityAlerts request.
func (client *GitHubV3RESTAPIClient) reposEnableVulnerabilityAlertsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposEnableVulnerabilityAlertsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/vulnerability-alerts"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReposGenerateReleaseNotes - Generate a name and body describing a release [https://docs.github.com/rest/reference/repos#releases].
// The body content will be markdown formatted and contain information like the changes since last
// release and users who contributed. The generated release notes are not saved anywhere. They are intended to be generated
// and used when creating a new release.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGenerateReleaseNotesOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGenerateReleaseNotes
//     method.
func (client *GitHubV3RESTAPIClient) ReposGenerateReleaseNotes(ctx context.Context, body Paths1WqvvxaReposOwnerRepoReleasesGenerateNotesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposGenerateReleaseNotesOptions) (GitHubV3RESTAPIClientReposGenerateReleaseNotesResponse, error) {
	req, err := client.reposGenerateReleaseNotesCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGenerateReleaseNotesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGenerateReleaseNotesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGenerateReleaseNotesResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGenerateReleaseNotesHandleResponse(resp)
}

// reposGenerateReleaseNotesCreateRequest creates the ReposGenerateReleaseNotes request.
func (client *GitHubV3RESTAPIClient) reposGenerateReleaseNotesCreateRequest(ctx context.Context, body Paths1WqvvxaReposOwnerRepoReleasesGenerateNotesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposGenerateReleaseNotesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/releases/generate-notes"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposGenerateReleaseNotesHandleResponse handles the ReposGenerateReleaseNotes response.
func (client *GitHubV3RESTAPIClient) reposGenerateReleaseNotesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGenerateReleaseNotesResponse, error) {
	result := GitHubV3RESTAPIClientReposGenerateReleaseNotesResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ReleaseNotesContent
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGenerateReleaseNotesResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGenerateReleaseNotesResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGenerateReleaseNotesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGet - The parent and source objects are present when the repository is a fork. parent is the repository this repository
// was forked from, source is the ultimate source for the network.
// Note: In order to see the securityandanalysis block for a repository you must have admin permissions for the repository
// or be an owner or security manager for the organization that owns the
// repository. For more information, see "Managing security managers in your organization
// [https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGet
//     method.
func (client *GitHubV3RESTAPIClient) ReposGet(ctx context.Context, options *GitHubV3RESTAPIClientReposGetOptions) (GitHubV3RESTAPIClientReposGetResponse, error) {
	req, err := client.reposGetCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetHandleResponse(resp)
}

// reposGetCreateRequest creates the ReposGet request.
func (client *GitHubV3RESTAPIClient) reposGetCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetHandleResponse handles the ReposGet response.
func (client *GitHubV3RESTAPIClient) reposGetHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetResponse, error) {
	result := GitHubV3RESTAPIClientReposGetResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val FullRepository
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetAccessRestrictions - Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Lists who has access to this protected branch.
// Note: Users, apps, and teams restrictions are only available for organization-owned repositories.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetAccessRestrictionsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetAccessRestrictions
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetAccessRestrictions(ctx context.Context, options *GitHubV3RESTAPIClientReposGetAccessRestrictionsOptions) (GitHubV3RESTAPIClientReposGetAccessRestrictionsResponse, error) {
	req, err := client.reposGetAccessRestrictionsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetAccessRestrictionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetAccessRestrictionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetAccessRestrictionsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetAccessRestrictionsHandleResponse(resp)
}

// reposGetAccessRestrictionsCreateRequest creates the ReposGetAccessRestrictions request.
func (client *GitHubV3RESTAPIClient) reposGetAccessRestrictionsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetAccessRestrictionsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetAccessRestrictionsHandleResponse handles the ReposGetAccessRestrictions response.
func (client *GitHubV3RESTAPIClient) reposGetAccessRestrictionsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetAccessRestrictionsResponse, error) {
	result := GitHubV3RESTAPIClientReposGetAccessRestrictionsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val BranchRestrictionPolicy
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetAccessRestrictionsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetAccessRestrictionsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetAccessRestrictionsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetAdminBranchProtection - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetAdminBranchProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetAdminBranchProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetAdminBranchProtection(ctx context.Context, options *GitHubV3RESTAPIClientReposGetAdminBranchProtectionOptions) (GitHubV3RESTAPIClientReposGetAdminBranchProtectionResponse, error) {
	req, err := client.reposGetAdminBranchProtectionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetAdminBranchProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetAdminBranchProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposGetAdminBranchProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetAdminBranchProtectionHandleResponse(resp)
}

// reposGetAdminBranchProtectionCreateRequest creates the ReposGetAdminBranchProtection request.
func (client *GitHubV3RESTAPIClient) reposGetAdminBranchProtectionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetAdminBranchProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetAdminBranchProtectionHandleResponse handles the ReposGetAdminBranchProtection response.
func (client *GitHubV3RESTAPIClient) reposGetAdminBranchProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetAdminBranchProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposGetAdminBranchProtectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProtectedBranchAdminEnforced); err != nil {
		return GitHubV3RESTAPIClientReposGetAdminBranchProtectionResponse{}, err
	}
	return result, nil
}

// ReposGetAllEnvironments - Lists the environments for a repository.
// Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token
// with the repo scope. GitHub Apps must have the actions:read permission to
// use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetAllEnvironmentsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetAllEnvironments
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetAllEnvironments(ctx context.Context, options *GitHubV3RESTAPIClientReposGetAllEnvironmentsOptions) (GitHubV3RESTAPIClientReposGetAllEnvironmentsResponse, error) {
	req, err := client.reposGetAllEnvironmentsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetAllEnvironmentsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetAllEnvironmentsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposGetAllEnvironmentsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetAllEnvironmentsHandleResponse(resp)
}

// reposGetAllEnvironmentsCreateRequest creates the ReposGetAllEnvironments request.
func (client *GitHubV3RESTAPIClient) reposGetAllEnvironmentsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetAllEnvironmentsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/environments"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetAllEnvironmentsHandleResponse handles the ReposGetAllEnvironments response.
func (client *GitHubV3RESTAPIClient) reposGetAllEnvironmentsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetAllEnvironmentsResponse, error) {
	result := GitHubV3RESTAPIClientReposGetAllEnvironmentsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1I57UpnReposOwnerRepoEnvironmentsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientReposGetAllEnvironmentsResponse{}, err
	}
	return result, nil
}

// ReposGetAllStatusCheckContexts - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetAllStatusCheckContextsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetAllStatusCheckContexts
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetAllStatusCheckContexts(ctx context.Context, options *GitHubV3RESTAPIClientReposGetAllStatusCheckContextsOptions) (GitHubV3RESTAPIClientReposGetAllStatusCheckContextsResponse, error) {
	req, err := client.reposGetAllStatusCheckContextsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetAllStatusCheckContextsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetAllStatusCheckContextsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetAllStatusCheckContextsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetAllStatusCheckContextsHandleResponse(resp)
}

// reposGetAllStatusCheckContextsCreateRequest creates the ReposGetAllStatusCheckContexts request.
func (client *GitHubV3RESTAPIClient) reposGetAllStatusCheckContextsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetAllStatusCheckContextsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetAllStatusCheckContextsHandleResponse handles the ReposGetAllStatusCheckContexts response.
func (client *GitHubV3RESTAPIClient) reposGetAllStatusCheckContextsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetAllStatusCheckContextsResponse, error) {
	result := GitHubV3RESTAPIClientReposGetAllStatusCheckContextsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*string
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetAllStatusCheckContextsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetAllStatusCheckContextsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetAllStatusCheckContextsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetAllTopics - Get all repository topics
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetAllTopicsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetAllTopics
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetAllTopics(ctx context.Context, options *GitHubV3RESTAPIClientReposGetAllTopicsOptions) (GitHubV3RESTAPIClientReposGetAllTopicsResponse, error) {
	req, err := client.reposGetAllTopicsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetAllTopicsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetAllTopicsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetAllTopicsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetAllTopicsHandleResponse(resp)
}

// reposGetAllTopicsCreateRequest creates the ReposGetAllTopics request.
func (client *GitHubV3RESTAPIClient) reposGetAllTopicsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetAllTopicsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/topics"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetAllTopicsHandleResponse handles the ReposGetAllTopics response.
func (client *GitHubV3RESTAPIClient) reposGetAllTopicsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetAllTopicsResponse, error) {
	result := GitHubV3RESTAPIClientReposGetAllTopicsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Topic
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetAllTopicsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetAllTopicsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetAllTopicsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetAppsWithAccessToProtectedBranch - Protected branches are available in public repositories with GitHub Free and
// GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Lists the GitHub Apps that have push access to this branch. Only installed GitHub Apps with write access to the contents
// permission can be added as authorized actors on a protected branch.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetAppsWithAccessToProtectedBranchOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ReposGetAppsWithAccessToProtectedBranch method.
func (client *GitHubV3RESTAPIClient) ReposGetAppsWithAccessToProtectedBranch(ctx context.Context, options *GitHubV3RESTAPIClientReposGetAppsWithAccessToProtectedBranchOptions) (GitHubV3RESTAPIClientReposGetAppsWithAccessToProtectedBranchResponse, error) {
	req, err := client.reposGetAppsWithAccessToProtectedBranchCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetAppsWithAccessToProtectedBranchResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetAppsWithAccessToProtectedBranchResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetAppsWithAccessToProtectedBranchResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetAppsWithAccessToProtectedBranchHandleResponse(resp)
}

// reposGetAppsWithAccessToProtectedBranchCreateRequest creates the ReposGetAppsWithAccessToProtectedBranch request.
func (client *GitHubV3RESTAPIClient) reposGetAppsWithAccessToProtectedBranchCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetAppsWithAccessToProtectedBranchOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetAppsWithAccessToProtectedBranchHandleResponse handles the ReposGetAppsWithAccessToProtectedBranch response.
func (client *GitHubV3RESTAPIClient) reposGetAppsWithAccessToProtectedBranchHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetAppsWithAccessToProtectedBranchResponse, error) {
	result := GitHubV3RESTAPIClientReposGetAppsWithAccessToProtectedBranchResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Integration
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetAppsWithAccessToProtectedBranchResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetAppsWithAccessToProtectedBranchResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetAppsWithAccessToProtectedBranchResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetAutolink - This returns a single autolink reference by ID that was configured for the given repository.
// Information about autolinks are only available to repository administrators.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetAutolinkOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetAutolink
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetAutolink(ctx context.Context, options *GitHubV3RESTAPIClientReposGetAutolinkOptions) (GitHubV3RESTAPIClientReposGetAutolinkResponse, error) {
	req, err := client.reposGetAutolinkCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetAutolinkResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetAutolinkResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetAutolinkResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetAutolinkHandleResponse(resp)
}

// reposGetAutolinkCreateRequest creates the ReposGetAutolink request.
func (client *GitHubV3RESTAPIClient) reposGetAutolinkCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetAutolinkOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/autolinks/{autolink_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{autolink_id}", url.PathEscape(strconv.FormatInt(int64(client.autolinkID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetAutolinkHandleResponse handles the ReposGetAutolink response.
func (client *GitHubV3RESTAPIClient) reposGetAutolinkHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetAutolinkResponse, error) {
	result := GitHubV3RESTAPIClientReposGetAutolinkResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Autolink
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetAutolinkResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetAutolinkResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetAutolinkResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetBranch - Get a branch
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetBranchOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetBranch
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetBranch(ctx context.Context, options *GitHubV3RESTAPIClientReposGetBranchOptions) (GitHubV3RESTAPIClientReposGetBranchResponse, error) {
	req, err := client.reposGetBranchCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetBranchResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetBranchResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetBranchResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetBranchHandleResponse(resp)
}

// reposGetBranchCreateRequest creates the ReposGetBranch request.
func (client *GitHubV3RESTAPIClient) reposGetBranchCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetBranchOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetBranchHandleResponse handles the ReposGetBranch response.
func (client *GitHubV3RESTAPIClient) reposGetBranchHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetBranchResponse, error) {
	result := GitHubV3RESTAPIClientReposGetBranchResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val BranchWithProtection
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetBranchResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetBranchResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetBranchResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetBranchProtection - Protected branches are available in public repositories with GitHub Free and GitHub Free for
// organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetBranchProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetBranchProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetBranchProtection(ctx context.Context, options *GitHubV3RESTAPIClientReposGetBranchProtectionOptions) (GitHubV3RESTAPIClientReposGetBranchProtectionResponse, error) {
	req, err := client.reposGetBranchProtectionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetBranchProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetBranchProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetBranchProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetBranchProtectionHandleResponse(resp)
}

// reposGetBranchProtectionCreateRequest creates the ReposGetBranchProtection request.
func (client *GitHubV3RESTAPIClient) reposGetBranchProtectionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetBranchProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetBranchProtectionHandleResponse handles the ReposGetBranchProtection response.
func (client *GitHubV3RESTAPIClient) reposGetBranchProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetBranchProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposGetBranchProtectionResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val BranchProtection
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetBranchProtectionResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetBranchProtectionResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetBranchProtectionResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetClones - Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps are aligned
// to UTC midnight of the beginning of the day or week. Week begins on Monday.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetClonesOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetClones
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetClones(ctx context.Context, options *GitHubV3RESTAPIClientReposGetClonesOptions) (GitHubV3RESTAPIClientReposGetClonesResponse, error) {
	req, err := client.reposGetClonesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetClonesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetClonesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden) {
		return GitHubV3RESTAPIClientReposGetClonesResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetClonesHandleResponse(resp)
}

// reposGetClonesCreateRequest creates the ReposGetClones request.
func (client *GitHubV3RESTAPIClient) reposGetClonesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetClonesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/traffic/clones"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.per != nil {
		reqQP.Set("per", string(*client.per))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetClonesHandleResponse handles the ReposGetClones response.
func (client *GitHubV3RESTAPIClient) reposGetClonesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetClonesResponse, error) {
	result := GitHubV3RESTAPIClientReposGetClonesResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val CloneTraffic
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetClonesResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetClonesResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetClonesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetCodeFrequencyStats - Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetCodeFrequencyStatsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetCodeFrequencyStats
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetCodeFrequencyStats(ctx context.Context, options *GitHubV3RESTAPIClientReposGetCodeFrequencyStatsOptions) (GitHubV3RESTAPIClientReposGetCodeFrequencyStatsResponse, error) {
	req, err := client.reposGetCodeFrequencyStatsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetCodeFrequencyStatsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetCodeFrequencyStatsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposGetCodeFrequencyStatsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetCodeFrequencyStatsHandleResponse(resp)
}

// reposGetCodeFrequencyStatsCreateRequest creates the ReposGetCodeFrequencyStats request.
func (client *GitHubV3RESTAPIClient) reposGetCodeFrequencyStatsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetCodeFrequencyStatsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/stats/code_frequency"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetCodeFrequencyStatsHandleResponse handles the ReposGetCodeFrequencyStats response.
func (client *GitHubV3RESTAPIClient) reposGetCodeFrequencyStatsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetCodeFrequencyStatsResponse, error) {
	result := GitHubV3RESTAPIClientReposGetCodeFrequencyStatsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val [][]*int32
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCodeFrequencyStatsResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCodeFrequencyStatsResponse{}, err
	}
	result.Value = val
	case http.StatusNoContent:
	default:
		return GitHubV3RESTAPIClientReposGetCodeFrequencyStatsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetCollaboratorPermissionLevel - Checks the repository permission of a collaborator. The possible repository permissions
// are admin, write, read, and none.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetCollaboratorPermissionLevelOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetCollaboratorPermissionLevel
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetCollaboratorPermissionLevel(ctx context.Context, options *GitHubV3RESTAPIClientReposGetCollaboratorPermissionLevelOptions) (GitHubV3RESTAPIClientReposGetCollaboratorPermissionLevelResponse, error) {
	req, err := client.reposGetCollaboratorPermissionLevelCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetCollaboratorPermissionLevelResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetCollaboratorPermissionLevelResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetCollaboratorPermissionLevelResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetCollaboratorPermissionLevelHandleResponse(resp)
}

// reposGetCollaboratorPermissionLevelCreateRequest creates the ReposGetCollaboratorPermissionLevel request.
func (client *GitHubV3RESTAPIClient) reposGetCollaboratorPermissionLevelCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetCollaboratorPermissionLevelOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/collaborators/{username}/permission"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetCollaboratorPermissionLevelHandleResponse handles the ReposGetCollaboratorPermissionLevel response.
func (client *GitHubV3RESTAPIClient) reposGetCollaboratorPermissionLevelHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetCollaboratorPermissionLevelResponse, error) {
	result := GitHubV3RESTAPIClientReposGetCollaboratorPermissionLevelResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val RepositoryCollaboratorPermission
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCollaboratorPermissionLevelResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCollaboratorPermissionLevelResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetCollaboratorPermissionLevelResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetCombinedStatusForRef - Users with pull access in a repository can access a combined view of commit statuses for
// a given ref. The ref can be a SHA, a branch name, or a tag name.
// Additionally, a combined state is returned. The state is one of:
// * failure if any of the contexts report as error or failure
// * pending if there are no statuses or a context is pending
// * success if the latest status for all contexts is success
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - ref - ref parameter
//   - options - GitHubV3RESTAPIClientReposGetCombinedStatusForRefOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetCombinedStatusForRef
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetCombinedStatusForRef(ctx context.Context, ref string, options *GitHubV3RESTAPIClientReposGetCombinedStatusForRefOptions) (GitHubV3RESTAPIClientReposGetCombinedStatusForRefResponse, error) {
	req, err := client.reposGetCombinedStatusForRefCreateRequest(ctx, ref, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetCombinedStatusForRefResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetCombinedStatusForRefResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetCombinedStatusForRefResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetCombinedStatusForRefHandleResponse(resp)
}

// reposGetCombinedStatusForRefCreateRequest creates the ReposGetCombinedStatusForRef request.
func (client *GitHubV3RESTAPIClient) reposGetCombinedStatusForRefCreateRequest(ctx context.Context, ref string, options *GitHubV3RESTAPIClientReposGetCombinedStatusForRefOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/commits/{ref}/status"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if ref == "" {
		return nil, errors.New("parameter ref cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{ref}", url.PathEscape(ref))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetCombinedStatusForRefHandleResponse handles the ReposGetCombinedStatusForRef response.
func (client *GitHubV3RESTAPIClient) reposGetCombinedStatusForRefHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetCombinedStatusForRefResponse, error) {
	result := GitHubV3RESTAPIClientReposGetCombinedStatusForRefResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val CombinedCommitStatus
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCombinedStatusForRefResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCombinedStatusForRefResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetCombinedStatusForRefResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetCommit - Returns the contents of a single commit reference. You must have read access for the repository to use
// this endpoint.
// Note: If there are more than 300 files in the commit diff, the response will include pagination link headers for the remaining
// files, up to a limit of 3000 files. Each page contains the static commit
// information, and the only changes are to the file listing.
// You can pass the appropriate media type [https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests]
// to fetch diff and patch formats. Diffs with binary data will
// have no patch property.
// To return only the SHA-1 hash of the commit reference, you can provide the sha custom media type [https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests]
// in the
// Accept header. You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local reference's
// SHA-1 hash by providing the local SHA-1 reference as the ETag.
// Signature verification object
// The response will include a verification object that describes the result of verifying the commit's signature. The following
// fields are included in the verification object:
// NAME TYPE DESCRIPTION
// verified boolean Indicates whether GitHub considers the signature in this commit to be verified.
// reason string The reason for verified value. Possible values and their meanings are enumerated in table below.
// signature string The signature that was extracted from the commit.
// payload string The value that was signed.
// These are the possible values for reason in the verification object:
// VALUE DESCRIPTION
// expiredkey The key that made the signature is expired. notsigningkey The "signing" flag is not among the usage flags in
// the GPG key that made the signature. gpgverifyerror There was an error
// communicating with the signature verification service.
// gpgverifyunavailable The signature verification service is currently unavailable. unsigned The object does not include
// a signature. unknownsignaturetype A non-PGP signature was found in the commit. no
// user No user was associated with the committer email address in the commit.
// unverifiedemail The committer email address in the commit was associated with a user, but the email address is not verified
// on her/his account. bademail The committer email address in the commit is
// not included in the identities of the PGP key that made the signature.
// unknownkey The key that made the signature has not been registered with any user's account. malformedsignature There was
// an error parsing the signature.
// invalid The signature could not be cryptographically verified using the key whose key-id was found in the signature.
// valid None of the above errors applied, so the signature is considered to be verified.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - ref - ref parameter
//   - options - GitHubV3RESTAPIClientReposGetCommitOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetCommit
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetCommit(ctx context.Context, ref string, options *GitHubV3RESTAPIClientReposGetCommitOptions) (GitHubV3RESTAPIClientReposGetCommitResponse, error) {
	req, err := client.reposGetCommitCreateRequest(ctx, ref, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetCommitResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetCommitResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity, http.StatusInternalServerError, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientReposGetCommitResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetCommitHandleResponse(resp)
}

// reposGetCommitCreateRequest creates the ReposGetCommit request.
func (client *GitHubV3RESTAPIClient) reposGetCommitCreateRequest(ctx context.Context, ref string, options *GitHubV3RESTAPIClientReposGetCommitOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/commits/{ref}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if ref == "" {
		return nil, errors.New("parameter ref cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{ref}", url.PathEscape(ref))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetCommitHandleResponse handles the ReposGetCommit response.
func (client *GitHubV3RESTAPIClient) reposGetCommitHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetCommitResponse, error) {
	result := GitHubV3RESTAPIClientReposGetCommitResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Commit
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCommitResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCommitResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCommitResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCommitResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCommitResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetCommitResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetCommitActivityStats - Returns the last year of commit activity grouped by week. The days array is a group of commits
// per day, starting on Sunday.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetCommitActivityStatsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetCommitActivityStats
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetCommitActivityStats(ctx context.Context, options *GitHubV3RESTAPIClientReposGetCommitActivityStatsOptions) (GitHubV3RESTAPIClientReposGetCommitActivityStatsResponse, error) {
	req, err := client.reposGetCommitActivityStatsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetCommitActivityStatsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetCommitActivityStatsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposGetCommitActivityStatsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetCommitActivityStatsHandleResponse(resp)
}

// reposGetCommitActivityStatsCreateRequest creates the ReposGetCommitActivityStats request.
func (client *GitHubV3RESTAPIClient) reposGetCommitActivityStatsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetCommitActivityStatsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/stats/commit_activity"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetCommitActivityStatsHandleResponse handles the ReposGetCommitActivityStats response.
func (client *GitHubV3RESTAPIClient) reposGetCommitActivityStatsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetCommitActivityStatsResponse, error) {
	result := GitHubV3RESTAPIClientReposGetCommitActivityStatsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*CommitActivity
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCommitActivityStatsResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCommitActivityStatsResponse{}, err
	}
	result.Value = val
	case http.StatusNoContent:
	default:
		return GitHubV3RESTAPIClientReposGetCommitActivityStatsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetCommitComment - Get a commit comment
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetCommitCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetCommitComment
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetCommitComment(ctx context.Context, options *GitHubV3RESTAPIClientReposGetCommitCommentOptions) (GitHubV3RESTAPIClientReposGetCommitCommentResponse, error) {
	req, err := client.reposGetCommitCommentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetCommitCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetCommitCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetCommitCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetCommitCommentHandleResponse(resp)
}

// reposGetCommitCommentCreateRequest creates the ReposGetCommitComment request.
func (client *GitHubV3RESTAPIClient) reposGetCommitCommentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetCommitCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/comments/{comment_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetCommitCommentHandleResponse handles the ReposGetCommitComment response.
func (client *GitHubV3RESTAPIClient) reposGetCommitCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetCommitCommentResponse, error) {
	result := GitHubV3RESTAPIClientReposGetCommitCommentResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val CommitComment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCommitCommentResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCommitCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetCommitCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetCommitSignatureProtection - Protected branches are available in public repositories with GitHub Free and GitHub
// Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// When authenticated with admin or owner permissions to the repository, you can use this endpoint to check whether a branch
// requires signed commits. An enabled status of true indicates you must sign
// commits on this branch. For more information, see Signing commits with GPG [https://docs.github.com/articles/signing-commits-with-gpg]
// in GitHub Help.
// Note: You must enable branch protection to require signed commits.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetCommitSignatureProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetCommitSignatureProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetCommitSignatureProtection(ctx context.Context, options *GitHubV3RESTAPIClientReposGetCommitSignatureProtectionOptions) (GitHubV3RESTAPIClientReposGetCommitSignatureProtectionResponse, error) {
	req, err := client.reposGetCommitSignatureProtectionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetCommitSignatureProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetCommitSignatureProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetCommitSignatureProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetCommitSignatureProtectionHandleResponse(resp)
}

// reposGetCommitSignatureProtectionCreateRequest creates the ReposGetCommitSignatureProtection request.
func (client *GitHubV3RESTAPIClient) reposGetCommitSignatureProtectionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetCommitSignatureProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetCommitSignatureProtectionHandleResponse handles the ReposGetCommitSignatureProtection response.
func (client *GitHubV3RESTAPIClient) reposGetCommitSignatureProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetCommitSignatureProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposGetCommitSignatureProtectionResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProtectedBranchAdminEnforced
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCommitSignatureProtectionResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetCommitSignatureProtectionResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetCommitSignatureProtectionResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetCommunityProfileMetrics - Returns all community profile metrics for a repository. The repository cannot be a fork.
// The returned metrics include an overall health score, the repository description, the presence of documentation, the detected
// code of conduct, the detected license, and the presence of ISSUETEMPLATE,
// PULLREQUEST_TEMPLATE, README, and CONTRIBUTING files.
// The healthpercentage score is defined as a percentage of how many of these four documents are present: README, CONTRIBUTING,
// LICENSE, and CODEOFCONDUCT. For example, if all four documents are present,
// then the healthpercentage is 100. If only one is present, then thehealth_percentage is 25.
// contentreportsenabled is only returned for organization-owned repositories.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetCommunityProfileMetricsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetCommunityProfileMetrics
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetCommunityProfileMetrics(ctx context.Context, options *GitHubV3RESTAPIClientReposGetCommunityProfileMetricsOptions) (GitHubV3RESTAPIClientReposGetCommunityProfileMetricsResponse, error) {
	req, err := client.reposGetCommunityProfileMetricsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetCommunityProfileMetricsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetCommunityProfileMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposGetCommunityProfileMetricsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetCommunityProfileMetricsHandleResponse(resp)
}

// reposGetCommunityProfileMetricsCreateRequest creates the ReposGetCommunityProfileMetrics request.
func (client *GitHubV3RESTAPIClient) reposGetCommunityProfileMetricsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetCommunityProfileMetricsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/community/profile"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetCommunityProfileMetricsHandleResponse handles the ReposGetCommunityProfileMetrics response.
func (client *GitHubV3RESTAPIClient) reposGetCommunityProfileMetricsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetCommunityProfileMetricsResponse, error) {
	result := GitHubV3RESTAPIClientReposGetCommunityProfileMetricsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CommunityProfile); err != nil {
		return GitHubV3RESTAPIClientReposGetCommunityProfileMetricsResponse{}, err
	}
	return result, nil
}

// ReposGetContent - Gets the contents of a file or directory in a repository. Specify the file path or directory in :path.
// If you omit:path, you will receive the contents of the repository's root directory. See the
// description below regarding what the API response includes for directories.
// Files and symlinks support a custom media type [https://docs.github.com/rest/reference/repos#custom-media-types] for retrieving
// the raw content or rendered HTML (when supported). All content types
// support a custom media type [https://docs.github.com/rest/reference/repos#custom-media-types] to ensure the content is
// returned in a consistent object format.
// Notes:
// * To get a repository's contents recursively, you can recursively get the tree [https://docs.github.com/rest/reference/git#trees].
// * This API has an upper limit of 1,000 files for a directory. If you need to retrieve more files, use the Git Trees API
// [https://docs.github.com/rest/reference/git#get-a-tree].
// * Download URLs expire and are meant to be used just once. To ensure the download URL does not expire, please use the contents
// API to obtain a fresh download URL for each download.
// SIZE LIMITS If the requested file's size is:
// * 1 MB or smaller: All features of this endpoint are supported.
// * Between 1-100 MB: Only the raw or object custom media types [https://docs.github.com/rest/repos/contents#custom-media-types-for-repository-contents]
// are supported. Both will work as normal, except
// that when using the object media type, the content field will be an empty string and the encoding field will be "none".
// To get the contents of these larger files, use the raw media type.
// * Greater than 100 MB: This endpoint is not supported.
// IF THE CONTENT IS A DIRECTORY The response will be an array of objects, one object for each item in the directory. When
// listing the contents of a directory, submodules have their "type" specified as
// "file". Logically, the value should be "submodule". This behavior exists in API v3 for backwards compatibility purposes
// [https://git.io/v1YCW]. In the next major version of the API, the type will be
// returned as "submodule".
// IF THE CONTENT IS A SYMLINK If the requested :path points to a symlink, and the symlink's target is a normal file in the
// repository, then the API responds with the content of the file (in the format
// shown in the example. Otherwise, the API responds with an object describing the symlink itself.
// IF THE CONTENT IS A SUBMODULE The submodulegiturl identifies the location of the submodule repository, and the sha identifies
// a specific commit within the submodule repository. Git uses the given URL
// when cloning the submodule repository, and checks out the submodule at that specific commit.
// If the submodule repository is not hosted on github.com, the Git URLs (git_url and _links["git"]) and the github.com URLs
// (html_url and _links["html"]) will have null values.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - pathParam - path parameter
//   - options - GitHubV3RESTAPIClientReposGetContentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetContent
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetContent(ctx context.Context, pathParam string, options *GitHubV3RESTAPIClientReposGetContentOptions) (GitHubV3RESTAPIClientReposGetContentResponse, error) {
	req, err := client.reposGetContentCreateRequest(ctx, pathParam, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetContentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetContentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetContentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetContentHandleResponse(resp)
}

// reposGetContentCreateRequest creates the ReposGetContent request.
func (client *GitHubV3RESTAPIClient) reposGetContentCreateRequest(ctx context.Context, pathParam string, options *GitHubV3RESTAPIClientReposGetContentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/contents/{path}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if pathParam == "" {
		return nil, errors.New("parameter pathParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{path}", url.PathEscape(pathParam))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Ref != nil {
		reqQP.Set("ref", *options.Ref)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetContentHandleResponse handles the ReposGetContent response.
func (client *GitHubV3RESTAPIClient) reposGetContentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetContentResponse, error) {
	result := GitHubV3RESTAPIClientReposGetContentResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Paths3So6PhReposOwnerRepoContentsPathGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetContentResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetContentResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetContentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetContentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetContributorsStats - Returns the total number of commits authored by the contributor. In addition, the response
// includes a Weekly Hash (weeks array) with the following information:
// * w - Start of the week, given as a Unix timestamp [http://en.wikipedia.org/wiki/Unix_time].
// * a - Number of additions
// * d - Number of deletions
// * c - Number of commits
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetContributorsStatsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetContributorsStats
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetContributorsStats(ctx context.Context, options *GitHubV3RESTAPIClientReposGetContributorsStatsOptions) (GitHubV3RESTAPIClientReposGetContributorsStatsResponse, error) {
	req, err := client.reposGetContributorsStatsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetContributorsStatsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetContributorsStatsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposGetContributorsStatsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetContributorsStatsHandleResponse(resp)
}

// reposGetContributorsStatsCreateRequest creates the ReposGetContributorsStats request.
func (client *GitHubV3RESTAPIClient) reposGetContributorsStatsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetContributorsStatsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/stats/contributors"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetContributorsStatsHandleResponse handles the ReposGetContributorsStats response.
func (client *GitHubV3RESTAPIClient) reposGetContributorsStatsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetContributorsStatsResponse, error) {
	result := GitHubV3RESTAPIClientReposGetContributorsStatsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*ContributorActivity
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetContributorsStatsResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetContributorsStatsResponse{}, err
	}
	result.Value = val
	case http.StatusNoContent:
	default:
		return GitHubV3RESTAPIClientReposGetContributorsStatsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetDeployKey - Get a deploy key
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetDeployKeyOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetDeployKey
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetDeployKey(ctx context.Context, options *GitHubV3RESTAPIClientReposGetDeployKeyOptions) (GitHubV3RESTAPIClientReposGetDeployKeyResponse, error) {
	req, err := client.reposGetDeployKeyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetDeployKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetDeployKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetDeployKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetDeployKeyHandleResponse(resp)
}

// reposGetDeployKeyCreateRequest creates the ReposGetDeployKey request.
func (client *GitHubV3RESTAPIClient) reposGetDeployKeyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetDeployKeyOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/keys/{key_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{key_id}", url.PathEscape(strconv.FormatInt(int64(client.keyID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetDeployKeyHandleResponse handles the ReposGetDeployKey response.
func (client *GitHubV3RESTAPIClient) reposGetDeployKeyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetDeployKeyResponse, error) {
	result := GitHubV3RESTAPIClientReposGetDeployKeyResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val DeployKey
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetDeployKeyResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetDeployKeyResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetDeployKeyResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetDeployment - Get a deployment
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetDeploymentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetDeployment
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetDeployment(ctx context.Context, options *GitHubV3RESTAPIClientReposGetDeploymentOptions) (GitHubV3RESTAPIClientReposGetDeploymentResponse, error) {
	req, err := client.reposGetDeploymentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetDeploymentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetDeploymentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetDeploymentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetDeploymentHandleResponse(resp)
}

// reposGetDeploymentCreateRequest creates the ReposGetDeployment request.
func (client *GitHubV3RESTAPIClient) reposGetDeploymentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetDeploymentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/deployments/{deployment_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{deployment_id}", url.PathEscape(strconv.FormatInt(int64(client.deploymentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetDeploymentHandleResponse handles the ReposGetDeployment response.
func (client *GitHubV3RESTAPIClient) reposGetDeploymentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetDeploymentResponse, error) {
	result := GitHubV3RESTAPIClientReposGetDeploymentResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Deployment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetDeploymentResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetDeploymentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetDeploymentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetDeploymentBranchPolicy - Gets a deployment branch policy for an environment.
// Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token
// with the repo scope. GitHub Apps must have the actions:read permission to
// use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetDeploymentBranchPolicyOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetDeploymentBranchPolicy
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetDeploymentBranchPolicy(ctx context.Context, options *GitHubV3RESTAPIClientReposGetDeploymentBranchPolicyOptions) (GitHubV3RESTAPIClientReposGetDeploymentBranchPolicyResponse, error) {
	req, err := client.reposGetDeploymentBranchPolicyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetDeploymentBranchPolicyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetDeploymentBranchPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposGetDeploymentBranchPolicyResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetDeploymentBranchPolicyHandleResponse(resp)
}

// reposGetDeploymentBranchPolicyCreateRequest creates the ReposGetDeploymentBranchPolicy request.
func (client *GitHubV3RESTAPIClient) reposGetDeploymentBranchPolicyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetDeploymentBranchPolicyOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	urlPath = strings.ReplaceAll(urlPath, "{branch_policy_id}", url.PathEscape(strconv.FormatInt(int64(client.branchPolicyID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetDeploymentBranchPolicyHandleResponse handles the ReposGetDeploymentBranchPolicy response.
func (client *GitHubV3RESTAPIClient) reposGetDeploymentBranchPolicyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetDeploymentBranchPolicyResponse, error) {
	result := GitHubV3RESTAPIClientReposGetDeploymentBranchPolicyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentBranchPolicy); err != nil {
		return GitHubV3RESTAPIClientReposGetDeploymentBranchPolicyResponse{}, err
	}
	return result, nil
}

// ReposGetDeploymentStatus - Users with pull access can view a deployment status for a deployment:
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetDeploymentStatusOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetDeploymentStatus
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetDeploymentStatus(ctx context.Context, statusID int32, options *GitHubV3RESTAPIClientReposGetDeploymentStatusOptions) (GitHubV3RESTAPIClientReposGetDeploymentStatusResponse, error) {
	req, err := client.reposGetDeploymentStatusCreateRequest(ctx, statusID, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetDeploymentStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetDeploymentStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetDeploymentStatusResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetDeploymentStatusHandleResponse(resp)
}

// reposGetDeploymentStatusCreateRequest creates the ReposGetDeploymentStatus request.
func (client *GitHubV3RESTAPIClient) reposGetDeploymentStatusCreateRequest(ctx context.Context, statusID int32, options *GitHubV3RESTAPIClientReposGetDeploymentStatusOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{deployment_id}", url.PathEscape(strconv.FormatInt(int64(client.deploymentID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{status_id}", url.PathEscape(strconv.FormatInt(int64(statusID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetDeploymentStatusHandleResponse handles the ReposGetDeploymentStatus response.
func (client *GitHubV3RESTAPIClient) reposGetDeploymentStatusHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetDeploymentStatusResponse, error) {
	result := GitHubV3RESTAPIClientReposGetDeploymentStatusResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val DeploymentStatus
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetDeploymentStatusResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetDeploymentStatusResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetDeploymentStatusResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetEnvironment - Note: To get information about name patterns that branches must match in order to deploy to this
// environment, see "Get a deployment branch policy
// [/rest/deployments/branch-policies#get-a-deployment-branch-policy]."
// Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token
// with the repo scope. GitHub Apps must have the actions:read permission to
// use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetEnvironmentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetEnvironment
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetEnvironment(ctx context.Context, options *GitHubV3RESTAPIClientReposGetEnvironmentOptions) (GitHubV3RESTAPIClientReposGetEnvironmentResponse, error) {
	req, err := client.reposGetEnvironmentCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetEnvironmentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetEnvironmentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposGetEnvironmentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetEnvironmentHandleResponse(resp)
}

// reposGetEnvironmentCreateRequest creates the ReposGetEnvironment request.
func (client *GitHubV3RESTAPIClient) reposGetEnvironmentCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetEnvironmentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/environments/{environment_name}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetEnvironmentHandleResponse handles the ReposGetEnvironment response.
func (client *GitHubV3RESTAPIClient) reposGetEnvironmentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetEnvironmentResponse, error) {
	result := GitHubV3RESTAPIClientReposGetEnvironmentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Environment); err != nil {
		return GitHubV3RESTAPIClientReposGetEnvironmentResponse{}, err
	}
	return result, nil
}

// ReposGetLatestPagesBuild - Get latest Pages build
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetLatestPagesBuildOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetLatestPagesBuild
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetLatestPagesBuild(ctx context.Context, options *GitHubV3RESTAPIClientReposGetLatestPagesBuildOptions) (GitHubV3RESTAPIClientReposGetLatestPagesBuildResponse, error) {
	req, err := client.reposGetLatestPagesBuildCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetLatestPagesBuildResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetLatestPagesBuildResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposGetLatestPagesBuildResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetLatestPagesBuildHandleResponse(resp)
}

// reposGetLatestPagesBuildCreateRequest creates the ReposGetLatestPagesBuild request.
func (client *GitHubV3RESTAPIClient) reposGetLatestPagesBuildCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetLatestPagesBuildOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pages/builds/latest"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetLatestPagesBuildHandleResponse handles the ReposGetLatestPagesBuild response.
func (client *GitHubV3RESTAPIClient) reposGetLatestPagesBuildHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetLatestPagesBuildResponse, error) {
	result := GitHubV3RESTAPIClientReposGetLatestPagesBuildResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PageBuild); err != nil {
		return GitHubV3RESTAPIClientReposGetLatestPagesBuildResponse{}, err
	}
	return result, nil
}

// ReposGetLatestRelease - View the latest published full release for the repository.
// The latest release is the most recent non-prerelease, non-draft release, sorted by the createdat attribute. The createdat
// attribute is the date of the commit used for the release, and not the date
// when the release was drafted or published.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetLatestReleaseOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetLatestRelease
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetLatestRelease(ctx context.Context, options *GitHubV3RESTAPIClientReposGetLatestReleaseOptions) (GitHubV3RESTAPIClientReposGetLatestReleaseResponse, error) {
	req, err := client.reposGetLatestReleaseCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetLatestReleaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetLatestReleaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposGetLatestReleaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetLatestReleaseHandleResponse(resp)
}

// reposGetLatestReleaseCreateRequest creates the ReposGetLatestRelease request.
func (client *GitHubV3RESTAPIClient) reposGetLatestReleaseCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetLatestReleaseOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/releases/latest"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetLatestReleaseHandleResponse handles the ReposGetLatestRelease response.
func (client *GitHubV3RESTAPIClient) reposGetLatestReleaseHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetLatestReleaseResponse, error) {
	result := GitHubV3RESTAPIClientReposGetLatestReleaseResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Release); err != nil {
		return GitHubV3RESTAPIClientReposGetLatestReleaseResponse{}, err
	}
	return result, nil
}

// ReposGetPages - Get a GitHub Pages site
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetPagesOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetPages
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetPages(ctx context.Context, options *GitHubV3RESTAPIClientReposGetPagesOptions) (GitHubV3RESTAPIClientReposGetPagesResponse, error) {
	req, err := client.reposGetPagesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetPagesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetPagesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetPagesResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetPagesHandleResponse(resp)
}

// reposGetPagesCreateRequest creates the ReposGetPages request.
func (client *GitHubV3RESTAPIClient) reposGetPagesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetPagesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pages"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetPagesHandleResponse handles the ReposGetPages response.
func (client *GitHubV3RESTAPIClient) reposGetPagesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetPagesResponse, error) {
	result := GitHubV3RESTAPIClientReposGetPagesResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Page
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetPagesResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetPagesResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetPagesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetPagesBuild - Get GitHub Pages build
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetPagesBuildOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetPagesBuild
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetPagesBuild(ctx context.Context, buildID int32, options *GitHubV3RESTAPIClientReposGetPagesBuildOptions) (GitHubV3RESTAPIClientReposGetPagesBuildResponse, error) {
	req, err := client.reposGetPagesBuildCreateRequest(ctx, buildID, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetPagesBuildResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetPagesBuildResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposGetPagesBuildResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetPagesBuildHandleResponse(resp)
}

// reposGetPagesBuildCreateRequest creates the ReposGetPagesBuild request.
func (client *GitHubV3RESTAPIClient) reposGetPagesBuildCreateRequest(ctx context.Context, buildID int32, options *GitHubV3RESTAPIClientReposGetPagesBuildOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pages/builds/{build_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{build_id}", url.PathEscape(strconv.FormatInt(int64(buildID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetPagesBuildHandleResponse handles the ReposGetPagesBuild response.
func (client *GitHubV3RESTAPIClient) reposGetPagesBuildHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetPagesBuildResponse, error) {
	result := GitHubV3RESTAPIClientReposGetPagesBuildResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PageBuild); err != nil {
		return GitHubV3RESTAPIClientReposGetPagesBuildResponse{}, err
	}
	return result, nil
}

// ReposGetPagesHealthCheck - Gets a health check of the DNS settings for the CNAME record configured for a repository's GitHub
// Pages.
// The first request to this endpoint returns a 202 Accepted status and starts an asynchronous background task to get the
// results for the domain. After the background task completes, subsequent requests
// to this endpoint return a 200 OK status with the health check results in the response.
// To use this endpoint, you must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.
// A token with the repo scope or Pages write permission is required.
// GitHub Apps must have the administrative:write and pages:write permissions.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetPagesHealthCheckOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetPagesHealthCheck
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetPagesHealthCheck(ctx context.Context, options *GitHubV3RESTAPIClientReposGetPagesHealthCheckOptions) (GitHubV3RESTAPIClientReposGetPagesHealthCheckResponse, error) {
	req, err := client.reposGetPagesHealthCheckCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetPagesHealthCheckResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetPagesHealthCheckResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposGetPagesHealthCheckResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetPagesHealthCheckHandleResponse(resp)
}

// reposGetPagesHealthCheckCreateRequest creates the ReposGetPagesHealthCheck request.
func (client *GitHubV3RESTAPIClient) reposGetPagesHealthCheckCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetPagesHealthCheckOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pages/health"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetPagesHealthCheckHandleResponse handles the ReposGetPagesHealthCheck response.
func (client *GitHubV3RESTAPIClient) reposGetPagesHealthCheckHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetPagesHealthCheckResponse, error) {
	result := GitHubV3RESTAPIClientReposGetPagesHealthCheckResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PagesHealthCheck
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetPagesHealthCheckResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetPagesHealthCheckResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetPagesHealthCheckResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	default:
		return GitHubV3RESTAPIClientReposGetPagesHealthCheckResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetParticipationStats - Returns the total commit counts for the owner and total commit counts in all. all is everyone
// combined, including the owner in the last 52 weeks. If you'd like to get the commit counts for non-owners,
// you can subtract owner from all.
// The array order is oldest week (index 0) to most recent week.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetParticipationStatsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetParticipationStats
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetParticipationStats(ctx context.Context, options *GitHubV3RESTAPIClientReposGetParticipationStatsOptions) (GitHubV3RESTAPIClientReposGetParticipationStatsResponse, error) {
	req, err := client.reposGetParticipationStatsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetParticipationStatsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetParticipationStatsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetParticipationStatsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetParticipationStatsHandleResponse(resp)
}

// reposGetParticipationStatsCreateRequest creates the ReposGetParticipationStats request.
func (client *GitHubV3RESTAPIClient) reposGetParticipationStatsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetParticipationStatsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/stats/participation"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetParticipationStatsHandleResponse handles the ReposGetParticipationStats response.
func (client *GitHubV3RESTAPIClient) reposGetParticipationStatsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetParticipationStatsResponse, error) {
	result := GitHubV3RESTAPIClientReposGetParticipationStatsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ParticipationStats
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetParticipationStatsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetParticipationStatsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetParticipationStatsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetPullRequestReviewProtection - Protected branches are available in public repositories with GitHub Free and GitHub
// Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetPullRequestReviewProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetPullRequestReviewProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetPullRequestReviewProtection(ctx context.Context, options *GitHubV3RESTAPIClientReposGetPullRequestReviewProtectionOptions) (GitHubV3RESTAPIClientReposGetPullRequestReviewProtectionResponse, error) {
	req, err := client.reposGetPullRequestReviewProtectionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetPullRequestReviewProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetPullRequestReviewProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposGetPullRequestReviewProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetPullRequestReviewProtectionHandleResponse(resp)
}

// reposGetPullRequestReviewProtectionCreateRequest creates the ReposGetPullRequestReviewProtection request.
func (client *GitHubV3RESTAPIClient) reposGetPullRequestReviewProtectionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetPullRequestReviewProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetPullRequestReviewProtectionHandleResponse handles the ReposGetPullRequestReviewProtection response.
func (client *GitHubV3RESTAPIClient) reposGetPullRequestReviewProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetPullRequestReviewProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposGetPullRequestReviewProtectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProtectedBranchPullRequestReview); err != nil {
		return GitHubV3RESTAPIClientReposGetPullRequestReviewProtectionResponse{}, err
	}
	return result, nil
}

// ReposGetPunchCardStats - Each array contains the day number, hour number, and number of commits:
// * 0-6: Sunday - Saturday
// * 0-23: Hour of day
// * Number of commits
// For example, [2, 14, 25] indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are
// based on the time zone of individual commits.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetPunchCardStatsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetPunchCardStats
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetPunchCardStats(ctx context.Context, options *GitHubV3RESTAPIClientReposGetPunchCardStatsOptions) (GitHubV3RESTAPIClientReposGetPunchCardStatsResponse, error) {
	req, err := client.reposGetPunchCardStatsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetPunchCardStatsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetPunchCardStatsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposGetPunchCardStatsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetPunchCardStatsHandleResponse(resp)
}

// reposGetPunchCardStatsCreateRequest creates the ReposGetPunchCardStats request.
func (client *GitHubV3RESTAPIClient) reposGetPunchCardStatsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetPunchCardStatsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/stats/punch_card"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetPunchCardStatsHandleResponse handles the ReposGetPunchCardStats response.
func (client *GitHubV3RESTAPIClient) reposGetPunchCardStatsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetPunchCardStatsResponse, error) {
	result := GitHubV3RESTAPIClientReposGetPunchCardStatsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Int32ArrayArray); err != nil {
		return GitHubV3RESTAPIClientReposGetPunchCardStatsResponse{}, err
	}
	return result, nil
}

// ReposGetReadme - Gets the preferred README for a repository.
// READMEs support custom media types [https://docs.github.com/rest/reference/repos#custom-media-types] for retrieving the
// raw content or rendered HTML.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetReadmeOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetReadme
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetReadme(ctx context.Context, options *GitHubV3RESTAPIClientReposGetReadmeOptions) (GitHubV3RESTAPIClientReposGetReadmeResponse, error) {
	req, err := client.reposGetReadmeCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetReadmeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetReadmeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposGetReadmeResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetReadmeHandleResponse(resp)
}

// reposGetReadmeCreateRequest creates the ReposGetReadme request.
func (client *GitHubV3RESTAPIClient) reposGetReadmeCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetReadmeOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/readme"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Ref != nil {
		reqQP.Set("ref", *options.Ref)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetReadmeHandleResponse handles the ReposGetReadme response.
func (client *GitHubV3RESTAPIClient) reposGetReadmeHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetReadmeResponse, error) {
	result := GitHubV3RESTAPIClientReposGetReadmeResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ContentFile
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetReadmeResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetReadmeResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetReadmeResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetReadmeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetReadmeInDirectory - Gets the README from a repository directory.
// READMEs support custom media types [https://docs.github.com/rest/reference/repos#custom-media-types] for retrieving the
// raw content or rendered HTML.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - dir - The alternate path to look for a README file
//   - options - GitHubV3RESTAPIClientReposGetReadmeInDirectoryOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetReadmeInDirectory
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetReadmeInDirectory(ctx context.Context, dir string, options *GitHubV3RESTAPIClientReposGetReadmeInDirectoryOptions) (GitHubV3RESTAPIClientReposGetReadmeInDirectoryResponse, error) {
	req, err := client.reposGetReadmeInDirectoryCreateRequest(ctx, dir, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetReadmeInDirectoryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetReadmeInDirectoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposGetReadmeInDirectoryResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetReadmeInDirectoryHandleResponse(resp)
}

// reposGetReadmeInDirectoryCreateRequest creates the ReposGetReadmeInDirectory request.
func (client *GitHubV3RESTAPIClient) reposGetReadmeInDirectoryCreateRequest(ctx context.Context, dir string, options *GitHubV3RESTAPIClientReposGetReadmeInDirectoryOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/readme/{dir}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if dir == "" {
		return nil, errors.New("parameter dir cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{dir}", url.PathEscape(dir))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Ref != nil {
		reqQP.Set("ref", *options.Ref)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetReadmeInDirectoryHandleResponse handles the ReposGetReadmeInDirectory response.
func (client *GitHubV3RESTAPIClient) reposGetReadmeInDirectoryHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetReadmeInDirectoryResponse, error) {
	result := GitHubV3RESTAPIClientReposGetReadmeInDirectoryResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ContentFile
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetReadmeInDirectoryResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetReadmeInDirectoryResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetReadmeInDirectoryResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetReadmeInDirectoryResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetRelease - Note: This returns an upload_url key corresponding to the endpoint for uploading release assets. This
// key is a hypermedia resource
// [https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetReleaseOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetRelease
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetRelease(ctx context.Context, options *GitHubV3RESTAPIClientReposGetReleaseOptions) (GitHubV3RESTAPIClientReposGetReleaseResponse, error) {
	req, err := client.reposGetReleaseCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetReleaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetReleaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetReleaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetReleaseHandleResponse(resp)
}

// reposGetReleaseCreateRequest creates the ReposGetRelease request.
func (client *GitHubV3RESTAPIClient) reposGetReleaseCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetReleaseOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/releases/{release_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{release_id}", url.PathEscape(strconv.FormatInt(int64(client.releaseID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetReleaseHandleResponse handles the ReposGetRelease response.
func (client *GitHubV3RESTAPIClient) reposGetReleaseHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetReleaseResponse, error) {
	result := GitHubV3RESTAPIClientReposGetReleaseResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Release
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetReleaseResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetReleaseResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetReleaseResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetReleaseAsset - To download the asset's binary content, set the Accept header of the request to application/octet-stream
// [https://docs.github.com/rest/overview/media-types]. The API will either redirect the client to
// the location, or stream it directly if possible. API clients should handle both a 200 or 302 response.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetReleaseAssetOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetReleaseAsset
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetReleaseAsset(ctx context.Context, options *GitHubV3RESTAPIClientReposGetReleaseAssetOptions) (GitHubV3RESTAPIClientReposGetReleaseAssetResponse, error) {
	req, err := client.reposGetReleaseAssetCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetReleaseAssetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetReleaseAssetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetReleaseAssetResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetReleaseAssetHandleResponse(resp)
}

// reposGetReleaseAssetCreateRequest creates the ReposGetReleaseAsset request.
func (client *GitHubV3RESTAPIClient) reposGetReleaseAssetCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetReleaseAssetOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/releases/assets/{asset_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{asset_id}", url.PathEscape(strconv.FormatInt(int64(client.assetID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetReleaseAssetHandleResponse handles the ReposGetReleaseAsset response.
func (client *GitHubV3RESTAPIClient) reposGetReleaseAssetHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetReleaseAssetResponse, error) {
	result := GitHubV3RESTAPIClientReposGetReleaseAssetResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ReleaseAsset
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetReleaseAssetResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetReleaseAssetResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetReleaseAssetResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetReleaseByTag - Get a published release with the specified tag.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - tag - tag parameter
//   - options - GitHubV3RESTAPIClientReposGetReleaseByTagOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetReleaseByTag
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetReleaseByTag(ctx context.Context, tag string, options *GitHubV3RESTAPIClientReposGetReleaseByTagOptions) (GitHubV3RESTAPIClientReposGetReleaseByTagResponse, error) {
	req, err := client.reposGetReleaseByTagCreateRequest(ctx, tag, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetReleaseByTagResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetReleaseByTagResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetReleaseByTagResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetReleaseByTagHandleResponse(resp)
}

// reposGetReleaseByTagCreateRequest creates the ReposGetReleaseByTag request.
func (client *GitHubV3RESTAPIClient) reposGetReleaseByTagCreateRequest(ctx context.Context, tag string, options *GitHubV3RESTAPIClientReposGetReleaseByTagOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/releases/tags/{tag}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if tag == "" {
		return nil, errors.New("parameter tag cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{tag}", url.PathEscape(tag))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetReleaseByTagHandleResponse handles the ReposGetReleaseByTag response.
func (client *GitHubV3RESTAPIClient) reposGetReleaseByTagHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetReleaseByTagResponse, error) {
	result := GitHubV3RESTAPIClientReposGetReleaseByTagResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Release
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetReleaseByTagResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetReleaseByTagResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetReleaseByTagResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetStatusChecksProtection - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetStatusChecksProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetStatusChecksProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetStatusChecksProtection(ctx context.Context, options *GitHubV3RESTAPIClientReposGetStatusChecksProtectionOptions) (GitHubV3RESTAPIClientReposGetStatusChecksProtectionResponse, error) {
	req, err := client.reposGetStatusChecksProtectionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetStatusChecksProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetStatusChecksProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetStatusChecksProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetStatusChecksProtectionHandleResponse(resp)
}

// reposGetStatusChecksProtectionCreateRequest creates the ReposGetStatusChecksProtection request.
func (client *GitHubV3RESTAPIClient) reposGetStatusChecksProtectionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetStatusChecksProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetStatusChecksProtectionHandleResponse handles the ReposGetStatusChecksProtection response.
func (client *GitHubV3RESTAPIClient) reposGetStatusChecksProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetStatusChecksProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposGetStatusChecksProtectionResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val StatusCheckPolicy
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetStatusChecksProtectionResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetStatusChecksProtectionResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetStatusChecksProtectionResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetTeamsWithAccessToProtectedBranch - Protected branches are available in public repositories with GitHub Free and
// GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Lists the teams who have push access to this branch. The list includes child teams.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetTeamsWithAccessToProtectedBranchOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ReposGetTeamsWithAccessToProtectedBranch method.
func (client *GitHubV3RESTAPIClient) ReposGetTeamsWithAccessToProtectedBranch(ctx context.Context, options *GitHubV3RESTAPIClientReposGetTeamsWithAccessToProtectedBranchOptions) (GitHubV3RESTAPIClientReposGetTeamsWithAccessToProtectedBranchResponse, error) {
	req, err := client.reposGetTeamsWithAccessToProtectedBranchCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetTeamsWithAccessToProtectedBranchResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetTeamsWithAccessToProtectedBranchResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetTeamsWithAccessToProtectedBranchResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetTeamsWithAccessToProtectedBranchHandleResponse(resp)
}

// reposGetTeamsWithAccessToProtectedBranchCreateRequest creates the ReposGetTeamsWithAccessToProtectedBranch request.
func (client *GitHubV3RESTAPIClient) reposGetTeamsWithAccessToProtectedBranchCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetTeamsWithAccessToProtectedBranchOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetTeamsWithAccessToProtectedBranchHandleResponse handles the ReposGetTeamsWithAccessToProtectedBranch response.
func (client *GitHubV3RESTAPIClient) reposGetTeamsWithAccessToProtectedBranchHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetTeamsWithAccessToProtectedBranchResponse, error) {
	result := GitHubV3RESTAPIClientReposGetTeamsWithAccessToProtectedBranchResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Team
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetTeamsWithAccessToProtectedBranchResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetTeamsWithAccessToProtectedBranchResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetTeamsWithAccessToProtectedBranchResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetTopPaths - Get the top 10 popular contents over the last 14 days.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetTopPathsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetTopPaths
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetTopPaths(ctx context.Context, options *GitHubV3RESTAPIClientReposGetTopPathsOptions) (GitHubV3RESTAPIClientReposGetTopPathsResponse, error) {
	req, err := client.reposGetTopPathsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetTopPathsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetTopPathsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden) {
		return GitHubV3RESTAPIClientReposGetTopPathsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetTopPathsHandleResponse(resp)
}

// reposGetTopPathsCreateRequest creates the ReposGetTopPaths request.
func (client *GitHubV3RESTAPIClient) reposGetTopPathsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetTopPathsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/traffic/popular/paths"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetTopPathsHandleResponse handles the ReposGetTopPaths response.
func (client *GitHubV3RESTAPIClient) reposGetTopPathsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetTopPathsResponse, error) {
	result := GitHubV3RESTAPIClientReposGetTopPathsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*ContentTraffic
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetTopPathsResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetTopPathsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetTopPathsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetTopReferrers - Get the top 10 referrers over the last 14 days.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetTopReferrersOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetTopReferrers
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetTopReferrers(ctx context.Context, options *GitHubV3RESTAPIClientReposGetTopReferrersOptions) (GitHubV3RESTAPIClientReposGetTopReferrersResponse, error) {
	req, err := client.reposGetTopReferrersCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetTopReferrersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetTopReferrersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden) {
		return GitHubV3RESTAPIClientReposGetTopReferrersResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetTopReferrersHandleResponse(resp)
}

// reposGetTopReferrersCreateRequest creates the ReposGetTopReferrers request.
func (client *GitHubV3RESTAPIClient) reposGetTopReferrersCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetTopReferrersOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/traffic/popular/referrers"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetTopReferrersHandleResponse handles the ReposGetTopReferrers response.
func (client *GitHubV3RESTAPIClient) reposGetTopReferrersHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetTopReferrersResponse, error) {
	result := GitHubV3RESTAPIClientReposGetTopReferrersResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*ReferrerTraffic
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetTopReferrersResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetTopReferrersResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetTopReferrersResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetUsersWithAccessToProtectedBranch - Protected branches are available in public repositories with GitHub Free and
// GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Lists the people who have push access to this branch.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetUsersWithAccessToProtectedBranchOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ReposGetUsersWithAccessToProtectedBranch method.
func (client *GitHubV3RESTAPIClient) ReposGetUsersWithAccessToProtectedBranch(ctx context.Context, options *GitHubV3RESTAPIClientReposGetUsersWithAccessToProtectedBranchOptions) (GitHubV3RESTAPIClientReposGetUsersWithAccessToProtectedBranchResponse, error) {
	req, err := client.reposGetUsersWithAccessToProtectedBranchCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetUsersWithAccessToProtectedBranchResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetUsersWithAccessToProtectedBranchResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetUsersWithAccessToProtectedBranchResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetUsersWithAccessToProtectedBranchHandleResponse(resp)
}

// reposGetUsersWithAccessToProtectedBranchCreateRequest creates the ReposGetUsersWithAccessToProtectedBranch request.
func (client *GitHubV3RESTAPIClient) reposGetUsersWithAccessToProtectedBranchCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetUsersWithAccessToProtectedBranchOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetUsersWithAccessToProtectedBranchHandleResponse handles the ReposGetUsersWithAccessToProtectedBranch response.
func (client *GitHubV3RESTAPIClient) reposGetUsersWithAccessToProtectedBranchHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetUsersWithAccessToProtectedBranchResponse, error) {
	result := GitHubV3RESTAPIClientReposGetUsersWithAccessToProtectedBranchResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*SimpleUser
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetUsersWithAccessToProtectedBranchResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetUsersWithAccessToProtectedBranchResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetUsersWithAccessToProtectedBranchResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetViews - Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are aligned
// to UTC midnight of the beginning of the day or week. Week begins on Monday.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetViewsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetViews
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetViews(ctx context.Context, options *GitHubV3RESTAPIClientReposGetViewsOptions) (GitHubV3RESTAPIClientReposGetViewsResponse, error) {
	req, err := client.reposGetViewsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetViewsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetViewsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden) {
		return GitHubV3RESTAPIClientReposGetViewsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetViewsHandleResponse(resp)
}

// reposGetViewsCreateRequest creates the ReposGetViews request.
func (client *GitHubV3RESTAPIClient) reposGetViewsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetViewsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/traffic/views"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.per != nil {
		reqQP.Set("per", string(*client.per))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetViewsHandleResponse handles the ReposGetViews response.
func (client *GitHubV3RESTAPIClient) reposGetViewsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetViewsResponse, error) {
	result := GitHubV3RESTAPIClientReposGetViewsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ViewTraffic
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetViewsResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetViewsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetViewsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetWebhook - Returns a webhook configured in a repository. To get only the webhook config properties, see "Get a webhook
// configuration for a repository
// [/rest/reference/repos#get-a-webhook-configuration-for-a-repository]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetWebhookOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetWebhook
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetWebhook(ctx context.Context, options *GitHubV3RESTAPIClientReposGetWebhookOptions) (GitHubV3RESTAPIClientReposGetWebhookResponse, error) {
	req, err := client.reposGetWebhookCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetWebhookResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetWebhookResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposGetWebhookResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetWebhookHandleResponse(resp)
}

// reposGetWebhookCreateRequest creates the ReposGetWebhook request.
func (client *GitHubV3RESTAPIClient) reposGetWebhookCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetWebhookOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/hooks/{hook_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetWebhookHandleResponse handles the ReposGetWebhook response.
func (client *GitHubV3RESTAPIClient) reposGetWebhookHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetWebhookResponse, error) {
	result := GitHubV3RESTAPIClientReposGetWebhookResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Hook
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetWebhookResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetWebhookResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetWebhookResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposGetWebhookConfigForRepo - Returns the webhook configuration for a repository. To get more information about the webhook,
// including the active state and events, use "Get a repository webhook
// [/rest/reference/orgs#get-a-repository-webhook]."
// Access tokens must have the read:repohook or repo scope, and GitHub Apps must have the repositoryhooks:read permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetWebhookConfigForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetWebhookConfigForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetWebhookConfigForRepo(ctx context.Context, options *GitHubV3RESTAPIClientReposGetWebhookConfigForRepoOptions) (GitHubV3RESTAPIClientReposGetWebhookConfigForRepoResponse, error) {
	req, err := client.reposGetWebhookConfigForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetWebhookConfigForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetWebhookConfigForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposGetWebhookConfigForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetWebhookConfigForRepoHandleResponse(resp)
}

// reposGetWebhookConfigForRepoCreateRequest creates the ReposGetWebhookConfigForRepo request.
func (client *GitHubV3RESTAPIClient) reposGetWebhookConfigForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetWebhookConfigForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/hooks/{hook_id}/config"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposGetWebhookConfigForRepoHandleResponse handles the ReposGetWebhookConfigForRepo response.
func (client *GitHubV3RESTAPIClient) reposGetWebhookConfigForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetWebhookConfigForRepoResponse, error) {
	result := GitHubV3RESTAPIClientReposGetWebhookConfigForRepoResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebhookConfig); err != nil {
		return GitHubV3RESTAPIClientReposGetWebhookConfigForRepoResponse{}, err
	}
	return result, nil
}

// ReposGetWebhookDelivery - Returns a delivery for a webhook configured in a repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposGetWebhookDeliveryOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposGetWebhookDelivery
//     method.
func (client *GitHubV3RESTAPIClient) ReposGetWebhookDelivery(ctx context.Context, options *GitHubV3RESTAPIClientReposGetWebhookDeliveryOptions) (GitHubV3RESTAPIClientReposGetWebhookDeliveryResponse, error) {
	req, err := client.reposGetWebhookDeliveryCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetWebhookDeliveryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposGetWebhookDeliveryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposGetWebhookDeliveryResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposGetWebhookDeliveryHandleResponse(resp)
}

// reposGetWebhookDeliveryCreateRequest creates the ReposGetWebhookDelivery request.
func (client *GitHubV3RESTAPIClient) reposGetWebhookDeliveryCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposGetWebhookDeliveryOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{delivery_id}", url.PathEscape(strconv.FormatInt(int64(client.deliveryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// reposGetWebhookDeliveryHandleResponse handles the ReposGetWebhookDelivery response.
func (client *GitHubV3RESTAPIClient) reposGetWebhookDeliveryHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposGetWebhookDeliveryResponse, error) {
	result := GitHubV3RESTAPIClientReposGetWebhookDeliveryResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val HookDelivery
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetWebhookDeliveryResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetWebhookDeliveryResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposGetWebhookDeliveryResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposGetWebhookDeliveryResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposListAutolinks - This returns a list of autolinks configured for the given repository.
// Information about autolinks are only available to repository administrators.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListAutolinksOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListAutolinks
//     method.
func (client *GitHubV3RESTAPIClient) ReposListAutolinks(ctx context.Context, options *GitHubV3RESTAPIClientReposListAutolinksOptions) (GitHubV3RESTAPIClientReposListAutolinksResponse, error) {
	req, err := client.reposListAutolinksCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListAutolinksResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListAutolinksResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposListAutolinksResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListAutolinksHandleResponse(resp)
}

// reposListAutolinksCreateRequest creates the ReposListAutolinks request.
func (client *GitHubV3RESTAPIClient) reposListAutolinksCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListAutolinksOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/autolinks"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListAutolinksHandleResponse handles the ReposListAutolinks response.
func (client *GitHubV3RESTAPIClient) reposListAutolinksHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListAutolinksResponse, error) {
	result := GitHubV3RESTAPIClientReposListAutolinksResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AutolinkArray); err != nil {
		return GitHubV3RESTAPIClientReposListAutolinksResponse{}, err
	}
	return result, nil
}

// ReposListBranches - List branches
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListBranchesOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListBranches
//     method.
func (client *GitHubV3RESTAPIClient) ReposListBranches(ctx context.Context, options *GitHubV3RESTAPIClientReposListBranchesOptions) (GitHubV3RESTAPIClientReposListBranchesResponse, error) {
	req, err := client.reposListBranchesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListBranchesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListBranchesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposListBranchesResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListBranchesHandleResponse(resp)
}

// reposListBranchesCreateRequest creates the ReposListBranches request.
func (client *GitHubV3RESTAPIClient) reposListBranchesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListBranchesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Protected != nil {
		reqQP.Set("protected", strconv.FormatBool(*options.Protected))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListBranchesHandleResponse handles the ReposListBranches response.
func (client *GitHubV3RESTAPIClient) reposListBranchesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListBranchesResponse, error) {
	result := GitHubV3RESTAPIClientReposListBranchesResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*ShortBranch
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListBranchesResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListBranchesResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposListBranchesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposListBranchesForHeadCommit - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Returns all branches where the given commit SHA is the HEAD, or latest commit for the branch.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListBranchesForHeadCommitOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListBranchesForHeadCommit
//     method.
func (client *GitHubV3RESTAPIClient) ReposListBranchesForHeadCommit(ctx context.Context, options *GitHubV3RESTAPIClientReposListBranchesForHeadCommitOptions) (GitHubV3RESTAPIClientReposListBranchesForHeadCommitResponse, error) {
	req, err := client.reposListBranchesForHeadCommitCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListBranchesForHeadCommitResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListBranchesForHeadCommitResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposListBranchesForHeadCommitResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListBranchesForHeadCommitHandleResponse(resp)
}

// reposListBranchesForHeadCommitCreateRequest creates the ReposListBranchesForHeadCommit request.
func (client *GitHubV3RESTAPIClient) reposListBranchesForHeadCommitCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListBranchesForHeadCommitOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.commitSHA == "" {
		return nil, errors.New("parameter client.commitSHA cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{commit_sha}", url.PathEscape(client.commitSHA))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListBranchesForHeadCommitHandleResponse handles the ReposListBranchesForHeadCommit response.
func (client *GitHubV3RESTAPIClient) reposListBranchesForHeadCommitHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListBranchesForHeadCommitResponse, error) {
	result := GitHubV3RESTAPIClientReposListBranchesForHeadCommitResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*BranchShort
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListBranchesForHeadCommitResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListBranchesForHeadCommitResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposListBranchesForHeadCommitResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposListCollaborators - For organization-owned repositories, the list of collaborators includes outside collaborators,
// organization members that are direct collaborators, organization members with access through team
// memberships, organization members with access through default organization permissions, and organization owners. Organization
// members with write, maintain, or admin privileges on the
// organization-owned repository can use this endpoint.
// Team members will include the members of child teams.
// You must authenticate using an access token with the read:org and repo scopes with push access to use this endpoint. GitHub
// Apps must have the members organization permission and metadata repository
// permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListCollaboratorsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListCollaborators
//     method.
func (client *GitHubV3RESTAPIClient) ReposListCollaborators(ctx context.Context, options *GitHubV3RESTAPIClientReposListCollaboratorsOptions) (GitHubV3RESTAPIClientReposListCollaboratorsResponse, error) {
	req, err := client.reposListCollaboratorsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListCollaboratorsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListCollaboratorsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposListCollaboratorsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListCollaboratorsHandleResponse(resp)
}

// reposListCollaboratorsCreateRequest creates the ReposListCollaborators request.
func (client *GitHubV3RESTAPIClient) reposListCollaboratorsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListCollaboratorsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/collaborators"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Affiliation != nil {
		reqQP.Set("affiliation", string(*options.Affiliation))
	}
	if options != nil && options.Permission != nil {
		reqQP.Set("permission", string(*options.Permission))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListCollaboratorsHandleResponse handles the ReposListCollaborators response.
func (client *GitHubV3RESTAPIClient) reposListCollaboratorsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListCollaboratorsResponse, error) {
	result := GitHubV3RESTAPIClientReposListCollaboratorsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Collaborator
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListCollaboratorsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListCollaboratorsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposListCollaboratorsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposListCommentsForCommit - Use the :commit_sha to specify the commit that will have its comments listed.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListCommentsForCommitOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListCommentsForCommit
//     method.
func (client *GitHubV3RESTAPIClient) ReposListCommentsForCommit(ctx context.Context, options *GitHubV3RESTAPIClientReposListCommentsForCommitOptions) (GitHubV3RESTAPIClientReposListCommentsForCommitResponse, error) {
	req, err := client.reposListCommentsForCommitCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListCommentsForCommitResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListCommentsForCommitResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposListCommentsForCommitResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListCommentsForCommitHandleResponse(resp)
}

// reposListCommentsForCommitCreateRequest creates the ReposListCommentsForCommit request.
func (client *GitHubV3RESTAPIClient) reposListCommentsForCommitCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListCommentsForCommitOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/commits/{commit_sha}/comments"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.commitSHA == "" {
		return nil, errors.New("parameter client.commitSHA cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{commit_sha}", url.PathEscape(client.commitSHA))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListCommentsForCommitHandleResponse handles the ReposListCommentsForCommit response.
func (client *GitHubV3RESTAPIClient) reposListCommentsForCommitHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListCommentsForCommitResponse, error) {
	result := GitHubV3RESTAPIClientReposListCommentsForCommitResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.CommitCommentArray); err != nil {
		return GitHubV3RESTAPIClientReposListCommentsForCommitResponse{}, err
	}
	return result, nil
}

// ReposListCommitCommentsForRepo - Commit Comments use these custom media types [https://docs.github.com/rest/reference/repos#custom-media-types].
// You can read more about the use of media types in the API here
// [https://docs.github.com/rest/overview/media-types/].
// Comments are ordered by ascending ID.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListCommitCommentsForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListCommitCommentsForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ReposListCommitCommentsForRepo(ctx context.Context, options *GitHubV3RESTAPIClientReposListCommitCommentsForRepoOptions) (GitHubV3RESTAPIClientReposListCommitCommentsForRepoResponse, error) {
	req, err := client.reposListCommitCommentsForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListCommitCommentsForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListCommitCommentsForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposListCommitCommentsForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListCommitCommentsForRepoHandleResponse(resp)
}

// reposListCommitCommentsForRepoCreateRequest creates the ReposListCommitCommentsForRepo request.
func (client *GitHubV3RESTAPIClient) reposListCommitCommentsForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListCommitCommentsForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/comments"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListCommitCommentsForRepoHandleResponse handles the ReposListCommitCommentsForRepo response.
func (client *GitHubV3RESTAPIClient) reposListCommitCommentsForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListCommitCommentsForRepoResponse, error) {
	result := GitHubV3RESTAPIClientReposListCommitCommentsForRepoResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.CommitCommentArray); err != nil {
		return GitHubV3RESTAPIClientReposListCommitCommentsForRepoResponse{}, err
	}
	return result, nil
}

// ReposListCommitStatusesForRef - Users with pull access in a repository can view commit statuses for a given ref. The ref
// can be a SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first
// status in the list will be the latest one.
// This resource is also available via a legacy route: GET /repos/:owner/:repo/statuses/:ref.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - ref - ref parameter
//   - options - GitHubV3RESTAPIClientReposListCommitStatusesForRefOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListCommitStatusesForRef
//     method.
func (client *GitHubV3RESTAPIClient) ReposListCommitStatusesForRef(ctx context.Context, ref string, options *GitHubV3RESTAPIClientReposListCommitStatusesForRefOptions) (GitHubV3RESTAPIClientReposListCommitStatusesForRefResponse, error) {
	req, err := client.reposListCommitStatusesForRefCreateRequest(ctx, ref, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListCommitStatusesForRefResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListCommitStatusesForRefResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposListCommitStatusesForRefResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListCommitStatusesForRefHandleResponse(resp)
}

// reposListCommitStatusesForRefCreateRequest creates the ReposListCommitStatusesForRef request.
func (client *GitHubV3RESTAPIClient) reposListCommitStatusesForRefCreateRequest(ctx context.Context, ref string, options *GitHubV3RESTAPIClientReposListCommitStatusesForRefOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/commits/{ref}/statuses"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if ref == "" {
		return nil, errors.New("parameter ref cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{ref}", url.PathEscape(ref))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListCommitStatusesForRefHandleResponse handles the ReposListCommitStatusesForRef response.
func (client *GitHubV3RESTAPIClient) reposListCommitStatusesForRefHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListCommitStatusesForRefResponse, error) {
	result := GitHubV3RESTAPIClientReposListCommitStatusesForRefResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.StatusArray); err != nil {
		return GitHubV3RESTAPIClientReposListCommitStatusesForRefResponse{}, err
	}
	return result, nil
}

// ReposListCommits - Signature verification object
// The response will include a verification object that describes the result of verifying the commit's signature. The following
// fields are included in the verification object:
// NAME TYPE DESCRIPTION
// verified boolean Indicates whether GitHub considers the signature in this commit to be verified.
// reason string The reason for verified value. Possible values and their meanings are enumerated in table below.
// signature string The signature that was extracted from the commit.
// payload string The value that was signed.
// These are the possible values for reason in the verification object:
// VALUE DESCRIPTION
// expiredkey The key that made the signature is expired. notsigningkey The "signing" flag is not among the usage flags in
// the GPG key that made the signature. gpgverifyerror There was an error
// communicating with the signature verification service.
// gpgverifyunavailable The signature verification service is currently unavailable. unsigned The object does not include
// a signature. unknownsignaturetype A non-PGP signature was found in the commit. no
// user No user was associated with the committer email address in the commit.
// unverifiedemail The committer email address in the commit was associated with a user, but the email address is not verified
// on her/his account. bademail The committer email address in the commit is
// not included in the identities of the PGP key that made the signature.
// unknownkey The key that made the signature has not been registered with any user's account. malformedsignature There was
// an error parsing the signature.
// invalid The signature could not be cryptographically verified using the key whose key-id was found in the signature.
// valid None of the above errors applied, so the signature is considered to be verified.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListCommitsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListCommits
//     method.
func (client *GitHubV3RESTAPIClient) ReposListCommits(ctx context.Context, options *GitHubV3RESTAPIClientReposListCommitsOptions) (GitHubV3RESTAPIClientReposListCommitsResponse, error) {
	req, err := client.reposListCommitsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListCommitsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListCommitsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusNotFound, http.StatusConflict, http.StatusInternalServerError) {
		return GitHubV3RESTAPIClientReposListCommitsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListCommitsHandleResponse(resp)
}

// reposListCommitsCreateRequest creates the ReposListCommits request.
func (client *GitHubV3RESTAPIClient) reposListCommitsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListCommitsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/commits"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SHA != nil {
		reqQP.Set("sha", *options.SHA)
	}
	if options != nil && options.Path != nil {
		reqQP.Set("path", *options.Path)
	}
	if options != nil && options.Author != nil {
		reqQP.Set("author", *options.Author)
	}
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if options != nil && options.Until != nil {
		reqQP.Set("until", options.Until.Format(time.RFC3339Nano))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// reposListCommitsHandleResponse handles the ReposListCommits response.
func (client *GitHubV3RESTAPIClient) reposListCommitsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListCommitsResponse, error) {
	result := GitHubV3RESTAPIClientReposListCommitsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Commit
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListCommitsResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListCommitsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListCommitsResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListCommitsResponse{}, err
	}
	result.Value = val
	case http.StatusInternalServerError:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListCommitsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposListCommitsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposListContributors - Lists contributors to the specified repository and sorts them by the number of commits per contributor
// in descending order. This endpoint may return information that is a few hours old because the
// GitHub REST API caches contributor data to improve performance.
// GitHub identifies contributors by author email address. This endpoint groups contribution counts by GitHub user, which
// includes all associated email addresses. To improve performance, only the first
// 500 author email addresses in the repository link to GitHub users. The rest will appear as anonymous contributors without
// associated GitHub user information.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListContributorsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListContributors
//     method.
func (client *GitHubV3RESTAPIClient) ReposListContributors(ctx context.Context, options *GitHubV3RESTAPIClientReposListContributorsOptions) (GitHubV3RESTAPIClientReposListContributorsResponse, error) {
	req, err := client.reposListContributorsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListContributorsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListContributorsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposListContributorsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListContributorsHandleResponse(resp)
}

// reposListContributorsCreateRequest creates the ReposListContributors request.
func (client *GitHubV3RESTAPIClient) reposListContributorsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListContributorsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/contributors"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Anon != nil {
		reqQP.Set("anon", *options.Anon)
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListContributorsHandleResponse handles the ReposListContributors response.
func (client *GitHubV3RESTAPIClient) reposListContributorsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListContributorsResponse, error) {
	result := GitHubV3RESTAPIClientReposListContributorsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Contributor
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListContributorsResponse{}, err
	}
	result.Value = val
	case http.StatusNoContent:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListContributorsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListContributorsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposListContributorsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposListDeployKeys - List deploy keys
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListDeployKeysOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListDeployKeys
//     method.
func (client *GitHubV3RESTAPIClient) ReposListDeployKeys(ctx context.Context, options *GitHubV3RESTAPIClientReposListDeployKeysOptions) (GitHubV3RESTAPIClientReposListDeployKeysResponse, error) {
	req, err := client.reposListDeployKeysCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListDeployKeysResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListDeployKeysResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposListDeployKeysResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListDeployKeysHandleResponse(resp)
}

// reposListDeployKeysCreateRequest creates the ReposListDeployKeys request.
func (client *GitHubV3RESTAPIClient) reposListDeployKeysCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListDeployKeysOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/keys"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListDeployKeysHandleResponse handles the ReposListDeployKeys response.
func (client *GitHubV3RESTAPIClient) reposListDeployKeysHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListDeployKeysResponse, error) {
	result := GitHubV3RESTAPIClientReposListDeployKeysResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeployKeyArray); err != nil {
		return GitHubV3RESTAPIClientReposListDeployKeysResponse{}, err
	}
	return result, nil
}

// ReposListDeploymentBranchPolicies - Lists the deployment branch policies for an environment.
// Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token
// with the repo scope. GitHub Apps must have the actions:read permission to
// use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListDeploymentBranchPoliciesOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListDeploymentBranchPolicies
//     method.
func (client *GitHubV3RESTAPIClient) ReposListDeploymentBranchPolicies(ctx context.Context, options *GitHubV3RESTAPIClientReposListDeploymentBranchPoliciesOptions) (GitHubV3RESTAPIClientReposListDeploymentBranchPoliciesResponse, error) {
	req, err := client.reposListDeploymentBranchPoliciesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListDeploymentBranchPoliciesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListDeploymentBranchPoliciesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposListDeploymentBranchPoliciesResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListDeploymentBranchPoliciesHandleResponse(resp)
}

// reposListDeploymentBranchPoliciesCreateRequest creates the ReposListDeploymentBranchPolicies request.
func (client *GitHubV3RESTAPIClient) reposListDeploymentBranchPoliciesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListDeploymentBranchPoliciesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListDeploymentBranchPoliciesHandleResponse handles the ReposListDeploymentBranchPolicies response.
func (client *GitHubV3RESTAPIClient) reposListDeploymentBranchPoliciesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListDeploymentBranchPoliciesResponse, error) {
	result := GitHubV3RESTAPIClientReposListDeploymentBranchPoliciesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1HnxzhwReposOwnerRepoEnvironmentsEnvironmentNameDeploymentBranchPoliciesGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientReposListDeploymentBranchPoliciesResponse{}, err
	}
	return result, nil
}

// ReposListDeploymentStatuses - Users with pull access can view deployment statuses for a deployment:
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListDeploymentStatusesOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListDeploymentStatuses
//     method.
func (client *GitHubV3RESTAPIClient) ReposListDeploymentStatuses(ctx context.Context, options *GitHubV3RESTAPIClientReposListDeploymentStatusesOptions) (GitHubV3RESTAPIClientReposListDeploymentStatusesResponse, error) {
	req, err := client.reposListDeploymentStatusesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListDeploymentStatusesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListDeploymentStatusesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposListDeploymentStatusesResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListDeploymentStatusesHandleResponse(resp)
}

// reposListDeploymentStatusesCreateRequest creates the ReposListDeploymentStatuses request.
func (client *GitHubV3RESTAPIClient) reposListDeploymentStatusesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListDeploymentStatusesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{deployment_id}", url.PathEscape(strconv.FormatInt(int64(client.deploymentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListDeploymentStatusesHandleResponse handles the ReposListDeploymentStatuses response.
func (client *GitHubV3RESTAPIClient) reposListDeploymentStatusesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListDeploymentStatusesResponse, error) {
	result := GitHubV3RESTAPIClientReposListDeploymentStatusesResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*DeploymentStatus
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListDeploymentStatusesResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListDeploymentStatusesResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposListDeploymentStatusesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposListDeployments - Simple filtering of deployments is available via query parameters:
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListDeploymentsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListDeployments
//     method.
func (client *GitHubV3RESTAPIClient) ReposListDeployments(ctx context.Context, options *GitHubV3RESTAPIClientReposListDeploymentsOptions) (GitHubV3RESTAPIClientReposListDeploymentsResponse, error) {
	req, err := client.reposListDeploymentsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListDeploymentsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListDeploymentsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposListDeploymentsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListDeploymentsHandleResponse(resp)
}

// reposListDeploymentsCreateRequest creates the ReposListDeployments request.
func (client *GitHubV3RESTAPIClient) reposListDeploymentsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListDeploymentsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/deployments"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SHA != nil {
		reqQP.Set("sha", *options.SHA)
	}
	if options != nil && options.Ref != nil {
		reqQP.Set("ref", *options.Ref)
	}
	if options != nil && options.Task != nil {
		reqQP.Set("task", *options.Task)
	}
	if options != nil && options.Environment != nil {
		reqQP.Set("environment", *options.Environment)
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListDeploymentsHandleResponse handles the ReposListDeployments response.
func (client *GitHubV3RESTAPIClient) reposListDeploymentsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListDeploymentsResponse, error) {
	result := GitHubV3RESTAPIClientReposListDeploymentsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentArray); err != nil {
		return GitHubV3RESTAPIClientReposListDeploymentsResponse{}, err
	}
	return result, nil
}

// ReposListForAuthenticatedUser - Lists repositories that the authenticated user has explicit permission (:read, :write,
// or :admin) to access.
// The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator,
// and repositories that they can access through an organization membership.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) ReposListForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientReposListForAuthenticatedUserOptions) (GitHubV3RESTAPIClientReposListForAuthenticatedUserResponse, error) {
	req, err := client.reposListForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposListForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListForAuthenticatedUserHandleResponse(resp)
}

// reposListForAuthenticatedUserCreateRequest creates the ReposListForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) reposListForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/repos"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Visibility != nil {
		reqQP.Set("visibility", string(*options.Visibility))
	}
	if options != nil && options.Affiliation != nil {
		reqQP.Set("affiliation", *options.Affiliation)
	}
	if options != nil && options.Type != nil {
		reqQP.Set("type", string(*options.Type))
	}
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if options != nil && options.Direction != nil {
		reqQP.Set("direction", string(*options.Direction))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if client.before != nil {
		reqQP.Set("before", *client.before)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListForAuthenticatedUserHandleResponse handles the ReposListForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) reposListForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientReposListForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Repository
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposListForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposListForOrg - Lists repositories for the specified organization.
// Note: In order to see the securityandanalysis block for a repository you must have admin permissions for the repository
// or be an owner or security manager for the organization that owns the
// repository. For more information, see "Managing security managers in your organization
// [https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListForOrg
//     method.
func (client *GitHubV3RESTAPIClient) ReposListForOrg(ctx context.Context, options *GitHubV3RESTAPIClientReposListForOrgOptions) (GitHubV3RESTAPIClientReposListForOrgResponse, error) {
	req, err := client.reposListForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposListForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListForOrgHandleResponse(resp)
}

// reposListForOrgCreateRequest creates the ReposListForOrg request.
func (client *GitHubV3RESTAPIClient) reposListForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/repos"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Type != nil {
		reqQP.Set("type", string(*options.Type))
	}
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if options != nil && options.Direction != nil {
		reqQP.Set("direction", string(*options.Direction))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListForOrgHandleResponse handles the ReposListForOrg response.
func (client *GitHubV3RESTAPIClient) reposListForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListForOrgResponse, error) {
	result := GitHubV3RESTAPIClientReposListForOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.MinimalRepositoryArray); err != nil {
		return GitHubV3RESTAPIClientReposListForOrgResponse{}, err
	}
	return result, nil
}

// ReposListForUser - Lists public repositories for the specified user. Note: For GitHub AE, this endpoint will list internal
// repositories for the specified user.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListForUser
//     method.
func (client *GitHubV3RESTAPIClient) ReposListForUser(ctx context.Context, options *GitHubV3RESTAPIClientReposListForUserOptions) (GitHubV3RESTAPIClientReposListForUserResponse, error) {
	req, err := client.reposListForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposListForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListForUserHandleResponse(resp)
}

// reposListForUserCreateRequest creates the ReposListForUser request.
func (client *GitHubV3RESTAPIClient) reposListForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/repos"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Type != nil {
		reqQP.Set("type", string(*options.Type))
	}
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if options != nil && options.Direction != nil {
		reqQP.Set("direction", string(*options.Direction))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListForUserHandleResponse handles the ReposListForUser response.
func (client *GitHubV3RESTAPIClient) reposListForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListForUserResponse, error) {
	result := GitHubV3RESTAPIClientReposListForUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.MinimalRepositoryArray); err != nil {
		return GitHubV3RESTAPIClientReposListForUserResponse{}, err
	}
	return result, nil
}

// ReposListForks - List forks
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListForksOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListForks
//     method.
func (client *GitHubV3RESTAPIClient) ReposListForks(ctx context.Context, options *GitHubV3RESTAPIClientReposListForksOptions) (GitHubV3RESTAPIClientReposListForksResponse, error) {
	req, err := client.reposListForksCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListForksResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListForksResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest) {
		return GitHubV3RESTAPIClientReposListForksResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListForksHandleResponse(resp)
}

// reposListForksCreateRequest creates the ReposListForks request.
func (client *GitHubV3RESTAPIClient) reposListForksCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListForksOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/forks"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// reposListForksHandleResponse handles the ReposListForks response.
func (client *GitHubV3RESTAPIClient) reposListForksHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListForksResponse, error) {
	result := GitHubV3RESTAPIClientReposListForksResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*MinimalRepository
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListForksResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListForksResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposListForksResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposListInvitations - When authenticating as a user with admin rights to a repository, this endpoint will list all currently
// open repository invitations.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListInvitationsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListInvitations
//     method.
func (client *GitHubV3RESTAPIClient) ReposListInvitations(ctx context.Context, options *GitHubV3RESTAPIClientReposListInvitationsOptions) (GitHubV3RESTAPIClientReposListInvitationsResponse, error) {
	req, err := client.reposListInvitationsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListInvitationsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListInvitationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposListInvitationsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListInvitationsHandleResponse(resp)
}

// reposListInvitationsCreateRequest creates the ReposListInvitations request.
func (client *GitHubV3RESTAPIClient) reposListInvitationsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListInvitationsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/invitations"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListInvitationsHandleResponse handles the ReposListInvitations response.
func (client *GitHubV3RESTAPIClient) reposListInvitationsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListInvitationsResponse, error) {
	result := GitHubV3RESTAPIClientReposListInvitationsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.RepositoryInvitationArray); err != nil {
		return GitHubV3RESTAPIClientReposListInvitationsResponse{}, err
	}
	return result, nil
}

// ReposListInvitationsForAuthenticatedUser - When authenticating as a user, this endpoint will list all currently open repository
// invitations for that user.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListInvitationsForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ReposListInvitationsForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) ReposListInvitationsForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientReposListInvitationsForAuthenticatedUserOptions) (GitHubV3RESTAPIClientReposListInvitationsForAuthenticatedUserResponse, error) {
	req, err := client.reposListInvitationsForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListInvitationsForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListInvitationsForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposListInvitationsForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListInvitationsForAuthenticatedUserHandleResponse(resp)
}

// reposListInvitationsForAuthenticatedUserCreateRequest creates the ReposListInvitationsForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) reposListInvitationsForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListInvitationsForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/repository_invitations"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListInvitationsForAuthenticatedUserHandleResponse handles the ReposListInvitationsForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) reposListInvitationsForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListInvitationsForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientReposListInvitationsForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*RepositoryInvitation
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListInvitationsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListInvitationsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListInvitationsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListInvitationsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposListInvitationsForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposListLanguages - Lists languages for the specified repository. The value shown for each language is the number of bytes
// of code written in that language.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListLanguagesOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListLanguages
//     method.
func (client *GitHubV3RESTAPIClient) ReposListLanguages(ctx context.Context, options *GitHubV3RESTAPIClientReposListLanguagesOptions) (GitHubV3RESTAPIClientReposListLanguagesResponse, error) {
	req, err := client.reposListLanguagesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListLanguagesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListLanguagesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposListLanguagesResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListLanguagesHandleResponse(resp)
}

// reposListLanguagesCreateRequest creates the ReposListLanguages request.
func (client *GitHubV3RESTAPIClient) reposListLanguagesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListLanguagesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/languages"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListLanguagesHandleResponse handles the ReposListLanguages response.
func (client *GitHubV3RESTAPIClient) reposListLanguagesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListLanguagesResponse, error) {
	result := GitHubV3RESTAPIClientReposListLanguagesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return GitHubV3RESTAPIClientReposListLanguagesResponse{}, err
	}
	return result, nil
}

// ReposListPagesBuilds - List GitHub Pages builds
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListPagesBuildsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListPagesBuilds
//     method.
func (client *GitHubV3RESTAPIClient) ReposListPagesBuilds(ctx context.Context, options *GitHubV3RESTAPIClientReposListPagesBuildsOptions) (GitHubV3RESTAPIClientReposListPagesBuildsResponse, error) {
	req, err := client.reposListPagesBuildsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListPagesBuildsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListPagesBuildsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposListPagesBuildsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListPagesBuildsHandleResponse(resp)
}

// reposListPagesBuildsCreateRequest creates the ReposListPagesBuilds request.
func (client *GitHubV3RESTAPIClient) reposListPagesBuildsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListPagesBuildsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pages/builds"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListPagesBuildsHandleResponse handles the ReposListPagesBuilds response.
func (client *GitHubV3RESTAPIClient) reposListPagesBuildsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListPagesBuildsResponse, error) {
	result := GitHubV3RESTAPIClientReposListPagesBuildsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PageBuildArray); err != nil {
		return GitHubV3RESTAPIClientReposListPagesBuildsResponse{}, err
	}
	return result, nil
}

// ReposListPublic - Lists all public repositories in the order that they were created.
// Note:
// * For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise.
// * Pagination is powered exclusively by the since parameter. Use the Link header [https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header]
// to get the URL for the next page of
// repositories.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListPublicOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListPublic
//     method.
func (client *GitHubV3RESTAPIClient) ReposListPublic(ctx context.Context, options *GitHubV3RESTAPIClientReposListPublicOptions) (GitHubV3RESTAPIClientReposListPublicResponse, error) {
	req, err := client.reposListPublicCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListPublicResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListPublicResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposListPublicResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListPublicHandleResponse(resp)
}

// reposListPublicCreateRequest creates the ReposListPublic request.
func (client *GitHubV3RESTAPIClient) reposListPublicCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListPublicOptions) (*policy.Request, error) {
	urlPath := "/repositories"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListPublicHandleResponse handles the ReposListPublic response.
func (client *GitHubV3RESTAPIClient) reposListPublicHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListPublicResponse, error) {
	result := GitHubV3RESTAPIClientReposListPublicResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*MinimalRepository
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListPublicResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListPublicResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposListPublicResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposListPullRequestsAssociatedWithCommit - Lists the merged pull request that introduced the commit to the repository.
// If the commit is not present in the default branch, will only return open pull requests associated with the commit.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListPullRequestsAssociatedWithCommitOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.ReposListPullRequestsAssociatedWithCommit method.
func (client *GitHubV3RESTAPIClient) ReposListPullRequestsAssociatedWithCommit(ctx context.Context, options *GitHubV3RESTAPIClientReposListPullRequestsAssociatedWithCommitOptions) (GitHubV3RESTAPIClientReposListPullRequestsAssociatedWithCommitResponse, error) {
	req, err := client.reposListPullRequestsAssociatedWithCommitCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListPullRequestsAssociatedWithCommitResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListPullRequestsAssociatedWithCommitResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposListPullRequestsAssociatedWithCommitResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListPullRequestsAssociatedWithCommitHandleResponse(resp)
}

// reposListPullRequestsAssociatedWithCommitCreateRequest creates the ReposListPullRequestsAssociatedWithCommit request.
func (client *GitHubV3RESTAPIClient) reposListPullRequestsAssociatedWithCommitCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListPullRequestsAssociatedWithCommitOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/commits/{commit_sha}/pulls"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.commitSHA == "" {
		return nil, errors.New("parameter client.commitSHA cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{commit_sha}", url.PathEscape(client.commitSHA))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListPullRequestsAssociatedWithCommitHandleResponse handles the ReposListPullRequestsAssociatedWithCommit response.
func (client *GitHubV3RESTAPIClient) reposListPullRequestsAssociatedWithCommitHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListPullRequestsAssociatedWithCommitResponse, error) {
	result := GitHubV3RESTAPIClientReposListPullRequestsAssociatedWithCommitResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.PullRequestSimpleArray); err != nil {
		return GitHubV3RESTAPIClientReposListPullRequestsAssociatedWithCommitResponse{}, err
	}
	return result, nil
}

// ReposListReleaseAssets - List release assets
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListReleaseAssetsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListReleaseAssets
//     method.
func (client *GitHubV3RESTAPIClient) ReposListReleaseAssets(ctx context.Context, options *GitHubV3RESTAPIClientReposListReleaseAssetsOptions) (GitHubV3RESTAPIClientReposListReleaseAssetsResponse, error) {
	req, err := client.reposListReleaseAssetsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListReleaseAssetsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListReleaseAssetsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposListReleaseAssetsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListReleaseAssetsHandleResponse(resp)
}

// reposListReleaseAssetsCreateRequest creates the ReposListReleaseAssets request.
func (client *GitHubV3RESTAPIClient) reposListReleaseAssetsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListReleaseAssetsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/releases/{release_id}/assets"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{release_id}", url.PathEscape(strconv.FormatInt(int64(client.releaseID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListReleaseAssetsHandleResponse handles the ReposListReleaseAssets response.
func (client *GitHubV3RESTAPIClient) reposListReleaseAssetsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListReleaseAssetsResponse, error) {
	result := GitHubV3RESTAPIClientReposListReleaseAssetsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ReleaseAssetArray); err != nil {
		return GitHubV3RESTAPIClientReposListReleaseAssetsResponse{}, err
	}
	return result, nil
}

// ReposListReleases - This returns a list of releases, which does not include regular Git tags that have not been associated
// with a release. To get a list of Git tags, use the Repository Tags API
// [https://docs.github.com/rest/reference/repos#list-repository-tags].
// Information about published releases are available to everyone. Only users with push access will receive listings for draft
// releases.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListReleasesOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListReleases
//     method.
func (client *GitHubV3RESTAPIClient) ReposListReleases(ctx context.Context, options *GitHubV3RESTAPIClientReposListReleasesOptions) (GitHubV3RESTAPIClientReposListReleasesResponse, error) {
	req, err := client.reposListReleasesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListReleasesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListReleasesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposListReleasesResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListReleasesHandleResponse(resp)
}

// reposListReleasesCreateRequest creates the ReposListReleases request.
func (client *GitHubV3RESTAPIClient) reposListReleasesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListReleasesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/releases"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListReleasesHandleResponse handles the ReposListReleases response.
func (client *GitHubV3RESTAPIClient) reposListReleasesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListReleasesResponse, error) {
	result := GitHubV3RESTAPIClientReposListReleasesResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Release
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListReleasesResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListReleasesResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposListReleasesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposListTagProtection - This returns the tag protection states of a repository.
// This information is only available to repository administrators.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListTagProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListTagProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposListTagProtection(ctx context.Context, options *GitHubV3RESTAPIClientReposListTagProtectionOptions) (GitHubV3RESTAPIClientReposListTagProtectionResponse, error) {
	req, err := client.reposListTagProtectionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListTagProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListTagProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposListTagProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListTagProtectionHandleResponse(resp)
}

// reposListTagProtectionCreateRequest creates the ReposListTagProtection request.
func (client *GitHubV3RESTAPIClient) reposListTagProtectionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListTagProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/tags/protection"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListTagProtectionHandleResponse handles the ReposListTagProtection response.
func (client *GitHubV3RESTAPIClient) reposListTagProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListTagProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposListTagProtectionResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*TagProtection
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListTagProtectionResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListTagProtectionResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListTagProtectionResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposListTagProtectionResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposListTags - List repository tags
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListTagsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListTags
//     method.
func (client *GitHubV3RESTAPIClient) ReposListTags(ctx context.Context, options *GitHubV3RESTAPIClientReposListTagsOptions) (GitHubV3RESTAPIClientReposListTagsResponse, error) {
	req, err := client.reposListTagsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListTagsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListTagsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposListTagsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListTagsHandleResponse(resp)
}

// reposListTagsCreateRequest creates the ReposListTags request.
func (client *GitHubV3RESTAPIClient) reposListTagsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListTagsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/tags"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListTagsHandleResponse handles the ReposListTags response.
func (client *GitHubV3RESTAPIClient) reposListTagsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListTagsResponse, error) {
	result := GitHubV3RESTAPIClientReposListTagsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.TagArray); err != nil {
		return GitHubV3RESTAPIClientReposListTagsResponse{}, err
	}
	return result, nil
}

// ReposListTeams - List repository teams
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListTeamsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListTeams
//     method.
func (client *GitHubV3RESTAPIClient) ReposListTeams(ctx context.Context, options *GitHubV3RESTAPIClientReposListTeamsOptions) (GitHubV3RESTAPIClientReposListTeamsResponse, error) {
	req, err := client.reposListTeamsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListTeamsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListTeamsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposListTeamsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListTeamsHandleResponse(resp)
}

// reposListTeamsCreateRequest creates the ReposListTeams request.
func (client *GitHubV3RESTAPIClient) reposListTeamsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListTeamsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/teams"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListTeamsHandleResponse handles the ReposListTeams response.
func (client *GitHubV3RESTAPIClient) reposListTeamsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListTeamsResponse, error) {
	result := GitHubV3RESTAPIClientReposListTeamsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamArray); err != nil {
		return GitHubV3RESTAPIClientReposListTeamsResponse{}, err
	}
	return result, nil
}

// ReposListWebhookDeliveries - Returns a list of webhook deliveries for a webhook configured in a repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListWebhookDeliveriesOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListWebhookDeliveries
//     method.
func (client *GitHubV3RESTAPIClient) ReposListWebhookDeliveries(ctx context.Context, options *GitHubV3RESTAPIClientReposListWebhookDeliveriesOptions) (GitHubV3RESTAPIClientReposListWebhookDeliveriesResponse, error) {
	req, err := client.reposListWebhookDeliveriesCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListWebhookDeliveriesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListWebhookDeliveriesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposListWebhookDeliveriesResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListWebhookDeliveriesHandleResponse(resp)
}

// reposListWebhookDeliveriesCreateRequest creates the ReposListWebhookDeliveries request.
func (client *GitHubV3RESTAPIClient) reposListWebhookDeliveriesCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListWebhookDeliveriesOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.cursor != nil {
		reqQP.Set("cursor", *client.cursor)
	}
	if options != nil && options.Redelivery != nil {
		reqQP.Set("redelivery", strconv.FormatBool(*options.Redelivery))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// reposListWebhookDeliveriesHandleResponse handles the ReposListWebhookDeliveries response.
func (client *GitHubV3RESTAPIClient) reposListWebhookDeliveriesHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListWebhookDeliveriesResponse, error) {
	result := GitHubV3RESTAPIClientReposListWebhookDeliveriesResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*HookDeliveryItem
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListWebhookDeliveriesResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListWebhookDeliveriesResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListWebhookDeliveriesResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposListWebhookDeliveriesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposListWebhooks - Lists webhooks for a repository. last response may return null if there have not been any deliveries
// within 30 days.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposListWebhooksOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposListWebhooks
//     method.
func (client *GitHubV3RESTAPIClient) ReposListWebhooks(ctx context.Context, options *GitHubV3RESTAPIClientReposListWebhooksOptions) (GitHubV3RESTAPIClientReposListWebhooksResponse, error) {
	req, err := client.reposListWebhooksCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposListWebhooksResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposListWebhooksResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposListWebhooksResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposListWebhooksHandleResponse(resp)
}

// reposListWebhooksCreateRequest creates the ReposListWebhooks request.
func (client *GitHubV3RESTAPIClient) reposListWebhooksCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposListWebhooksOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/hooks"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposListWebhooksHandleResponse handles the ReposListWebhooks response.
func (client *GitHubV3RESTAPIClient) reposListWebhooksHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposListWebhooksResponse, error) {
	result := GitHubV3RESTAPIClientReposListWebhooksResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Hook
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListWebhooksResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposListWebhooksResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposListWebhooksResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposMerge - Merge a branch
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposMergeOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposMerge
//     method.
func (client *GitHubV3RESTAPIClient) ReposMerge(ctx context.Context, body PathsCjr1R2ReposOwnerRepoMergesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposMergeOptions) (GitHubV3RESTAPIClientReposMergeResponse, error) {
	req, err := client.reposMergeCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposMergeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposMergeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNoContent, http.StatusForbidden, http.StatusNotFound, http.StatusConflict, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposMergeResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposMergeHandleResponse(resp)
}

// reposMergeCreateRequest creates the ReposMerge request.
func (client *GitHubV3RESTAPIClient) reposMergeCreateRequest(ctx context.Context, body PathsCjr1R2ReposOwnerRepoMergesPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposMergeOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/merges"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposMergeHandleResponse handles the ReposMerge response.
func (client *GitHubV3RESTAPIClient) reposMergeHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposMergeResponse, error) {
	result := GitHubV3RESTAPIClientReposMergeResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Commit
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposMergeResponse{}, err
	}
	result.Value = val
	case http.StatusNoContent:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposMergeResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	case http.StatusConflict:
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposMergeResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposMergeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposMergeUpstream - Sync a branch of a forked repository to keep it up-to-date with the upstream repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposMergeUpstreamOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposMergeUpstream
//     method.
func (client *GitHubV3RESTAPIClient) ReposMergeUpstream(ctx context.Context, body Paths1Awl2R3ReposOwnerRepoMergeUpstreamPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposMergeUpstreamOptions) (GitHubV3RESTAPIClientReposMergeUpstreamResponse, error) {
	req, err := client.reposMergeUpstreamCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposMergeUpstreamResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposMergeUpstreamResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusConflict, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposMergeUpstreamResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposMergeUpstreamHandleResponse(resp)
}

// reposMergeUpstreamCreateRequest creates the ReposMergeUpstream request.
func (client *GitHubV3RESTAPIClient) reposMergeUpstreamCreateRequest(ctx context.Context, body Paths1Awl2R3ReposOwnerRepoMergeUpstreamPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposMergeUpstreamOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/merge-upstream"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposMergeUpstreamHandleResponse handles the ReposMergeUpstream response.
func (client *GitHubV3RESTAPIClient) reposMergeUpstreamHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposMergeUpstreamResponse, error) {
	result := GitHubV3RESTAPIClientReposMergeUpstreamResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MergedUpstream); err != nil {
		return GitHubV3RESTAPIClientReposMergeUpstreamResponse{}, err
	}
	return result, nil
}

// ReposPingWebhook - This will trigger a ping event [https://docs.github.com/webhooks/#ping-event] to be sent to the hook.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposPingWebhookOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposPingWebhook
//     method.
func (client *GitHubV3RESTAPIClient) ReposPingWebhook(ctx context.Context, options *GitHubV3RESTAPIClientReposPingWebhookOptions) (GitHubV3RESTAPIClientReposPingWebhookResponse, error) {
	req, err := client.reposPingWebhookCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposPingWebhookResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposPingWebhookResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposPingWebhookResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposPingWebhookHandleResponse(resp)
}

// reposPingWebhookCreateRequest creates the ReposPingWebhook request.
func (client *GitHubV3RESTAPIClient) reposPingWebhookCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposPingWebhookOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/hooks/{hook_id}/pings"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposPingWebhookHandleResponse handles the ReposPingWebhook response.
func (client *GitHubV3RESTAPIClient) reposPingWebhookHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposPingWebhookResponse, error) {
	result := GitHubV3RESTAPIClientReposPingWebhookResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientReposPingWebhookResponse{}, err
	}
	return result, nil
}

// ReposRedeliverWebhookDelivery - Redeliver a webhook delivery for a webhook configured in a repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposRedeliverWebhookDeliveryOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposRedeliverWebhookDelivery
//     method.
func (client *GitHubV3RESTAPIClient) ReposRedeliverWebhookDelivery(ctx context.Context, options *GitHubV3RESTAPIClientReposRedeliverWebhookDeliveryOptions) (GitHubV3RESTAPIClientReposRedeliverWebhookDeliveryResponse, error) {
	req, err := client.reposRedeliverWebhookDeliveryCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposRedeliverWebhookDeliveryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposRedeliverWebhookDeliveryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusBadRequest, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposRedeliverWebhookDeliveryResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposRedeliverWebhookDeliveryHandleResponse(resp)
}

// reposRedeliverWebhookDeliveryCreateRequest creates the ReposRedeliverWebhookDelivery request.
func (client *GitHubV3RESTAPIClient) reposRedeliverWebhookDeliveryCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposRedeliverWebhookDeliveryOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{delivery_id}", url.PathEscape(strconv.FormatInt(int64(client.deliveryID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, nil
}

// reposRedeliverWebhookDeliveryHandleResponse handles the ReposRedeliverWebhookDelivery response.
func (client *GitHubV3RESTAPIClient) reposRedeliverWebhookDeliveryHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposRedeliverWebhookDeliveryResponse, error) {
	result := GitHubV3RESTAPIClientReposRedeliverWebhookDeliveryResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val any
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposRedeliverWebhookDeliveryResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposRedeliverWebhookDeliveryResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposRedeliverWebhookDeliveryResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposRedeliverWebhookDeliveryResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposRemoveAppAccessRestrictions - Protected branches are available in public repositories with GitHub Free and GitHub
// Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Removes the ability of an app to push to this branch. Only installed GitHub Apps with write access to the contents permission
// can be added as authorized actors on a protected branch.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposRemoveAppAccessRestrictionsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposRemoveAppAccessRestrictions
//     method.
func (client *GitHubV3RESTAPIClient) ReposRemoveAppAccessRestrictions(ctx context.Context, options *GitHubV3RESTAPIClientReposRemoveAppAccessRestrictionsOptions) (GitHubV3RESTAPIClientReposRemoveAppAccessRestrictionsResponse, error) {
	req, err := client.reposRemoveAppAccessRestrictionsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposRemoveAppAccessRestrictionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposRemoveAppAccessRestrictionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposRemoveAppAccessRestrictionsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposRemoveAppAccessRestrictionsHandleResponse(resp)
}

// reposRemoveAppAccessRestrictionsCreateRequest creates the ReposRemoveAppAccessRestrictions request.
func (client *GitHubV3RESTAPIClient) reposRemoveAppAccessRestrictionsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposRemoveAppAccessRestrictionsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// reposRemoveAppAccessRestrictionsHandleResponse handles the ReposRemoveAppAccessRestrictions response.
func (client *GitHubV3RESTAPIClient) reposRemoveAppAccessRestrictionsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposRemoveAppAccessRestrictionsResponse, error) {
	result := GitHubV3RESTAPIClientReposRemoveAppAccessRestrictionsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Integration
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposRemoveAppAccessRestrictionsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposRemoveAppAccessRestrictionsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposRemoveAppAccessRestrictionsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposRemoveCollaborator - Remove a repository collaborator
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposRemoveCollaboratorOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposRemoveCollaborator
//     method.
func (client *GitHubV3RESTAPIClient) ReposRemoveCollaborator(ctx context.Context, options *GitHubV3RESTAPIClientReposRemoveCollaboratorOptions) (GitHubV3RESTAPIClientReposRemoveCollaboratorResponse, error) {
	req, err := client.reposRemoveCollaboratorCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposRemoveCollaboratorResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposRemoveCollaboratorResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposRemoveCollaboratorResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposRemoveCollaboratorResponse{}, nil
}

// reposRemoveCollaboratorCreateRequest creates the ReposRemoveCollaborator request.
func (client *GitHubV3RESTAPIClient) reposRemoveCollaboratorCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposRemoveCollaboratorOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/collaborators/{username}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReposRemoveStatusCheckContexts - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposRemoveStatusCheckContextsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposRemoveStatusCheckContexts
//     method.
func (client *GitHubV3RESTAPIClient) ReposRemoveStatusCheckContexts(ctx context.Context, options *GitHubV3RESTAPIClientReposRemoveStatusCheckContextsOptions) (GitHubV3RESTAPIClientReposRemoveStatusCheckContextsResponse, error) {
	req, err := client.reposRemoveStatusCheckContextsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposRemoveStatusCheckContextsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposRemoveStatusCheckContextsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposRemoveStatusCheckContextsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposRemoveStatusCheckContextsHandleResponse(resp)
}

// reposRemoveStatusCheckContextsCreateRequest creates the ReposRemoveStatusCheckContexts request.
func (client *GitHubV3RESTAPIClient) reposRemoveStatusCheckContextsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposRemoveStatusCheckContextsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// reposRemoveStatusCheckContextsHandleResponse handles the ReposRemoveStatusCheckContexts response.
func (client *GitHubV3RESTAPIClient) reposRemoveStatusCheckContextsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposRemoveStatusCheckContextsResponse, error) {
	result := GitHubV3RESTAPIClientReposRemoveStatusCheckContextsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*string
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposRemoveStatusCheckContextsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposRemoveStatusCheckContextsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposRemoveStatusCheckContextsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposRemoveStatusCheckContextsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposRemoveStatusCheckProtection - Protected branches are available in public repositories with GitHub Free and GitHub
// Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposRemoveStatusCheckProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposRemoveStatusCheckProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposRemoveStatusCheckProtection(ctx context.Context, options *GitHubV3RESTAPIClientReposRemoveStatusCheckProtectionOptions) (GitHubV3RESTAPIClientReposRemoveStatusCheckProtectionResponse, error) {
	req, err := client.reposRemoveStatusCheckProtectionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposRemoveStatusCheckProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposRemoveStatusCheckProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientReposRemoveStatusCheckProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientReposRemoveStatusCheckProtectionResponse{}, nil
}

// reposRemoveStatusCheckProtectionCreateRequest creates the ReposRemoveStatusCheckProtection request.
func (client *GitHubV3RESTAPIClient) reposRemoveStatusCheckProtectionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposRemoveStatusCheckProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// ReposRemoveTeamAccessRestrictions - Protected branches are available in public repositories with GitHub Free and GitHub
// Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Removes the ability of a team to push to this branch. You can also remove push access for child teams.
// TYPE DESCRIPTION
// array Teams that should no longer have push access. Use the team's slug. Note: The list of users, apps, and teams in total
// is limited to 100 items.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposRemoveTeamAccessRestrictionsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposRemoveTeamAccessRestrictions
//     method.
func (client *GitHubV3RESTAPIClient) ReposRemoveTeamAccessRestrictions(ctx context.Context, options *GitHubV3RESTAPIClientReposRemoveTeamAccessRestrictionsOptions) (GitHubV3RESTAPIClientReposRemoveTeamAccessRestrictionsResponse, error) {
	req, err := client.reposRemoveTeamAccessRestrictionsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposRemoveTeamAccessRestrictionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposRemoveTeamAccessRestrictionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposRemoveTeamAccessRestrictionsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposRemoveTeamAccessRestrictionsHandleResponse(resp)
}

// reposRemoveTeamAccessRestrictionsCreateRequest creates the ReposRemoveTeamAccessRestrictions request.
func (client *GitHubV3RESTAPIClient) reposRemoveTeamAccessRestrictionsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposRemoveTeamAccessRestrictionsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// reposRemoveTeamAccessRestrictionsHandleResponse handles the ReposRemoveTeamAccessRestrictions response.
func (client *GitHubV3RESTAPIClient) reposRemoveTeamAccessRestrictionsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposRemoveTeamAccessRestrictionsResponse, error) {
	result := GitHubV3RESTAPIClientReposRemoveTeamAccessRestrictionsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Team
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposRemoveTeamAccessRestrictionsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposRemoveTeamAccessRestrictionsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposRemoveTeamAccessRestrictionsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposRemoveUserAccessRestrictions - Protected branches are available in public repositories with GitHub Free and GitHub
// Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Removes the ability of a user to push to this branch.
// TYPE DESCRIPTION
// array Usernames of the people who should no longer have push access. Note: The list of users, apps, and teams in total
// is limited to 100 items.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposRemoveUserAccessRestrictionsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposRemoveUserAccessRestrictions
//     method.
func (client *GitHubV3RESTAPIClient) ReposRemoveUserAccessRestrictions(ctx context.Context, options *GitHubV3RESTAPIClientReposRemoveUserAccessRestrictionsOptions) (GitHubV3RESTAPIClientReposRemoveUserAccessRestrictionsResponse, error) {
	req, err := client.reposRemoveUserAccessRestrictionsCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposRemoveUserAccessRestrictionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposRemoveUserAccessRestrictionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposRemoveUserAccessRestrictionsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposRemoveUserAccessRestrictionsHandleResponse(resp)
}

// reposRemoveUserAccessRestrictionsCreateRequest creates the ReposRemoveUserAccessRestrictions request.
func (client *GitHubV3RESTAPIClient) reposRemoveUserAccessRestrictionsCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposRemoveUserAccessRestrictionsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// reposRemoveUserAccessRestrictionsHandleResponse handles the ReposRemoveUserAccessRestrictions response.
func (client *GitHubV3RESTAPIClient) reposRemoveUserAccessRestrictionsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposRemoveUserAccessRestrictionsResponse, error) {
	result := GitHubV3RESTAPIClientReposRemoveUserAccessRestrictionsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*SimpleUser
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposRemoveUserAccessRestrictionsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposRemoveUserAccessRestrictionsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposRemoveUserAccessRestrictionsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposRenameBranch - Renames a branch in a repository.
// Note: Although the API responds immediately, the branch rename process might take some extra time to complete in the background.
// You won't be able to push to the old branch name while the rename
// process is in progress. For more information, see "Renaming a branch [https://docs.github.com/github/administering-a-repository/renaming-a-branch]".
// The permissions required to use this endpoint depends on whether you are renaming the default branch.
// To rename a non-default branch:
// * Users must have push access.
// * GitHub Apps must have the contents:write repository permission.
// To rename the default branch:
// * Users must have admin or owner permissions.
// * GitHub Apps must have the administration:write repository permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposRenameBranchOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposRenameBranch
//     method.
func (client *GitHubV3RESTAPIClient) ReposRenameBranch(ctx context.Context, body Paths1M8E4H4ReposOwnerRepoBranchesBranchRenamePostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposRenameBranchOptions) (GitHubV3RESTAPIClientReposRenameBranchResponse, error) {
	req, err := client.reposRenameBranchCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposRenameBranchResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposRenameBranchResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposRenameBranchResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposRenameBranchHandleResponse(resp)
}

// reposRenameBranchCreateRequest creates the ReposRenameBranch request.
func (client *GitHubV3RESTAPIClient) reposRenameBranchCreateRequest(ctx context.Context, body Paths1M8E4H4ReposOwnerRepoBranchesBranchRenamePostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposRenameBranchOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/rename"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposRenameBranchHandleResponse handles the ReposRenameBranch response.
func (client *GitHubV3RESTAPIClient) reposRenameBranchHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposRenameBranchResponse, error) {
	result := GitHubV3RESTAPIClientReposRenameBranchResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val BranchWithProtection
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposRenameBranchResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposRenameBranchResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposRenameBranchResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposRenameBranchResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposRenameBranchResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposReplaceAllTopics - Replace all repository topics
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposReplaceAllTopicsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposReplaceAllTopics
//     method.
func (client *GitHubV3RESTAPIClient) ReposReplaceAllTopics(ctx context.Context, body Paths1V0OsxsReposOwnerRepoTopicsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposReplaceAllTopicsOptions) (GitHubV3RESTAPIClientReposReplaceAllTopicsResponse, error) {
	req, err := client.reposReplaceAllTopicsCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposReplaceAllTopicsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposReplaceAllTopicsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposReplaceAllTopicsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposReplaceAllTopicsHandleResponse(resp)
}

// reposReplaceAllTopicsCreateRequest creates the ReposReplaceAllTopics request.
func (client *GitHubV3RESTAPIClient) reposReplaceAllTopicsCreateRequest(ctx context.Context, body Paths1V0OsxsReposOwnerRepoTopicsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposReplaceAllTopicsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/topics"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposReplaceAllTopicsHandleResponse handles the ReposReplaceAllTopics response.
func (client *GitHubV3RESTAPIClient) reposReplaceAllTopicsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposReplaceAllTopicsResponse, error) {
	result := GitHubV3RESTAPIClientReposReplaceAllTopicsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Topic
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposReplaceAllTopicsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposReplaceAllTopicsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposReplaceAllTopicsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposReplaceAllTopicsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposRequestPagesBuild - You can request that your site be built from the latest revision on the default branch. This has
// the same effect as pushing a commit to your default branch, but does not require an additional commit.
// Manually triggering page builds can be helpful when diagnosing build warnings and failures.
// Build requests are limited to one concurrent build per repository and one concurrent build per requester. If you request
// a build while another is still in progress, the second request will be queued
// until the first completes.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposRequestPagesBuildOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposRequestPagesBuild
//     method.
func (client *GitHubV3RESTAPIClient) ReposRequestPagesBuild(ctx context.Context, options *GitHubV3RESTAPIClientReposRequestPagesBuildOptions) (GitHubV3RESTAPIClientReposRequestPagesBuildResponse, error) {
	req, err := client.reposRequestPagesBuildCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposRequestPagesBuildResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposRequestPagesBuildResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientReposRequestPagesBuildResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposRequestPagesBuildHandleResponse(resp)
}

// reposRequestPagesBuildCreateRequest creates the ReposRequestPagesBuild request.
func (client *GitHubV3RESTAPIClient) reposRequestPagesBuildCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposRequestPagesBuildOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pages/builds"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposRequestPagesBuildHandleResponse handles the ReposRequestPagesBuild response.
func (client *GitHubV3RESTAPIClient) reposRequestPagesBuildHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposRequestPagesBuildResponse, error) {
	result := GitHubV3RESTAPIClientReposRequestPagesBuildResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return GitHubV3RESTAPIClientReposRequestPagesBuildResponse{}, err
	}
	return result, nil
}

// ReposSetAdminBranchProtection - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Adding admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposSetAdminBranchProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposSetAdminBranchProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposSetAdminBranchProtection(ctx context.Context, options *GitHubV3RESTAPIClientReposSetAdminBranchProtectionOptions) (GitHubV3RESTAPIClientReposSetAdminBranchProtectionResponse, error) {
	req, err := client.reposSetAdminBranchProtectionCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposSetAdminBranchProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposSetAdminBranchProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposSetAdminBranchProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposSetAdminBranchProtectionHandleResponse(resp)
}

// reposSetAdminBranchProtectionCreateRequest creates the ReposSetAdminBranchProtection request.
func (client *GitHubV3RESTAPIClient) reposSetAdminBranchProtectionCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposSetAdminBranchProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposSetAdminBranchProtectionHandleResponse handles the ReposSetAdminBranchProtection response.
func (client *GitHubV3RESTAPIClient) reposSetAdminBranchProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposSetAdminBranchProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposSetAdminBranchProtectionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProtectedBranchAdminEnforced); err != nil {
		return GitHubV3RESTAPIClientReposSetAdminBranchProtectionResponse{}, err
	}
	return result, nil
}

// ReposSetAppAccessRestrictions - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Replaces the list of apps that have push access to this branch. This removes all apps that previously had push access and
// grants push access to the new list of apps. Only installed GitHub Apps with
// write access to the contents permission can be added as authorized actors on a protected branch.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposSetAppAccessRestrictionsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposSetAppAccessRestrictions
//     method.
func (client *GitHubV3RESTAPIClient) ReposSetAppAccessRestrictions(ctx context.Context, body Paths9SkxohReposOwnerRepoBranchesBranchProtectionRestrictionsAppsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposSetAppAccessRestrictionsOptions) (GitHubV3RESTAPIClientReposSetAppAccessRestrictionsResponse, error) {
	req, err := client.reposSetAppAccessRestrictionsCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposSetAppAccessRestrictionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposSetAppAccessRestrictionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposSetAppAccessRestrictionsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposSetAppAccessRestrictionsHandleResponse(resp)
}

// reposSetAppAccessRestrictionsCreateRequest creates the ReposSetAppAccessRestrictions request.
func (client *GitHubV3RESTAPIClient) reposSetAppAccessRestrictionsCreateRequest(ctx context.Context, body Paths9SkxohReposOwnerRepoBranchesBranchProtectionRestrictionsAppsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposSetAppAccessRestrictionsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposSetAppAccessRestrictionsHandleResponse handles the ReposSetAppAccessRestrictions response.
func (client *GitHubV3RESTAPIClient) reposSetAppAccessRestrictionsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposSetAppAccessRestrictionsResponse, error) {
	result := GitHubV3RESTAPIClientReposSetAppAccessRestrictionsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Integration
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposSetAppAccessRestrictionsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposSetAppAccessRestrictionsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposSetAppAccessRestrictionsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposSetStatusCheckContexts - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposSetStatusCheckContextsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposSetStatusCheckContexts
//     method.
func (client *GitHubV3RESTAPIClient) ReposSetStatusCheckContexts(ctx context.Context, body PathsDs1CRCReposOwnerRepoBranchesBranchProtectionRequiredStatusChecksContextsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposSetStatusCheckContextsOptions) (GitHubV3RESTAPIClientReposSetStatusCheckContextsResponse, error) {
	req, err := client.reposSetStatusCheckContextsCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposSetStatusCheckContextsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposSetStatusCheckContextsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposSetStatusCheckContextsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposSetStatusCheckContextsHandleResponse(resp)
}

// reposSetStatusCheckContextsCreateRequest creates the ReposSetStatusCheckContexts request.
func (client *GitHubV3RESTAPIClient) reposSetStatusCheckContextsCreateRequest(ctx context.Context, body PathsDs1CRCReposOwnerRepoBranchesBranchProtectionRequiredStatusChecksContextsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposSetStatusCheckContextsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposSetStatusCheckContextsHandleResponse handles the ReposSetStatusCheckContexts response.
func (client *GitHubV3RESTAPIClient) reposSetStatusCheckContextsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposSetStatusCheckContextsResponse, error) {
	result := GitHubV3RESTAPIClientReposSetStatusCheckContextsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*string
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposSetStatusCheckContextsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposSetStatusCheckContextsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposSetStatusCheckContextsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposSetStatusCheckContextsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposSetTeamAccessRestrictions - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Replaces the list of teams that have push access to this branch. This removes all teams that previously had push access
// and grants push access to the new list of teams. Team restrictions include child
// teams.
// TYPE DESCRIPTION
// array The teams that can have push access. Use the team's slug. Note: The list of users, apps, and teams in total is limited
// to 100 items.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposSetTeamAccessRestrictionsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposSetTeamAccessRestrictions
//     method.
func (client *GitHubV3RESTAPIClient) ReposSetTeamAccessRestrictions(ctx context.Context, body Paths1EdxjqnReposOwnerRepoBranchesBranchProtectionRestrictionsTeamsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposSetTeamAccessRestrictionsOptions) (GitHubV3RESTAPIClientReposSetTeamAccessRestrictionsResponse, error) {
	req, err := client.reposSetTeamAccessRestrictionsCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposSetTeamAccessRestrictionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposSetTeamAccessRestrictionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposSetTeamAccessRestrictionsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposSetTeamAccessRestrictionsHandleResponse(resp)
}

// reposSetTeamAccessRestrictionsCreateRequest creates the ReposSetTeamAccessRestrictions request.
func (client *GitHubV3RESTAPIClient) reposSetTeamAccessRestrictionsCreateRequest(ctx context.Context, body Paths1EdxjqnReposOwnerRepoBranchesBranchProtectionRestrictionsTeamsPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposSetTeamAccessRestrictionsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposSetTeamAccessRestrictionsHandleResponse handles the ReposSetTeamAccessRestrictions response.
func (client *GitHubV3RESTAPIClient) reposSetTeamAccessRestrictionsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposSetTeamAccessRestrictionsResponse, error) {
	result := GitHubV3RESTAPIClientReposSetTeamAccessRestrictionsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Team
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposSetTeamAccessRestrictionsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposSetTeamAccessRestrictionsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposSetTeamAccessRestrictionsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposSetUserAccessRestrictions - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Replaces the list of people that have push access to this branch. This removes all people that previously had push access
// and grants push access to the new list of people.
// TYPE DESCRIPTION
// array Usernames for people who can have push access. Note: The list of users, apps, and teams in total is limited to 100
// items.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposSetUserAccessRestrictionsOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposSetUserAccessRestrictions
//     method.
func (client *GitHubV3RESTAPIClient) ReposSetUserAccessRestrictions(ctx context.Context, body PathsQv63J8ReposOwnerRepoBranchesBranchProtectionRestrictionsUsersPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposSetUserAccessRestrictionsOptions) (GitHubV3RESTAPIClientReposSetUserAccessRestrictionsResponse, error) {
	req, err := client.reposSetUserAccessRestrictionsCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposSetUserAccessRestrictionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposSetUserAccessRestrictionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposSetUserAccessRestrictionsResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposSetUserAccessRestrictionsHandleResponse(resp)
}

// reposSetUserAccessRestrictionsCreateRequest creates the ReposSetUserAccessRestrictions request.
func (client *GitHubV3RESTAPIClient) reposSetUserAccessRestrictionsCreateRequest(ctx context.Context, body PathsQv63J8ReposOwnerRepoBranchesBranchProtectionRestrictionsUsersPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposSetUserAccessRestrictionsOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposSetUserAccessRestrictionsHandleResponse handles the ReposSetUserAccessRestrictions response.
func (client *GitHubV3RESTAPIClient) reposSetUserAccessRestrictionsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposSetUserAccessRestrictionsResponse, error) {
	result := GitHubV3RESTAPIClientReposSetUserAccessRestrictionsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*SimpleUser
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposSetUserAccessRestrictionsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposSetUserAccessRestrictionsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposSetUserAccessRestrictionsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposTestPushWebhook - This will trigger the hook with the latest push to the current repository if the hook is subscribed
// to push events. If the hook is not subscribed to push events, the server will respond with 204 but
// no test POST will be generated.
// Note: Previously /repos/:owner/:repo/hooks/:hook_id/test
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposTestPushWebhookOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposTestPushWebhook
//     method.
func (client *GitHubV3RESTAPIClient) ReposTestPushWebhook(ctx context.Context, options *GitHubV3RESTAPIClientReposTestPushWebhookOptions) (GitHubV3RESTAPIClientReposTestPushWebhookResponse, error) {
	req, err := client.reposTestPushWebhookCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposTestPushWebhookResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposTestPushWebhookResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposTestPushWebhookResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposTestPushWebhookHandleResponse(resp)
}

// reposTestPushWebhookCreateRequest creates the ReposTestPushWebhook request.
func (client *GitHubV3RESTAPIClient) reposTestPushWebhookCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientReposTestPushWebhookOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/hooks/{hook_id}/tests"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// reposTestPushWebhookHandleResponse handles the ReposTestPushWebhook response.
func (client *GitHubV3RESTAPIClient) reposTestPushWebhookHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposTestPushWebhookResponse, error) {
	result := GitHubV3RESTAPIClientReposTestPushWebhookResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientReposTestPushWebhookResponse{}, err
	}
	return result, nil
}

// ReposTransfer - A transfer request will need to be accepted by the new owner when transferring a personal repository to
// another user. The response will contain the original owner, and the transfer will continue
// asynchronously. For more details on the requirements to transfer personal and organization-owned repositories, see about
// repository transfers
// [https://docs.github.com/articles/about-repository-transfers/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposTransferOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposTransfer
//     method.
func (client *GitHubV3RESTAPIClient) ReposTransfer(ctx context.Context, body Paths1Rezap1ReposOwnerRepoTransferPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposTransferOptions) (GitHubV3RESTAPIClientReposTransferResponse, error) {
	req, err := client.reposTransferCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposTransferResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposTransferResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return GitHubV3RESTAPIClientReposTransferResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposTransferHandleResponse(resp)
}

// reposTransferCreateRequest creates the ReposTransfer request.
func (client *GitHubV3RESTAPIClient) reposTransferCreateRequest(ctx context.Context, body Paths1Rezap1ReposOwnerRepoTransferPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposTransferOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/transfer"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposTransferHandleResponse handles the ReposTransfer response.
func (client *GitHubV3RESTAPIClient) reposTransferHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposTransferResponse, error) {
	result := GitHubV3RESTAPIClientReposTransferResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MinimalRepository); err != nil {
		return GitHubV3RESTAPIClientReposTransferResponse{}, err
	}
	return result, nil
}

// ReposUpdate - Note: To edit a repository's topics, use the Replace all repository topics [https://docs.github.com/rest/reference/repos#replace-all-repository-topics]
// endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposUpdateOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposUpdate
//     method.
func (client *GitHubV3RESTAPIClient) ReposUpdate(ctx context.Context, body Paths1Vy1VsiReposOwnerRepoPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateOptions) (GitHubV3RESTAPIClientReposUpdateResponse, error) {
	req, err := client.reposUpdateCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposUpdateResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposUpdateHandleResponse(resp)
}

// reposUpdateCreateRequest creates the ReposUpdate request.
func (client *GitHubV3RESTAPIClient) reposUpdateCreateRequest(ctx context.Context, body Paths1Vy1VsiReposOwnerRepoPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposUpdateHandleResponse handles the ReposUpdate response.
func (client *GitHubV3RESTAPIClient) reposUpdateHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposUpdateResponse, error) {
	result := GitHubV3RESTAPIClientReposUpdateResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val FullRepository
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposUpdateResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposUpdateBranchProtection - Protected branches are available in public repositories with GitHub Free and GitHub Free
// for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Protecting a branch requires admin or owner permissions to the repository.
// Note: Passing new arrays of users and teams replaces their previous values.
// Note: The list of users, apps, and teams in total is limited to 100 items.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposUpdateBranchProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposUpdateBranchProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposUpdateBranchProtection(ctx context.Context, body Paths1Vr1F5VReposOwnerRepoBranchesBranchProtectionPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateBranchProtectionOptions) (GitHubV3RESTAPIClientReposUpdateBranchProtectionResponse, error) {
	req, err := client.reposUpdateBranchProtectionCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateBranchProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateBranchProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposUpdateBranchProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposUpdateBranchProtectionHandleResponse(resp)
}

// reposUpdateBranchProtectionCreateRequest creates the ReposUpdateBranchProtection request.
func (client *GitHubV3RESTAPIClient) reposUpdateBranchProtectionCreateRequest(ctx context.Context, body Paths1Vr1F5VReposOwnerRepoBranchesBranchProtectionPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateBranchProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposUpdateBranchProtectionHandleResponse handles the ReposUpdateBranchProtection response.
func (client *GitHubV3RESTAPIClient) reposUpdateBranchProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposUpdateBranchProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposUpdateBranchProtectionResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProtectedBranch
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateBranchProtectionResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateBranchProtectionResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateBranchProtectionResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationErrorSimple
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateBranchProtectionResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposUpdateBranchProtectionResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposUpdateCommitComment - Update a commit comment
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposUpdateCommitCommentOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposUpdateCommitComment
//     method.
func (client *GitHubV3RESTAPIClient) ReposUpdateCommitComment(ctx context.Context, body Paths1S0XspiReposOwnerRepoCommentsCommentIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateCommitCommentOptions) (GitHubV3RESTAPIClientReposUpdateCommitCommentResponse, error) {
	req, err := client.reposUpdateCommitCommentCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateCommitCommentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateCommitCommentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposUpdateCommitCommentResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposUpdateCommitCommentHandleResponse(resp)
}

// reposUpdateCommitCommentCreateRequest creates the ReposUpdateCommitComment request.
func (client *GitHubV3RESTAPIClient) reposUpdateCommitCommentCreateRequest(ctx context.Context, body Paths1S0XspiReposOwnerRepoCommentsCommentIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateCommitCommentOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/comments/{comment_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{comment_id}", url.PathEscape(strconv.FormatInt(int64(client.commentID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposUpdateCommitCommentHandleResponse handles the ReposUpdateCommitComment response.
func (client *GitHubV3RESTAPIClient) reposUpdateCommitCommentHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposUpdateCommitCommentResponse, error) {
	result := GitHubV3RESTAPIClientReposUpdateCommitCommentResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val CommitComment
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateCommitCommentResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateCommitCommentResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposUpdateCommitCommentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposUpdateDeploymentBranchPolicy - Updates a deployment branch policy for an environment.
// You must authenticate using an access token with the repo scope to use this endpoint. GitHub Apps must have the administration:write
// permission for the repository to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposUpdateDeploymentBranchPolicyOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposUpdateDeploymentBranchPolicy
//     method.
func (client *GitHubV3RESTAPIClient) ReposUpdateDeploymentBranchPolicy(ctx context.Context, body DeploymentBranchPolicyNamePattern, options *GitHubV3RESTAPIClientReposUpdateDeploymentBranchPolicyOptions) (GitHubV3RESTAPIClientReposUpdateDeploymentBranchPolicyResponse, error) {
	req, err := client.reposUpdateDeploymentBranchPolicyCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateDeploymentBranchPolicyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateDeploymentBranchPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposUpdateDeploymentBranchPolicyResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposUpdateDeploymentBranchPolicyHandleResponse(resp)
}

// reposUpdateDeploymentBranchPolicyCreateRequest creates the ReposUpdateDeploymentBranchPolicy request.
func (client *GitHubV3RESTAPIClient) reposUpdateDeploymentBranchPolicyCreateRequest(ctx context.Context, body DeploymentBranchPolicyNamePattern, options *GitHubV3RESTAPIClientReposUpdateDeploymentBranchPolicyOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	if client.environmentName == "" {
		return nil, errors.New("parameter client.environmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{environment_name}", url.PathEscape(client.environmentName))
	urlPath = strings.ReplaceAll(urlPath, "{branch_policy_id}", url.PathEscape(strconv.FormatInt(int64(client.branchPolicyID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposUpdateDeploymentBranchPolicyHandleResponse handles the ReposUpdateDeploymentBranchPolicy response.
func (client *GitHubV3RESTAPIClient) reposUpdateDeploymentBranchPolicyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposUpdateDeploymentBranchPolicyResponse, error) {
	result := GitHubV3RESTAPIClientReposUpdateDeploymentBranchPolicyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentBranchPolicy); err != nil {
		return GitHubV3RESTAPIClientReposUpdateDeploymentBranchPolicyResponse{}, err
	}
	return result, nil
}

// ReposUpdateInformationAboutPagesSite - Updates information for a GitHub Pages site. For more information, see "About GitHub
// Pages [/github/working-with-github-pages/about-github-pages].
// To use this endpoint, you must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.
// A token with the repo scope or Pages write permission is required.
// GitHub Apps must have the administration:write and pages:write permissions.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposUpdateInformationAboutPagesSiteOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposUpdateInformationAboutPagesSite
//     method.
func (client *GitHubV3RESTAPIClient) ReposUpdateInformationAboutPagesSite(ctx context.Context, body Paths1D5Zy92ReposOwnerRepoPagesPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateInformationAboutPagesSiteOptions) (GitHubV3RESTAPIClientReposUpdateInformationAboutPagesSiteResponse, error) {
	req, err := client.reposUpdateInformationAboutPagesSiteCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateInformationAboutPagesSiteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateInformationAboutPagesSiteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusBadRequest, http.StatusConflict, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposUpdateInformationAboutPagesSiteResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposUpdateInformationAboutPagesSiteHandleResponse(resp)
}

// reposUpdateInformationAboutPagesSiteCreateRequest creates the ReposUpdateInformationAboutPagesSite request.
func (client *GitHubV3RESTAPIClient) reposUpdateInformationAboutPagesSiteCreateRequest(ctx context.Context, body Paths1D5Zy92ReposOwnerRepoPagesPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateInformationAboutPagesSiteOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/pages"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json, application/scim+json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposUpdateInformationAboutPagesSiteHandleResponse handles the ReposUpdateInformationAboutPagesSite response.
func (client *GitHubV3RESTAPIClient) reposUpdateInformationAboutPagesSiteHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposUpdateInformationAboutPagesSiteResponse, error) {
	result := GitHubV3RESTAPIClientReposUpdateInformationAboutPagesSiteResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusBadRequest:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateInformationAboutPagesSiteResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateInformationAboutPagesSiteResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateInformationAboutPagesSiteResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposUpdateInformationAboutPagesSiteResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposUpdateInvitation - Update a repository invitation
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposUpdateInvitationOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposUpdateInvitation
//     method.
func (client *GitHubV3RESTAPIClient) ReposUpdateInvitation(ctx context.Context, body Paths1D0BbsxReposOwnerRepoInvitationsInvitationIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateInvitationOptions) (GitHubV3RESTAPIClientReposUpdateInvitationResponse, error) {
	req, err := client.reposUpdateInvitationCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateInvitationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateInvitationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposUpdateInvitationResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposUpdateInvitationHandleResponse(resp)
}

// reposUpdateInvitationCreateRequest creates the ReposUpdateInvitation request.
func (client *GitHubV3RESTAPIClient) reposUpdateInvitationCreateRequest(ctx context.Context, body Paths1D0BbsxReposOwnerRepoInvitationsInvitationIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateInvitationOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/invitations/{invitation_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{invitation_id}", url.PathEscape(strconv.FormatInt(int64(client.invitationID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposUpdateInvitationHandleResponse handles the ReposUpdateInvitation response.
func (client *GitHubV3RESTAPIClient) reposUpdateInvitationHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposUpdateInvitationResponse, error) {
	result := GitHubV3RESTAPIClientReposUpdateInvitationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RepositoryInvitation); err != nil {
		return GitHubV3RESTAPIClientReposUpdateInvitationResponse{}, err
	}
	return result, nil
}

// ReposUpdatePullRequestReviewProtection - Protected branches are available in public repositories with GitHub Free and GitHub
// Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Updating pull request review enforcement requires admin or owner permissions to the repository and branch protection to
// be enabled.
// Note: Passing new arrays of users and teams replaces their previous values.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposUpdatePullRequestReviewProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposUpdatePullRequestReviewProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposUpdatePullRequestReviewProtection(ctx context.Context, body PathsHt509LReposOwnerRepoBranchesBranchProtectionRequiredPullRequestReviewsPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdatePullRequestReviewProtectionOptions) (GitHubV3RESTAPIClientReposUpdatePullRequestReviewProtectionResponse, error) {
	req, err := client.reposUpdatePullRequestReviewProtectionCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdatePullRequestReviewProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdatePullRequestReviewProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposUpdatePullRequestReviewProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposUpdatePullRequestReviewProtectionHandleResponse(resp)
}

// reposUpdatePullRequestReviewProtectionCreateRequest creates the ReposUpdatePullRequestReviewProtection request.
func (client *GitHubV3RESTAPIClient) reposUpdatePullRequestReviewProtectionCreateRequest(ctx context.Context, body PathsHt509LReposOwnerRepoBranchesBranchProtectionRequiredPullRequestReviewsPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdatePullRequestReviewProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposUpdatePullRequestReviewProtectionHandleResponse handles the ReposUpdatePullRequestReviewProtection response.
func (client *GitHubV3RESTAPIClient) reposUpdatePullRequestReviewProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposUpdatePullRequestReviewProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposUpdatePullRequestReviewProtectionResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProtectedBranchPullRequestReview
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdatePullRequestReviewProtectionResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdatePullRequestReviewProtectionResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposUpdatePullRequestReviewProtectionResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposUpdateRelease - Users with push access to the repository can edit a release.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposUpdateReleaseOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposUpdateRelease
//     method.
func (client *GitHubV3RESTAPIClient) ReposUpdateRelease(ctx context.Context, body PathsQth03CReposOwnerRepoReleasesReleaseIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateReleaseOptions) (GitHubV3RESTAPIClientReposUpdateReleaseResponse, error) {
	req, err := client.reposUpdateReleaseCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateReleaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateReleaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientReposUpdateReleaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposUpdateReleaseHandleResponse(resp)
}

// reposUpdateReleaseCreateRequest creates the ReposUpdateRelease request.
func (client *GitHubV3RESTAPIClient) reposUpdateReleaseCreateRequest(ctx context.Context, body PathsQth03CReposOwnerRepoReleasesReleaseIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateReleaseOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/releases/{release_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{release_id}", url.PathEscape(strconv.FormatInt(int64(client.releaseID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposUpdateReleaseHandleResponse handles the ReposUpdateRelease response.
func (client *GitHubV3RESTAPIClient) reposUpdateReleaseHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposUpdateReleaseResponse, error) {
	result := GitHubV3RESTAPIClientReposUpdateReleaseResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Release
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateReleaseResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateReleaseResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposUpdateReleaseResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposUpdateReleaseAsset - Users with push access to the repository can edit a release asset.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposUpdateReleaseAssetOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposUpdateReleaseAsset
//     method.
func (client *GitHubV3RESTAPIClient) ReposUpdateReleaseAsset(ctx context.Context, body PathsFz02Q1ReposOwnerRepoReleasesAssetsAssetIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateReleaseAssetOptions) (GitHubV3RESTAPIClientReposUpdateReleaseAssetResponse, error) {
	req, err := client.reposUpdateReleaseAssetCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateReleaseAssetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateReleaseAssetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposUpdateReleaseAssetResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposUpdateReleaseAssetHandleResponse(resp)
}

// reposUpdateReleaseAssetCreateRequest creates the ReposUpdateReleaseAsset request.
func (client *GitHubV3RESTAPIClient) reposUpdateReleaseAssetCreateRequest(ctx context.Context, body PathsFz02Q1ReposOwnerRepoReleasesAssetsAssetIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateReleaseAssetOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/releases/assets/{asset_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{asset_id}", url.PathEscape(strconv.FormatInt(int64(client.assetID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposUpdateReleaseAssetHandleResponse handles the ReposUpdateReleaseAsset response.
func (client *GitHubV3RESTAPIClient) reposUpdateReleaseAssetHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposUpdateReleaseAssetResponse, error) {
	result := GitHubV3RESTAPIClientReposUpdateReleaseAssetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ReleaseAsset); err != nil {
		return GitHubV3RESTAPIClientReposUpdateReleaseAssetResponse{}, err
	}
	return result, nil
}

// ReposUpdateStatusCheckProtection - Protected branches are available in public repositories with GitHub Free and GitHub
// Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise
// Cloud, and GitHub Enterprise Server. For more information, see GitHub's products [https://docs.github.com/github/getting-started-with-github/githubs-products]
// in the GitHub Help documentation.
// Updating required status checks requires admin or owner permissions to the repository and branch protection to be enabled.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposUpdateStatusCheckProtectionOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposUpdateStatusCheckProtection
//     method.
func (client *GitHubV3RESTAPIClient) ReposUpdateStatusCheckProtection(ctx context.Context, body PathsEjre0CReposOwnerRepoBranchesBranchProtectionRequiredStatusChecksPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateStatusCheckProtectionOptions) (GitHubV3RESTAPIClientReposUpdateStatusCheckProtectionResponse, error) {
	req, err := client.reposUpdateStatusCheckProtectionCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateStatusCheckProtectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateStatusCheckProtectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposUpdateStatusCheckProtectionResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposUpdateStatusCheckProtectionHandleResponse(resp)
}

// reposUpdateStatusCheckProtectionCreateRequest creates the ReposUpdateStatusCheckProtection request.
func (client *GitHubV3RESTAPIClient) reposUpdateStatusCheckProtectionCreateRequest(ctx context.Context, body PathsEjre0CReposOwnerRepoBranchesBranchProtectionRequiredStatusChecksPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateStatusCheckProtectionOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.branch != nil {
		reqQP.Set("branch", *client.branch)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposUpdateStatusCheckProtectionHandleResponse handles the ReposUpdateStatusCheckProtection response.
func (client *GitHubV3RESTAPIClient) reposUpdateStatusCheckProtectionHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposUpdateStatusCheckProtectionResponse, error) {
	result := GitHubV3RESTAPIClientReposUpdateStatusCheckProtectionResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val StatusCheckPolicy
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateStatusCheckProtectionResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateStatusCheckProtectionResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateStatusCheckProtectionResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposUpdateStatusCheckProtectionResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposUpdateWebhook - Updates a webhook configured in a repository. If you previously had a secret set, you must provide
// the same secret or set a new secret or the secret will be removed. If you are only updating
// individual webhook config properties, use "Update a webhook configuration for a repository [/rest/reference/repos#update-a-webhook-configuration-for-a-repository]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposUpdateWebhookOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposUpdateWebhook
//     method.
func (client *GitHubV3RESTAPIClient) ReposUpdateWebhook(ctx context.Context, body Paths1I9HuefReposOwnerRepoHooksHookIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateWebhookOptions) (GitHubV3RESTAPIClientReposUpdateWebhookResponse, error) {
	req, err := client.reposUpdateWebhookCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateWebhookResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateWebhookResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposUpdateWebhookResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposUpdateWebhookHandleResponse(resp)
}

// reposUpdateWebhookCreateRequest creates the ReposUpdateWebhook request.
func (client *GitHubV3RESTAPIClient) reposUpdateWebhookCreateRequest(ctx context.Context, body Paths1I9HuefReposOwnerRepoHooksHookIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateWebhookOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/hooks/{hook_id}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposUpdateWebhookHandleResponse handles the ReposUpdateWebhook response.
func (client *GitHubV3RESTAPIClient) reposUpdateWebhookHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposUpdateWebhookResponse, error) {
	result := GitHubV3RESTAPIClientReposUpdateWebhookResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Hook
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateWebhookResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateWebhookResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientReposUpdateWebhookResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientReposUpdateWebhookResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// ReposUpdateWebhookConfigForRepo - Updates the webhook configuration for a repository. To update more information about
// the webhook, including the active state and events, use "Update a repository webhook
// [/rest/reference/orgs#update-a-repository-webhook]."
// Access tokens must have the write:repohook or repo scope, and GitHub Apps must have the repositoryhooks:write permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposUpdateWebhookConfigForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposUpdateWebhookConfigForRepo
//     method.
func (client *GitHubV3RESTAPIClient) ReposUpdateWebhookConfigForRepo(ctx context.Context, body Paths1Xxb6CtReposOwnerRepoHooksHookIDConfigPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateWebhookConfigForRepoOptions) (GitHubV3RESTAPIClientReposUpdateWebhookConfigForRepoResponse, error) {
	req, err := client.reposUpdateWebhookConfigForRepoCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateWebhookConfigForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposUpdateWebhookConfigForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientReposUpdateWebhookConfigForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposUpdateWebhookConfigForRepoHandleResponse(resp)
}

// reposUpdateWebhookConfigForRepoCreateRequest creates the ReposUpdateWebhookConfigForRepo request.
func (client *GitHubV3RESTAPIClient) reposUpdateWebhookConfigForRepoCreateRequest(ctx context.Context, body Paths1Xxb6CtReposOwnerRepoHooksHookIDConfigPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientReposUpdateWebhookConfigForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/hooks/{hook_id}/config"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{hook_id}", url.PathEscape(strconv.FormatInt(int64(client.hookID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// reposUpdateWebhookConfigForRepoHandleResponse handles the ReposUpdateWebhookConfigForRepo response.
func (client *GitHubV3RESTAPIClient) reposUpdateWebhookConfigForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposUpdateWebhookConfigForRepoResponse, error) {
	result := GitHubV3RESTAPIClientReposUpdateWebhookConfigForRepoResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebhookConfig); err != nil {
		return GitHubV3RESTAPIClientReposUpdateWebhookConfigForRepoResponse{}, err
	}
	return result, nil
}

// ReposUploadReleaseAsset - This endpoint makes use of a Hypermedia relation [https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia]
// to determine which URL to access. The endpoint you call to upload release
// assets is specific to your release. Use the upload_url returned in the response of the Create a release endpoint [https://docs.github.com/rest/releases/releases#create-a-release]
// to upload a release
// asset.
// You need to use an HTTP client which supports SNI [http://en.wikipedia.org/wiki/ServerNameIndication] to make calls to
// this endpoint.
// Most libraries will set the required Content-Length header automatically. Use the required Content-Type header to provide
// the media type of the asset. For a list of media types, see Media Types
// [https://www.iana.org/assignments/media-types/media-types.xhtml]. For example:
// application/zip
// GitHub expects the asset data in its raw binary form, rather than JSON. You will send the raw binary content of the asset
// as the request body. Everything else about the endpoint is the same as the
// rest of the API. For example, you'll still need to pass your authentication to be able to upload an asset.
// When an upstream failure occurs, you will receive a 502 Bad Gateway status. This may leave an empty asset with a state
// of starter. It can be safely deleted.
// Notes:
// * GitHub renames asset filenames that have special characters, non-alphanumeric characters, and leading or trailing periods.
// The "List assets for a release
// [https://docs.github.com/rest/reference/repos#list-assets-for-a-release]" endpoint lists the renamed filenames. For more
// information and help, contact GitHub Support
// [https://support.github.com/contact?tags=dotcom-rest-api].
// * To find the release_id query the GET /repos/{owner}/{repo}/releases/latest endpoint [https://docs.github.com/rest/releases/releases#get-the-latest-release].
// * If you upload an asset with the same filename as another uploaded asset, you'll receive an error and must delete the
// old file before you can re-upload the new asset.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientReposUploadReleaseAssetOptions contains the optional parameters for the GitHubV3RESTAPIClient.ReposUploadReleaseAsset
//     method.
func (client *GitHubV3RESTAPIClient) ReposUploadReleaseAsset(ctx context.Context, name string, options *GitHubV3RESTAPIClientReposUploadReleaseAssetOptions) (GitHubV3RESTAPIClientReposUploadReleaseAssetResponse, error) {
	req, err := client.reposUploadReleaseAssetCreateRequest(ctx, name, options)
	if err != nil {
		return GitHubV3RESTAPIClientReposUploadReleaseAssetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientReposUploadReleaseAssetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientReposUploadReleaseAssetResponse{}, runtime.NewResponseError(resp)
	}
	return client.reposUploadReleaseAssetHandleResponse(resp)
}

// reposUploadReleaseAssetCreateRequest creates the ReposUploadReleaseAsset request.
func (client *GitHubV3RESTAPIClient) reposUploadReleaseAssetCreateRequest(ctx context.Context, name string, options *GitHubV3RESTAPIClientReposUploadReleaseAssetOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/releases/{release_id}/assets"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{release_id}", url.PathEscape(strconv.FormatInt(int64(client.releaseID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("name", name)
	if options != nil && options.Label != nil {
		reqQP.Set("label", *options.Label)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Data != nil {
	return req, req.SetBody(options.Data, "application/octet-stream")
	}
	return req, nil
}

// reposUploadReleaseAssetHandleResponse handles the ReposUploadReleaseAsset response.
func (client *GitHubV3RESTAPIClient) reposUploadReleaseAssetHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientReposUploadReleaseAssetResponse, error) {
	result := GitHubV3RESTAPIClientReposUploadReleaseAssetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ReleaseAsset); err != nil {
		return GitHubV3RESTAPIClientReposUploadReleaseAssetResponse{}, err
	}
	return result, nil
}

// SearchCode - Searches for query terms inside of a file. This method returns up to 100 results per page [https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination].
// When searching for code, you can get text match metadata for the file content and file path fields when you pass the text-match
// media type. For more details about how to receive highlighted search
// results, see Text match metadata [https://docs.github.com/rest/reference/search#text-match-metadata].
// For example, if you want to find the definition of the addClass function inside jQuery [https://github.com/jquery/jquery]
// repository, your query would look something like this:
// q=addClass+in:file+language:js+repo:jquery/jquery
// This query searches for the keyword addClass within a file's contents. The query limits the search to files where the language
// is JavaScript in the jquery/jquery repository.
// CONSIDERATIONS FOR CODE SEARCH Due to the complexity of searching code, there are a few restrictions on how searches are
// performed:
// * Only the default branch is considered. In most cases, this will be the master branch.
// * Only files smaller than 384 KB are searchable.
// * You must always include at least one search term when searching source code. For example, searching for language:go [https://github.com/search?utf8=%E2%9C%93&q=language%3Ago&type=Code]
// is not
// valid, while amazing language:go [https://github.com/search?utf8=%E2%9C%93&q=amazing+language%3Ago&type=Code] is.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - q - The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific
//     areas of GitHub. The REST API supports the same qualifiers as the web interface for
//     GitHub. To learn more about the format of the query, see Constructing a search query [https://docs.github.com/rest/reference/search#constructing-a-search-query].
//     See "Searching code
//     [https://docs.github.com/search-github/searching-on-github/searching-code]" for a detailed list of qualifiers.
//   - options - GitHubV3RESTAPIClientSearchCodeOptions contains the optional parameters for the GitHubV3RESTAPIClient.SearchCode
//     method.
func (client *GitHubV3RESTAPIClient) SearchCode(ctx context.Context, q string, options *GitHubV3RESTAPIClientSearchCodeOptions) (GitHubV3RESTAPIClientSearchCodeResponse, error) {
	req, err := client.searchCodeCreateRequest(ctx, q, options)
	if err != nil {
		return GitHubV3RESTAPIClientSearchCodeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientSearchCodeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusUnprocessableEntity, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientSearchCodeResponse{}, runtime.NewResponseError(resp)
	}
	return client.searchCodeHandleResponse(resp)
}

// searchCodeCreateRequest creates the SearchCode request.
func (client *GitHubV3RESTAPIClient) searchCodeCreateRequest(ctx context.Context, q string, options *GitHubV3RESTAPIClientSearchCodeOptions) (*policy.Request, error) {
	urlPath := "/search/code"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("q", q)
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if client.order != nil {
		reqQP.Set("order", string(*client.order))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// searchCodeHandleResponse handles the SearchCode response.
func (client *GitHubV3RESTAPIClient) searchCodeHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientSearchCodeResponse, error) {
	result := GitHubV3RESTAPIClientSearchCodeResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PathsQ14Qg0SearchCodeGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchCodeResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchCodeResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchCodeResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchCodeResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientSearchCodeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// SearchCommits - Find commits via various criteria on the default branch (usually main). This method returns up to 100 results
// per page [https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination].
// When searching for commits, you can get text match metadata for the message field when you provide the text-match media
// type. For more details about how to receive highlighted search results, see Text
// match metadata [https://docs.github.com/rest/reference/search#text-match-metadata].
// For example, if you want to find commits related to CSS in the octocat/Spoon-Knife [https://github.com/octocat/Spoon-Knife]
// repository. Your query would look something like this:
// q=repo:octocat/Spoon-Knife+css
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - q - The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific
//     areas of GitHub. The REST API supports the same qualifiers as the web interface for
//     GitHub. To learn more about the format of the query, see Constructing a search query [https://docs.github.com/rest/reference/search#constructing-a-search-query].
//     See "Searching commits
//     [https://docs.github.com/search-github/searching-on-github/searching-commits]" for a detailed list of qualifiers.
//   - options - GitHubV3RESTAPIClientSearchCommitsOptions contains the optional parameters for the GitHubV3RESTAPIClient.SearchCommits
//     method.
func (client *GitHubV3RESTAPIClient) SearchCommits(ctx context.Context, q string, options *GitHubV3RESTAPIClientSearchCommitsOptions) (GitHubV3RESTAPIClientSearchCommitsResponse, error) {
	req, err := client.searchCommitsCreateRequest(ctx, q, options)
	if err != nil {
		return GitHubV3RESTAPIClientSearchCommitsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientSearchCommitsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified) {
		return GitHubV3RESTAPIClientSearchCommitsResponse{}, runtime.NewResponseError(resp)
	}
	return client.searchCommitsHandleResponse(resp)
}

// searchCommitsCreateRequest creates the SearchCommits request.
func (client *GitHubV3RESTAPIClient) searchCommitsCreateRequest(ctx context.Context, q string, options *GitHubV3RESTAPIClientSearchCommitsOptions) (*policy.Request, error) {
	urlPath := "/search/commits"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("q", q)
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if client.order != nil {
		reqQP.Set("order", string(*client.order))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// searchCommitsHandleResponse handles the SearchCommits response.
func (client *GitHubV3RESTAPIClient) searchCommitsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientSearchCommitsResponse, error) {
	result := GitHubV3RESTAPIClientSearchCommitsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths59Ua1LSearchCommitsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientSearchCommitsResponse{}, err
	}
	return result, nil
}

// SearchIssuesAndPullRequests - Find issues by state and keyword. This method returns up to 100 results per page [https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination].
// When searching for issues, you can get text match metadata for the issue title, issue body, and issue comment body fields
// when you pass the text-match media type. For more details about how to receive
// highlighted search results, see Text match metadata [https://docs.github.com/rest/reference/search#text-match-metadata].
// For example, if you want to find the oldest unresolved Python bugs on Windows. Your query might look something like this.
// q=windows+label:bug+language:python+state:open&sort=created&order=asc
// This query searches for the keyword windows, within any open issue that is labeled as bug. The search runs across repositories
// whose primary language is Python. The results are sorted by creation date
// in ascending order, which means the oldest issues appear first in the search results.
// Note: For user-to-server [https://docs.github.com/developers/apps/identifying-and-authorizing-users-for-github-apps#user-to-server-requests]
// GitHub App requests, you can't retrieve a combination of
// issues and pull requests in a single query. Requests that don't include the is:issue or is:pull-request qualifier will
// receive an HTTP 422 Unprocessable Entity response. To get results for both issues
// and pull requests, you must send separate queries for issues and pull requests. For more information about the is qualifier,
// see "Searching only issues or pull requests
// [https://docs.github.com/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-only-issues-or-pull-requests]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - q - The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific
//     areas of GitHub. The REST API supports the same qualifiers as the web interface for
//     GitHub. To learn more about the format of the query, see Constructing a search query [https://docs.github.com/rest/reference/search#constructing-a-search-query].
//     See "Searching issues and pull
//     requests [https://docs.github.com/search-github/searching-on-github/searching-issues-and-pull-requests]" for a detailed
//     list of qualifiers.
//   - options - GitHubV3RESTAPIClientSearchIssuesAndPullRequestsOptions contains the optional parameters for the GitHubV3RESTAPIClient.SearchIssuesAndPullRequests
//     method.
func (client *GitHubV3RESTAPIClient) SearchIssuesAndPullRequests(ctx context.Context, q string, options *GitHubV3RESTAPIClientSearchIssuesAndPullRequestsOptions) (GitHubV3RESTAPIClientSearchIssuesAndPullRequestsResponse, error) {
	req, err := client.searchIssuesAndPullRequestsCreateRequest(ctx, q, options)
	if err != nil {
		return GitHubV3RESTAPIClientSearchIssuesAndPullRequestsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientSearchIssuesAndPullRequestsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusUnprocessableEntity, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientSearchIssuesAndPullRequestsResponse{}, runtime.NewResponseError(resp)
	}
	return client.searchIssuesAndPullRequestsHandleResponse(resp)
}

// searchIssuesAndPullRequestsCreateRequest creates the SearchIssuesAndPullRequests request.
func (client *GitHubV3RESTAPIClient) searchIssuesAndPullRequestsCreateRequest(ctx context.Context, q string, options *GitHubV3RESTAPIClientSearchIssuesAndPullRequestsOptions) (*policy.Request, error) {
	urlPath := "/search/issues"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("q", q)
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if client.order != nil {
		reqQP.Set("order", string(*client.order))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// searchIssuesAndPullRequestsHandleResponse handles the SearchIssuesAndPullRequests response.
func (client *GitHubV3RESTAPIClient) searchIssuesAndPullRequestsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientSearchIssuesAndPullRequestsResponse, error) {
	result := GitHubV3RESTAPIClientSearchIssuesAndPullRequestsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Paths1A1084MSearchIssuesGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchIssuesAndPullRequestsResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchIssuesAndPullRequestsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchIssuesAndPullRequestsResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchIssuesAndPullRequestsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientSearchIssuesAndPullRequestsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// SearchLabels - Find labels in a repository with names or descriptions that match search keywords. Returns up to 100 results
// per page [https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination].
// When searching for labels, you can get text match metadata for the label name and description fields when you pass the
// text-match media type. For more details about how to receive highlighted search
// results, see Text match metadata [https://docs.github.com/rest/reference/search#text-match-metadata].
// For example, if you want to find labels in the linguist repository that match bug, defect, or enhancement. Your query might
// look like this:
// q=bug+defect+enhancement&repository_id=64778136
// The labels that best match the query appear first in the search results.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - repositoryID - The id of the repository.
//   - q - The search keywords. This endpoint does not accept qualifiers in the query. To learn more about the format of the query,
//     see Constructing a search query
//     [https://docs.github.com/rest/reference/search#constructing-a-search-query].
//   - options - GitHubV3RESTAPIClientSearchLabelsOptions contains the optional parameters for the GitHubV3RESTAPIClient.SearchLabels
//     method.
func (client *GitHubV3RESTAPIClient) SearchLabels(ctx context.Context, repositoryID int32, q string, options *GitHubV3RESTAPIClientSearchLabelsOptions) (GitHubV3RESTAPIClientSearchLabelsResponse, error) {
	req, err := client.searchLabelsCreateRequest(ctx, repositoryID, q, options)
	if err != nil {
		return GitHubV3RESTAPIClientSearchLabelsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientSearchLabelsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientSearchLabelsResponse{}, runtime.NewResponseError(resp)
	}
	return client.searchLabelsHandleResponse(resp)
}

// searchLabelsCreateRequest creates the SearchLabels request.
func (client *GitHubV3RESTAPIClient) searchLabelsCreateRequest(ctx context.Context, repositoryID int32, q string, options *GitHubV3RESTAPIClientSearchLabelsOptions) (*policy.Request, error) {
	urlPath := "/search/labels"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("repository_id", strconv.FormatInt(int64(repositoryID), 10))
	reqQP.Set("q", q)
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if client.order != nil {
		reqQP.Set("order", string(*client.order))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// searchLabelsHandleResponse handles the SearchLabels response.
func (client *GitHubV3RESTAPIClient) searchLabelsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientSearchLabelsResponse, error) {
	result := GitHubV3RESTAPIClientSearchLabelsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PathsOfgf9PSearchLabelsGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchLabelsResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchLabelsResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchLabelsResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchLabelsResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientSearchLabelsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// SearchRepos - Find repositories via various criteria. This method returns up to 100 results per page [https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination].
// When searching for repositories, you can get text match metadata for the name and description fields when you pass the
// text-match media type. For more details about how to receive highlighted search
// results, see Text match metadata [https://docs.github.com/rest/reference/search#text-match-metadata].
// For example, if you want to search for popular Tetris repositories written in assembly code, your query might look like
// this:
// q=tetris+language:assembly&sort=stars&order=desc
// This query searches for repositories with the word tetris in the name, the description, or the README. The results are
// limited to repositories where the primary language is assembly. The results are
// sorted by stars in descending order, so that the most popular repositories appear first in the search results.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - q - The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific
//     areas of GitHub. The REST API supports the same qualifiers as the web interface for
//     GitHub. To learn more about the format of the query, see Constructing a search query [https://docs.github.com/rest/reference/search#constructing-a-search-query].
//     See "Searching for repositories
//     [https://docs.github.com/articles/searching-for-repositories/]" for a detailed list of qualifiers.
//   - options - GitHubV3RESTAPIClientSearchReposOptions contains the optional parameters for the GitHubV3RESTAPIClient.SearchRepos
//     method.
func (client *GitHubV3RESTAPIClient) SearchRepos(ctx context.Context, q string, options *GitHubV3RESTAPIClientSearchReposOptions) (GitHubV3RESTAPIClientSearchReposResponse, error) {
	req, err := client.searchReposCreateRequest(ctx, q, options)
	if err != nil {
		return GitHubV3RESTAPIClientSearchReposResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientSearchReposResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnprocessableEntity, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientSearchReposResponse{}, runtime.NewResponseError(resp)
	}
	return client.searchReposHandleResponse(resp)
}

// searchReposCreateRequest creates the SearchRepos request.
func (client *GitHubV3RESTAPIClient) searchReposCreateRequest(ctx context.Context, q string, options *GitHubV3RESTAPIClientSearchReposOptions) (*policy.Request, error) {
	urlPath := "/search/repositories"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("q", q)
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if client.order != nil {
		reqQP.Set("order", string(*client.order))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// searchReposHandleResponse handles the SearchRepos response.
func (client *GitHubV3RESTAPIClient) searchReposHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientSearchReposResponse, error) {
	result := GitHubV3RESTAPIClientSearchReposResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Paths1Vdo4BmSearchRepositoriesGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchReposResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchReposResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchReposResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientSearchReposResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// SearchTopics - Find topics via various criteria. Results are sorted by best match. This method returns up to 100 results
// per page [https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination]. See "
// Searching topics [https://docs.github.com/articles/searching-topics/]" for a detailed list of qualifiers.
// When searching for topics, you can get text match metadata for the topic's shortdescription, description, name, or displayname
// field when you pass the text-match media type. For more details about how
// to receive highlighted search results, see Text match metadata [https://docs.github.com/rest/reference/search#text-match-metadata].
// For example, if you want to search for topics related to Ruby that are featured on https://github.com/topics. Your query
// might look like this:
// q=ruby+is:featured
// This query searches for topics with the keyword ruby and limits the results to find only topics that are featured. The
// topics that are the best match for the query appear first in the search results.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - q - The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific
//     areas of GitHub. The REST API supports the same qualifiers as the web interface for
//     GitHub. To learn more about the format of the query, see Constructing a search query [https://docs.github.com/rest/reference/search#constructing-a-search-query].
//   - options - GitHubV3RESTAPIClientSearchTopicsOptions contains the optional parameters for the GitHubV3RESTAPIClient.SearchTopics
//     method.
func (client *GitHubV3RESTAPIClient) SearchTopics(ctx context.Context, q string, options *GitHubV3RESTAPIClientSearchTopicsOptions) (GitHubV3RESTAPIClientSearchTopicsResponse, error) {
	req, err := client.searchTopicsCreateRequest(ctx, q, options)
	if err != nil {
		return GitHubV3RESTAPIClientSearchTopicsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientSearchTopicsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified) {
		return GitHubV3RESTAPIClientSearchTopicsResponse{}, runtime.NewResponseError(resp)
	}
	return client.searchTopicsHandleResponse(resp)
}

// searchTopicsCreateRequest creates the SearchTopics request.
func (client *GitHubV3RESTAPIClient) searchTopicsCreateRequest(ctx context.Context, q string, options *GitHubV3RESTAPIClientSearchTopicsOptions) (*policy.Request, error) {
	urlPath := "/search/topics"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("q", q)
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// searchTopicsHandleResponse handles the SearchTopics response.
func (client *GitHubV3RESTAPIClient) searchTopicsHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientSearchTopicsResponse, error) {
	result := GitHubV3RESTAPIClientSearchTopicsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Paths1Gazst8SearchTopicsGetResponses200ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientSearchTopicsResponse{}, err
	}
	return result, nil
}

// SearchUsers - Find users via various criteria. This method returns up to 100 results per page [https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination].
// When searching for users, you can get text match metadata for the issue login, public email, and name fields when you pass
// the text-match media type. For more details about highlighting search
// results, see Text match metadata [https://docs.github.com/rest/reference/search#text-match-metadata]. For more details
// about how to receive highlighted search results, see Text match metadata
// [https://docs.github.com/rest/reference/search#text-match-metadata].
// For example, if you're looking for a list of popular users, you might try this query:
// q=tom+repos:%3E42+followers:%3E1000
// This query searches for users with the name tom. The results are restricted to users with more than 42 repositories and
// over 1,000 followers.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - q - The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific
//     areas of GitHub. The REST API supports the same qualifiers as the web interface for
//     GitHub. To learn more about the format of the query, see Constructing a search query [https://docs.github.com/rest/reference/search#constructing-a-search-query].
//     See "Searching users
//     [https://docs.github.com/search-github/searching-on-github/searching-users]" for a detailed list of qualifiers.
//   - options - GitHubV3RESTAPIClientSearchUsersOptions contains the optional parameters for the GitHubV3RESTAPIClient.SearchUsers
//     method.
func (client *GitHubV3RESTAPIClient) SearchUsers(ctx context.Context, q string, options *GitHubV3RESTAPIClientSearchUsersOptions) (GitHubV3RESTAPIClientSearchUsersResponse, error) {
	req, err := client.searchUsersCreateRequest(ctx, q, options)
	if err != nil {
		return GitHubV3RESTAPIClientSearchUsersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientSearchUsersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnprocessableEntity, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientSearchUsersResponse{}, runtime.NewResponseError(resp)
	}
	return client.searchUsersHandleResponse(resp)
}

// searchUsersCreateRequest creates the SearchUsers request.
func (client *GitHubV3RESTAPIClient) searchUsersCreateRequest(ctx context.Context, q string, options *GitHubV3RESTAPIClientSearchUsersOptions) (*policy.Request, error) {
	urlPath := "/search/users"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("q", q)
	if options != nil && options.Sort != nil {
		reqQP.Set("sort", string(*options.Sort))
	}
	if client.order != nil {
		reqQP.Set("order", string(*client.order))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// searchUsersHandleResponse handles the SearchUsers response.
func (client *GitHubV3RESTAPIClient) searchUsersHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientSearchUsersResponse, error) {
	result := GitHubV3RESTAPIClientSearchUsersResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Paths8IoapxSearchUsersGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchUsersResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchUsersResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSearchUsersResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientSearchUsersResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// SecretScanningGetAlert - Gets a single secret scanning alert detected in an eligible repository. To use this endpoint,
// you must be an administrator for the repository or for the organization that owns the repository, and you
// must use a personal access token with the repo scope or securityevents scope. For public repositories, you may instead
// use the publicrepo scope.
// GitHub Apps must have the secretscanningalerts read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientSecretScanningGetAlertOptions contains the optional parameters for the GitHubV3RESTAPIClient.SecretScanningGetAlert
//     method.
func (client *GitHubV3RESTAPIClient) SecretScanningGetAlert(ctx context.Context, options *GitHubV3RESTAPIClientSecretScanningGetAlertOptions) (GitHubV3RESTAPIClientSecretScanningGetAlertResponse, error) {
	req, err := client.secretScanningGetAlertCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientSecretScanningGetAlertResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientSecretScanningGetAlertResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientSecretScanningGetAlertResponse{}, runtime.NewResponseError(resp)
	}
	return client.secretScanningGetAlertHandleResponse(resp)
}

// secretScanningGetAlertCreateRequest creates the SecretScanningGetAlert request.
func (client *GitHubV3RESTAPIClient) secretScanningGetAlertCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientSecretScanningGetAlertOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{alert_number}", url.PathEscape(strconv.FormatInt(int64(client.alertNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// secretScanningGetAlertHandleResponse handles the SecretScanningGetAlert response.
func (client *GitHubV3RESTAPIClient) secretScanningGetAlertHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientSecretScanningGetAlertResponse, error) {
	result := GitHubV3RESTAPIClientSecretScanningGetAlertResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val SecretScanningAlert
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSecretScanningGetAlertResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusNotFound:
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSecretScanningGetAlertResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientSecretScanningGetAlertResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// SecretScanningListAlertsForEnterprise - Lists secret scanning alerts for eligible repositories in an enterprise, from newest
// to oldest. To use this endpoint, you must be a member of the enterprise, and you must use an access token with the
// repo scope or security_events scope. Alerts are only returned for organizations in the enterprise for which you are an
// organization owner or a security manager
// [https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientSecretScanningListAlertsForEnterpriseOptions contains the optional parameters for the GitHubV3RESTAPIClient.SecretScanningListAlertsForEnterprise
//     method.
func (client *GitHubV3RESTAPIClient) SecretScanningListAlertsForEnterprise(ctx context.Context, options *GitHubV3RESTAPIClientSecretScanningListAlertsForEnterpriseOptions) (GitHubV3RESTAPIClientSecretScanningListAlertsForEnterpriseResponse, error) {
	req, err := client.secretScanningListAlertsForEnterpriseCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForEnterpriseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForEnterpriseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForEnterpriseResponse{}, runtime.NewResponseError(resp)
	}
	return client.secretScanningListAlertsForEnterpriseHandleResponse(resp)
}

// secretScanningListAlertsForEnterpriseCreateRequest creates the SecretScanningListAlertsForEnterprise request.
func (client *GitHubV3RESTAPIClient) secretScanningListAlertsForEnterpriseCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientSecretScanningListAlertsForEnterpriseOptions) (*policy.Request, error) {
	urlPath := "/enterprises/{enterprise}/secret-scanning/alerts"
	if client.enterprise == "" {
		return nil, errors.New("parameter client.enterprise cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{enterprise}", url.PathEscape(client.enterprise))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.state != nil {
		reqQP.Set("state", *client.state)
	}
	if client.secretType != nil {
		reqQP.Set("secret_type", *client.secretType)
	}
	if client.resolution != nil {
		reqQP.Set("resolution", *client.resolution)
	}
	if client.sortParam != nil {
		reqQP.Set("sort", string(*client.sortParam))
	}
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.before != nil {
		reqQP.Set("before", *client.before)
	}
	if client.after != nil {
		reqQP.Set("after", *client.after)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// secretScanningListAlertsForEnterpriseHandleResponse handles the SecretScanningListAlertsForEnterprise response.
func (client *GitHubV3RESTAPIClient) secretScanningListAlertsForEnterpriseHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientSecretScanningListAlertsForEnterpriseResponse, error) {
	result := GitHubV3RESTAPIClientSecretScanningListAlertsForEnterpriseResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*OrganizationSecretScanningAlert
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForEnterpriseResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForEnterpriseResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForEnterpriseResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientSecretScanningListAlertsForEnterpriseResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// SecretScanningListAlertsForOrg - Lists secret scanning alerts for eligible repositories in an organization, from newest
// to oldest. To use this endpoint, you must be an administrator or security manager for the organization, and you
// must use an access token with the repo scope or securityevents scope. For public repositories, you may instead use the
// publicrepo scope.
// GitHub Apps must have the secretscanningalerts read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientSecretScanningListAlertsForOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.SecretScanningListAlertsForOrg
//     method.
func (client *GitHubV3RESTAPIClient) SecretScanningListAlertsForOrg(ctx context.Context, options *GitHubV3RESTAPIClientSecretScanningListAlertsForOrgOptions) (GitHubV3RESTAPIClientSecretScanningListAlertsForOrgResponse, error) {
	req, err := client.secretScanningListAlertsForOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.secretScanningListAlertsForOrgHandleResponse(resp)
}

// secretScanningListAlertsForOrgCreateRequest creates the SecretScanningListAlertsForOrg request.
func (client *GitHubV3RESTAPIClient) secretScanningListAlertsForOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientSecretScanningListAlertsForOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/secret-scanning/alerts"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.state != nil {
		reqQP.Set("state", *client.state)
	}
	if client.secretType != nil {
		reqQP.Set("secret_type", *client.secretType)
	}
	if client.resolution != nil {
		reqQP.Set("resolution", *client.resolution)
	}
	if client.sortParam != nil {
		reqQP.Set("sort", string(*client.sortParam))
	}
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.before != nil {
		reqQP.Set("before", *client.before)
	}
	if client.after != nil {
		reqQP.Set("after", *client.after)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// secretScanningListAlertsForOrgHandleResponse handles the SecretScanningListAlertsForOrg response.
func (client *GitHubV3RESTAPIClient) secretScanningListAlertsForOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientSecretScanningListAlertsForOrgResponse, error) {
	result := GitHubV3RESTAPIClientSecretScanningListAlertsForOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*OrganizationSecretScanningAlert
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForOrgResponse{}, err
	}
	result.Value = val
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientSecretScanningListAlertsForOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// SecretScanningListAlertsForRepo - Lists secret scanning alerts for an eligible repository, from newest to oldest. To use
// this endpoint, you must be an administrator for the repository or for the organization that owns the repository,
// and you must use a personal access token with the repo scope or securityevents scope. For public repositories, you may
// instead use the publicrepo scope.
// GitHub Apps must have the secretscanningalerts read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientSecretScanningListAlertsForRepoOptions contains the optional parameters for the GitHubV3RESTAPIClient.SecretScanningListAlertsForRepo
//     method.
func (client *GitHubV3RESTAPIClient) SecretScanningListAlertsForRepo(ctx context.Context, options *GitHubV3RESTAPIClientSecretScanningListAlertsForRepoOptions) (GitHubV3RESTAPIClientSecretScanningListAlertsForRepoResponse, error) {
	req, err := client.secretScanningListAlertsForRepoCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForRepoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForRepoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForRepoResponse{}, runtime.NewResponseError(resp)
	}
	return client.secretScanningListAlertsForRepoHandleResponse(resp)
}

// secretScanningListAlertsForRepoCreateRequest creates the SecretScanningListAlertsForRepo request.
func (client *GitHubV3RESTAPIClient) secretScanningListAlertsForRepoCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientSecretScanningListAlertsForRepoOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/secret-scanning/alerts"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.state != nil {
		reqQP.Set("state", *client.state)
	}
	if client.secretType != nil {
		reqQP.Set("secret_type", *client.secretType)
	}
	if client.resolution != nil {
		reqQP.Set("resolution", *client.resolution)
	}
	if client.sortParam != nil {
		reqQP.Set("sort", string(*client.sortParam))
	}
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.before != nil {
		reqQP.Set("before", *client.before)
	}
	if client.after != nil {
		reqQP.Set("after", *client.after)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// secretScanningListAlertsForRepoHandleResponse handles the SecretScanningListAlertsForRepo response.
func (client *GitHubV3RESTAPIClient) secretScanningListAlertsForRepoHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientSecretScanningListAlertsForRepoResponse, error) {
	result := GitHubV3RESTAPIClientSecretScanningListAlertsForRepoResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*SecretScanningAlert
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForRepoResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSecretScanningListAlertsForRepoResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientSecretScanningListAlertsForRepoResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// SecretScanningListLocationsForAlert - Lists all locations for a given secret scanning alert for an eligible repository.
// To use this endpoint, you must be an administrator for the repository or for the organization that owns the
// repository, and you must use a personal access token with the repo scope or securityevents scope. For public repositories,
// you may instead use the publicrepo scope.
// GitHub Apps must have the secretscanningalerts read permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientSecretScanningListLocationsForAlertOptions contains the optional parameters for the GitHubV3RESTAPIClient.SecretScanningListLocationsForAlert
//     method.
func (client *GitHubV3RESTAPIClient) SecretScanningListLocationsForAlert(ctx context.Context, options *GitHubV3RESTAPIClientSecretScanningListLocationsForAlertOptions) (GitHubV3RESTAPIClientSecretScanningListLocationsForAlertResponse, error) {
	req, err := client.secretScanningListLocationsForAlertCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientSecretScanningListLocationsForAlertResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientSecretScanningListLocationsForAlertResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientSecretScanningListLocationsForAlertResponse{}, runtime.NewResponseError(resp)
	}
	return client.secretScanningListLocationsForAlertHandleResponse(resp)
}

// secretScanningListLocationsForAlertCreateRequest creates the SecretScanningListLocationsForAlert request.
func (client *GitHubV3RESTAPIClient) secretScanningListLocationsForAlertCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientSecretScanningListLocationsForAlertOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{alert_number}", url.PathEscape(strconv.FormatInt(int64(client.alertNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// secretScanningListLocationsForAlertHandleResponse handles the SecretScanningListLocationsForAlert response.
func (client *GitHubV3RESTAPIClient) secretScanningListLocationsForAlertHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientSecretScanningListLocationsForAlertResponse, error) {
	result := GitHubV3RESTAPIClientSecretScanningListLocationsForAlertResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*SecretScanningLocation
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSecretScanningListLocationsForAlertResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSecretScanningListLocationsForAlertResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientSecretScanningListLocationsForAlertResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// SecretScanningUpdateAlert - Updates the status of a secret scanning alert in an eligible repository. To use this endpoint,
// you must be an administrator for the repository or for the organization that owns the repository, and you
// must use a personal access token with the repo scope or securityevents scope. For public repositories, you may instead
// use the publicrepo scope.
// GitHub Apps must have the secretscanningalerts write permission to use this endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientSecretScanningUpdateAlertOptions contains the optional parameters for the GitHubV3RESTAPIClient.SecretScanningUpdateAlert
//     method.
func (client *GitHubV3RESTAPIClient) SecretScanningUpdateAlert(ctx context.Context, body Paths1Ofej2QReposOwnerRepoSecretScanningAlertsAlertNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientSecretScanningUpdateAlertOptions) (GitHubV3RESTAPIClientSecretScanningUpdateAlertResponse, error) {
	req, err := client.secretScanningUpdateAlertCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientSecretScanningUpdateAlertResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientSecretScanningUpdateAlertResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusNotFound, http.StatusUnprocessableEntity, http.StatusServiceUnavailable) {
		return GitHubV3RESTAPIClientSecretScanningUpdateAlertResponse{}, runtime.NewResponseError(resp)
	}
	return client.secretScanningUpdateAlertHandleResponse(resp)
}

// secretScanningUpdateAlertCreateRequest creates the SecretScanningUpdateAlert request.
func (client *GitHubV3RESTAPIClient) secretScanningUpdateAlertCreateRequest(ctx context.Context, body Paths1Ofej2QReposOwnerRepoSecretScanningAlertsAlertNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientSecretScanningUpdateAlertOptions) (*policy.Request, error) {
	urlPath := "/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	urlPath = strings.ReplaceAll(urlPath, "{alert_number}", url.PathEscape(strconv.FormatInt(int64(client.alertNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// secretScanningUpdateAlertHandleResponse handles the SecretScanningUpdateAlert response.
func (client *GitHubV3RESTAPIClient) secretScanningUpdateAlertHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientSecretScanningUpdateAlertResponse, error) {
	result := GitHubV3RESTAPIClientSecretScanningUpdateAlertResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val SecretScanningAlert
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSecretScanningUpdateAlertResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	case http.StatusNotFound:
	case http.StatusUnprocessableEntity:
	case http.StatusServiceUnavailable:
	var val Components103Lyo2ResponsesServiceUnavailableContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientSecretScanningUpdateAlertResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientSecretScanningUpdateAlertResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsAddMemberLegacy - The "Add team member" endpoint (described below) is deprecated.
// We recommend using the Add or update team membership for a user [https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user]
// endpoint instead. It allows you to invite new
// organization members to your teams.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see GitHub's products
// [https://docs.github.com/github/getting-started-with-github/githubs-products] in the GitHub Help documentation.
// To add someone to a team, the authenticated user must be an organization owner or a team maintainer in the team they're
// changing. The person being added to the team must be a member of the team's
// organization.
// Note: When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see
// an error if you attempt to use the API for making changes to the team's
// membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your
// identity provider, which automatically adds and removes team members in an
// organization. For more information, see "Synchronizing teams between your identity provider and GitHub [https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/]
// ."
// Note that you'll need to set Content-Length to zero when calling out to this endpoint. For more information, see "HTTP
// verbs
// [https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsAddMemberLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsAddMemberLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsAddMemberLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsAddMemberLegacyOptions) (GitHubV3RESTAPIClientTeamsAddMemberLegacyResponse, error) {
	req, err := client.teamsAddMemberLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsAddMemberLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsAddMemberLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientTeamsAddMemberLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsAddMemberLegacyHandleResponse(resp)
}

// teamsAddMemberLegacyCreateRequest creates the TeamsAddMemberLegacy request.
func (client *GitHubV3RESTAPIClient) teamsAddMemberLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsAddMemberLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/members/{username}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsAddMemberLegacyHandleResponse handles the TeamsAddMemberLegacy response.
func (client *GitHubV3RESTAPIClient) teamsAddMemberLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsAddMemberLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsAddMemberLegacyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientTeamsAddMemberLegacyResponse{}, err
	}
	return result, nil
}

// TeamsAddOrUpdateMembershipForUserInOrg - Adds an organization member to a team. An authenticated organization owner or
// team maintainer can add organization members to a team.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see GitHub's products
// [https://docs.github.com/github/getting-started-with-github/githubs-products] in the GitHub Help documentation.
// Note: When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see
// an error if you attempt to use the API for making changes to the team's
// membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your
// identity provider, which automatically adds and removes team members in an
// organization. For more information, see "Synchronizing teams between your identity provider and GitHub [https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/]
// ."
// An organization owner can add someone who is not part of the team's organization to a team. When an organization owner
// adds someone to a team who is not an organization member, this endpoint will send
// an invitation to the person via email. This newly-created membership will be in the "pending" state until the person accepts
// the invitation, at which point the membership will transition to the
// "active" state and the user will be added as a member of the team.
// If the user is already a member of the team, this endpoint will update the role of the team member's role. To update the
// membership of a team member, the authenticated user must be an organization
// owner or a team maintainer.
// Note: You can also specify a team by orgid and teamid using the route PUT /organizations/{orgid}/team/{teamid}/memberships/{username}.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsAddOrUpdateMembershipForUserInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsAddOrUpdateMembershipForUserInOrg(ctx context.Context, body Paths1X3ApmxOrgsOrgTeamsTeamSlugMembershipsUsernamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserInOrgOptions) (GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserInOrgResponse, error) {
	req, err := client.teamsAddOrUpdateMembershipForUserInOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsAddOrUpdateMembershipForUserInOrgHandleResponse(resp)
}

// teamsAddOrUpdateMembershipForUserInOrgCreateRequest creates the TeamsAddOrUpdateMembershipForUserInOrg request.
func (client *GitHubV3RESTAPIClient) teamsAddOrUpdateMembershipForUserInOrgCreateRequest(ctx context.Context, body Paths1X3ApmxOrgsOrgTeamsTeamSlugMembershipsUsernamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/memberships/{username}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// teamsAddOrUpdateMembershipForUserInOrgHandleResponse handles the TeamsAddOrUpdateMembershipForUserInOrg response.
func (client *GitHubV3RESTAPIClient) teamsAddOrUpdateMembershipForUserInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserInOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamMembership); err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserInOrgResponse{}, err
	}
	return result, nil
}

// TeamsAddOrUpdateMembershipForUserLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from
// the Teams API. We recommend migrating your existing code to use the new Add or update team membership for a user
// [https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user] endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see GitHub's products
// [https://docs.github.com/github/getting-started-with-github/githubs-products] in the GitHub Help documentation.
// If the user is already a member of the team's organization, this endpoint will add the user to the team. To add a membership
// between an organization member and a team, the authenticated user must be
// an organization owner or a team maintainer.
// Note: When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see
// an error if you attempt to use the API for making changes to the team's
// membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your
// identity provider, which automatically adds and removes team members in an
// organization. For more information, see "Synchronizing teams between your identity provider and GitHub [https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/]
// ."
// If the user is unaffiliated with the team's organization, this endpoint will send an invitation to the user via email.
// This newly-created membership will be in the "pending" state until the user
// accepts the invitation, at which point the membership will transition to the "active" state and the user will be added
// as a member of the team. To add a membership between an unaffiliated user and a
// team, the authenticated user must be an organization owner.
// If the user is already a member of the team, this endpoint will update the role of the team member's role. To update the
// membership of a team member, the authenticated user must be an organization
// owner or a team maintainer.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserLegacyOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.TeamsAddOrUpdateMembershipForUserLegacy method.
func (client *GitHubV3RESTAPIClient) TeamsAddOrUpdateMembershipForUserLegacy(ctx context.Context, body PathsXg2Jx3TeamsTeamIDMembershipsUsernamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserLegacyOptions) (GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserLegacyResponse, error) {
	req, err := client.teamsAddOrUpdateMembershipForUserLegacyCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsAddOrUpdateMembershipForUserLegacyHandleResponse(resp)
}

// teamsAddOrUpdateMembershipForUserLegacyCreateRequest creates the TeamsAddOrUpdateMembershipForUserLegacy request.
func (client *GitHubV3RESTAPIClient) teamsAddOrUpdateMembershipForUserLegacyCreateRequest(ctx context.Context, body PathsXg2Jx3TeamsTeamIDMembershipsUsernamePutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/memberships/{username}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// teamsAddOrUpdateMembershipForUserLegacyHandleResponse handles the TeamsAddOrUpdateMembershipForUserLegacy response.
func (client *GitHubV3RESTAPIClient) teamsAddOrUpdateMembershipForUserLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserLegacyResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val TeamMembership
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	default:
		return GitHubV3RESTAPIClientTeamsAddOrUpdateMembershipForUserLegacyResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsAddOrUpdateProjectPermissionsInOrg - Adds an organization project to a team. To add a project to a team or update
// the team's permission on a project, the authenticated user must have admin permissions for the project. The project and
// team must be part of the same organization.
// Note: You can also specify a team by orgid and teamid using the route PUT /organizations/{orgid}/team/{teamid}/projects/{project_id}.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsInOrgOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.TeamsAddOrUpdateProjectPermissionsInOrg method.
func (client *GitHubV3RESTAPIClient) TeamsAddOrUpdateProjectPermissionsInOrg(ctx context.Context, body Paths1T9ShtnOrgsOrgTeamsTeamSlugProjectsProjectIDPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsInOrgOptions) (GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsInOrgResponse, error) {
	req, err := client.teamsAddOrUpdateProjectPermissionsInOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusForbidden) {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsAddOrUpdateProjectPermissionsInOrgHandleResponse(resp)
}

// teamsAddOrUpdateProjectPermissionsInOrgCreateRequest creates the TeamsAddOrUpdateProjectPermissionsInOrg request.
func (client *GitHubV3RESTAPIClient) teamsAddOrUpdateProjectPermissionsInOrgCreateRequest(ctx context.Context, body Paths1T9ShtnOrgsOrgTeamsTeamSlugProjectsProjectIDPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/projects/{project_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{project_id}", url.PathEscape(strconv.FormatInt(int64(client.projectID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// teamsAddOrUpdateProjectPermissionsInOrgHandleResponse handles the TeamsAddOrUpdateProjectPermissionsInOrg response.
func (client *GitHubV3RESTAPIClient) teamsAddOrUpdateProjectPermissionsInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsInOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PathsJaryxdOrgsOrgTeamsTeamSlugProjectsProjectIDPutResponses403ContentApplicationJSONSchema); err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsInOrgResponse{}, err
	}
	return result, nil
}

// TeamsAddOrUpdateProjectPermissionsLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from
// the Teams API. We recommend migrating your existing code to use the new Add or update team project permissions
// [https://docs.github.com/rest/reference/teams#add-or-update-team-project-permissions] endpoint.
// Adds an organization project to a team. To add a project to a team or update the team's permission on a project, the authenticated
// user must have admin permissions for the project. The project and
// team must be part of the same organization.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsLegacyOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.TeamsAddOrUpdateProjectPermissionsLegacy method.
func (client *GitHubV3RESTAPIClient) TeamsAddOrUpdateProjectPermissionsLegacy(ctx context.Context, body Paths1S2Izb1TeamsTeamIDProjectsProjectIDPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsLegacyOptions) (GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsLegacyResponse, error) {
	req, err := client.teamsAddOrUpdateProjectPermissionsLegacyCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsAddOrUpdateProjectPermissionsLegacyHandleResponse(resp)
}

// teamsAddOrUpdateProjectPermissionsLegacyCreateRequest creates the TeamsAddOrUpdateProjectPermissionsLegacy request.
func (client *GitHubV3RESTAPIClient) teamsAddOrUpdateProjectPermissionsLegacyCreateRequest(ctx context.Context, body Paths1S2Izb1TeamsTeamIDProjectsProjectIDPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/projects/{project_id}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{project_id}", url.PathEscape(strconv.FormatInt(int64(client.projectID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// teamsAddOrUpdateProjectPermissionsLegacyHandleResponse handles the TeamsAddOrUpdateProjectPermissionsLegacy response.
func (client *GitHubV3RESTAPIClient) teamsAddOrUpdateProjectPermissionsLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsLegacyResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusForbidden:
	var val Paths8YxainTeamsTeamIDProjectsProjectIDPutResponses403ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsLegacyResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientTeamsAddOrUpdateProjectPermissionsLegacyResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsAddOrUpdateRepoPermissionsInOrg - To add a repository to a team or update the team's permission on a repository, the
// authenticated user must have admin access to the repository, and must be able to see the team. The repository must be
// owned by the organization, or a direct fork of a repository owned by the organization. You will get a 422 Unprocessable
// Entity status if you attempt to add a repository to a team that is not owned by
// the organization. Note that, if you choose not to pass any parameters, you'll need to set Content-Length to zero when calling
// out to this endpoint. For more information, see "HTTP verbs
// [https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs]."
// Note: You can also specify a team by orgid and teamid using the route PUT /organizations/{orgid}/team/{teamid}/repos/{owner}/{repo}.
// For more information about the permission levels, see "Repository permission levels for an organization
// [https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization]".
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsAddOrUpdateRepoPermissionsInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsAddOrUpdateRepoPermissionsInOrg(ctx context.Context, body PathsM2T5POrgsOrgTeamsTeamSlugReposOwnerRepoPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsInOrgOptions) (GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsInOrgResponse, error) {
	req, err := client.teamsAddOrUpdateRepoPermissionsInOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsInOrgResponse{}, nil
}

// teamsAddOrUpdateRepoPermissionsInOrgCreateRequest creates the TeamsAddOrUpdateRepoPermissionsInOrg request.
func (client *GitHubV3RESTAPIClient) teamsAddOrUpdateRepoPermissionsInOrgCreateRequest(ctx context.Context, body PathsM2T5POrgsOrgTeamsTeamSlugReposOwnerRepoPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// TeamsAddOrUpdateRepoPermissionsLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from
// the Teams API. We recommend migrating your existing code to use the new "Add or update team repository permissions
// [https://docs.github.com/rest/reference/teams#add-or-update-team-repository-permissions]" endpoint.
// To add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access
// to the repository, and must be able to see the team. The repository must be
// owned by the organization, or a direct fork of a repository owned by the organization. You will get a 422 Unprocessable
// Entity status if you attempt to add a repository to a team that is not owned by
// the organization.
// Note that, if you choose not to pass any parameters, you'll need to set Content-Length to zero when calling out to this
// endpoint. For more information, see "HTTP verbs
// [https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsAddOrUpdateRepoPermissionsLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsAddOrUpdateRepoPermissionsLegacy(ctx context.Context, body Paths1R8VmdaTeamsTeamIDReposOwnerRepoPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsLegacyOptions) (GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsLegacyResponse, error) {
	req, err := client.teamsAddOrUpdateRepoPermissionsLegacyCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsAddOrUpdateRepoPermissionsLegacyHandleResponse(resp)
}

// teamsAddOrUpdateRepoPermissionsLegacyCreateRequest creates the TeamsAddOrUpdateRepoPermissionsLegacy request.
func (client *GitHubV3RESTAPIClient) teamsAddOrUpdateRepoPermissionsLegacyCreateRequest(ctx context.Context, body Paths1R8VmdaTeamsTeamIDReposOwnerRepoPutRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/repos/{owner}/{repo}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// teamsAddOrUpdateRepoPermissionsLegacyHandleResponse handles the TeamsAddOrUpdateRepoPermissionsLegacy response.
func (client *GitHubV3RESTAPIClient) teamsAddOrUpdateRepoPermissionsLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsLegacyResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsLegacyResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientTeamsAddOrUpdateRepoPermissionsLegacyResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsCheckPermissionsForProjectInOrg - Checks whether a team has read, write, or admin permissions for an organization
// project. The response includes projects inherited from a parent team.
// Note: You can also specify a team by orgid and teamid using the route GET /organizations/{orgid}/team/{teamid}/projects/{project_id}.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsCheckPermissionsForProjectInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsCheckPermissionsForProjectInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectInOrgOptions) (GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectInOrgResponse, error) {
	req, err := client.teamsCheckPermissionsForProjectInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsCheckPermissionsForProjectInOrgHandleResponse(resp)
}

// teamsCheckPermissionsForProjectInOrgCreateRequest creates the TeamsCheckPermissionsForProjectInOrg request.
func (client *GitHubV3RESTAPIClient) teamsCheckPermissionsForProjectInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/projects/{project_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{project_id}", url.PathEscape(strconv.FormatInt(int64(client.projectID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsCheckPermissionsForProjectInOrgHandleResponse handles the TeamsCheckPermissionsForProjectInOrg response.
func (client *GitHubV3RESTAPIClient) teamsCheckPermissionsForProjectInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectInOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamProject); err != nil {
		return GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectInOrgResponse{}, err
	}
	return result, nil
}

// TeamsCheckPermissionsForProjectLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from
// the Teams API. We recommend migrating your existing code to use the new Check team permissions for a project
// [https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-project] endpoint.
// Checks whether a team has read, write, or admin permissions for an organization project. The response includes projects
// inherited from a parent team.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsCheckPermissionsForProjectLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsCheckPermissionsForProjectLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectLegacyOptions) (GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectLegacyResponse, error) {
	req, err := client.teamsCheckPermissionsForProjectLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsCheckPermissionsForProjectLegacyHandleResponse(resp)
}

// teamsCheckPermissionsForProjectLegacyCreateRequest creates the TeamsCheckPermissionsForProjectLegacy request.
func (client *GitHubV3RESTAPIClient) teamsCheckPermissionsForProjectLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/projects/{project_id}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{project_id}", url.PathEscape(strconv.FormatInt(int64(client.projectID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsCheckPermissionsForProjectLegacyHandleResponse handles the TeamsCheckPermissionsForProjectLegacy response.
func (client *GitHubV3RESTAPIClient) teamsCheckPermissionsForProjectLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectLegacyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamProject); err != nil {
		return GitHubV3RESTAPIClientTeamsCheckPermissionsForProjectLegacyResponse{}, err
	}
	return result, nil
}

// TeamsCheckPermissionsForRepoInOrg - Checks whether a team has admin, push, maintain, triage, or pull permission for a repository.
// Repositories inherited through a parent team will also be checked.
// You can also get information about the specified repository, including what permissions the team grants on it, by passing
// the following custom media type
// [https://docs.github.com/rest/overview/media-types/] via the application/vnd.github.v3.repository+json accept header.
// If a team doesn't have permission for the repository, you will receive a 404 Not Found response status.
// Note: You can also specify a team by orgid and teamid using the route GET /organizations/{orgid}/team/{teamid}/repos/{owner}/{repo}.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsCheckPermissionsForRepoInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsCheckPermissionsForRepoInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoInOrgOptions) (GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoInOrgResponse, error) {
	req, err := client.teamsCheckPermissionsForRepoInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsCheckPermissionsForRepoInOrgHandleResponse(resp)
}

// teamsCheckPermissionsForRepoInOrgCreateRequest creates the TeamsCheckPermissionsForRepoInOrg request.
func (client *GitHubV3RESTAPIClient) teamsCheckPermissionsForRepoInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsCheckPermissionsForRepoInOrgHandleResponse handles the TeamsCheckPermissionsForRepoInOrg response.
func (client *GitHubV3RESTAPIClient) teamsCheckPermissionsForRepoInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoInOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamRepository); err != nil {
		return GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoInOrgResponse{}, err
	}
	return result, nil
}

// TeamsCheckPermissionsForRepoLegacy - Note: Repositories inherited through a parent team will also be checked.
// Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your
// existing code to use the new Check team permissions for a repository
// [https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-repository] endpoint.
// You can also get information about the specified repository, including what permissions the team grants on it, by passing
// the following custom media type
// [https://docs.github.com/rest/overview/media-types/] via the Accept header:
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsCheckPermissionsForRepoLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsCheckPermissionsForRepoLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoLegacyOptions) (GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoLegacyResponse, error) {
	req, err := client.teamsCheckPermissionsForRepoLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsCheckPermissionsForRepoLegacyHandleResponse(resp)
}

// teamsCheckPermissionsForRepoLegacyCreateRequest creates the TeamsCheckPermissionsForRepoLegacy request.
func (client *GitHubV3RESTAPIClient) teamsCheckPermissionsForRepoLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/repos/{owner}/{repo}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsCheckPermissionsForRepoLegacyHandleResponse handles the TeamsCheckPermissionsForRepoLegacy response.
func (client *GitHubV3RESTAPIClient) teamsCheckPermissionsForRepoLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoLegacyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamRepository); err != nil {
		return GitHubV3RESTAPIClientTeamsCheckPermissionsForRepoLegacyResponse{}, err
	}
	return result, nil
}

// TeamsCreate - To create a team, the authenticated user must be a member or owner of {org}. By default, organization members
// can create teams. Organization owners can limit team creation to organization owners. For
// more information, see "Setting team creation permissions [https://docs.github.com/articles/setting-team-creation-permissions-in-your-organization]."
// When you create a new team, you automatically become a team maintainer without explicitly adding yourself to the optional
// array of maintainers. For more information, see "About teams
// [https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/about-teams]".
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsCreateOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsCreate
//     method.
func (client *GitHubV3RESTAPIClient) TeamsCreate(ctx context.Context, body PathsRn7NzwOrgsOrgTeamsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsCreateOptions) (GitHubV3RESTAPIClientTeamsCreateResponse, error) {
	req, err := client.teamsCreateCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCreateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCreateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusForbidden, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientTeamsCreateResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsCreateHandleResponse(resp)
}

// teamsCreateCreateRequest creates the TeamsCreate request.
func (client *GitHubV3RESTAPIClient) teamsCreateCreateRequest(ctx context.Context, body PathsRn7NzwOrgsOrgTeamsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsCreateOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// teamsCreateHandleResponse handles the TeamsCreate response.
func (client *GitHubV3RESTAPIClient) teamsCreateHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsCreateResponse, error) {
	result := GitHubV3RESTAPIClientTeamsCreateResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val TeamFull
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsCreateResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsCreateResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsCreateResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientTeamsCreateResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsCreateDiscussionCommentInOrg - Creates a new comment on a team discussion. OAuth access tokens require the write:discussion
// scope [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// Creating content too quickly using this endpoint may
// result in secondary rate limiting. See "Secondary rate limits [https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits]"
// and "Dealing with secondary rate limits
// [https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits]" for details.
// Note: You can also specify a team by orgid and teamid using the route POST /organizations/{orgid}/team/{teamid}/discussions/{discussion_number}/comments.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsCreateDiscussionCommentInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsCreateDiscussionCommentInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsCreateDiscussionCommentInOrg(ctx context.Context, body Paths168P3GeOrgsOrgTeamsTeamSlugDiscussionsDiscussionNumberCommentsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsCreateDiscussionCommentInOrgOptions) (GitHubV3RESTAPIClientTeamsCreateDiscussionCommentInOrgResponse, error) {
	req, err := client.teamsCreateDiscussionCommentInOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCreateDiscussionCommentInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCreateDiscussionCommentInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientTeamsCreateDiscussionCommentInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsCreateDiscussionCommentInOrgHandleResponse(resp)
}

// teamsCreateDiscussionCommentInOrgCreateRequest creates the TeamsCreateDiscussionCommentInOrg request.
func (client *GitHubV3RESTAPIClient) teamsCreateDiscussionCommentInOrgCreateRequest(ctx context.Context, body Paths168P3GeOrgsOrgTeamsTeamSlugDiscussionsDiscussionNumberCommentsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsCreateDiscussionCommentInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// teamsCreateDiscussionCommentInOrgHandleResponse handles the TeamsCreateDiscussionCommentInOrg response.
func (client *GitHubV3RESTAPIClient) teamsCreateDiscussionCommentInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsCreateDiscussionCommentInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsCreateDiscussionCommentInOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamDiscussionComment); err != nil {
		return GitHubV3RESTAPIClientTeamsCreateDiscussionCommentInOrgResponse{}, err
	}
	return result, nil
}

// TeamsCreateDiscussionCommentLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the
// Teams API. We recommend migrating your existing code to use the new Create a discussion comment
// [https://docs.github.com/rest/reference/teams#create-a-discussion-comment] endpoint.
// Creates a new comment on a team discussion. OAuth access tokens require the write:discussion scope [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// Creating content too quickly using this endpoint may
// result in secondary rate limiting. See "Secondary rate limits [https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits]"
// and "Dealing with secondary rate limits
// [https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits]" for details.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsCreateDiscussionCommentLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsCreateDiscussionCommentLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsCreateDiscussionCommentLegacy(ctx context.Context, body PathsNdspgnTeamsTeamIDDiscussionsDiscussionNumberCommentsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsCreateDiscussionCommentLegacyOptions) (GitHubV3RESTAPIClientTeamsCreateDiscussionCommentLegacyResponse, error) {
	req, err := client.teamsCreateDiscussionCommentLegacyCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCreateDiscussionCommentLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCreateDiscussionCommentLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientTeamsCreateDiscussionCommentLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsCreateDiscussionCommentLegacyHandleResponse(resp)
}

// teamsCreateDiscussionCommentLegacyCreateRequest creates the TeamsCreateDiscussionCommentLegacy request.
func (client *GitHubV3RESTAPIClient) teamsCreateDiscussionCommentLegacyCreateRequest(ctx context.Context, body PathsNdspgnTeamsTeamIDDiscussionsDiscussionNumberCommentsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsCreateDiscussionCommentLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/discussions/{discussion_number}/comments"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// teamsCreateDiscussionCommentLegacyHandleResponse handles the TeamsCreateDiscussionCommentLegacy response.
func (client *GitHubV3RESTAPIClient) teamsCreateDiscussionCommentLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsCreateDiscussionCommentLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsCreateDiscussionCommentLegacyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamDiscussionComment); err != nil {
		return GitHubV3RESTAPIClientTeamsCreateDiscussionCommentLegacyResponse{}, err
	}
	return result, nil
}

// TeamsCreateDiscussionInOrg - Creates a new discussion post on a team's page. OAuth access tokens require the write:discussion
// scope [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// Creating content too quickly using this endpoint may
// result in secondary rate limiting. See "Secondary rate limits [https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits]"
// and "Dealing with secondary rate limits
// [https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits]" for details.
// Note: You can also specify a team by orgid and teamid using the route POST /organizations/{orgid}/team/{teamid}/discussions.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsCreateDiscussionInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsCreateDiscussionInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsCreateDiscussionInOrg(ctx context.Context, body Paths58Csm6OrgsOrgTeamsTeamSlugDiscussionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsCreateDiscussionInOrgOptions) (GitHubV3RESTAPIClientTeamsCreateDiscussionInOrgResponse, error) {
	req, err := client.teamsCreateDiscussionInOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCreateDiscussionInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCreateDiscussionInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientTeamsCreateDiscussionInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsCreateDiscussionInOrgHandleResponse(resp)
}

// teamsCreateDiscussionInOrgCreateRequest creates the TeamsCreateDiscussionInOrg request.
func (client *GitHubV3RESTAPIClient) teamsCreateDiscussionInOrgCreateRequest(ctx context.Context, body Paths58Csm6OrgsOrgTeamsTeamSlugDiscussionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsCreateDiscussionInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/discussions"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// teamsCreateDiscussionInOrgHandleResponse handles the TeamsCreateDiscussionInOrg response.
func (client *GitHubV3RESTAPIClient) teamsCreateDiscussionInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsCreateDiscussionInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsCreateDiscussionInOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamDiscussion); err != nil {
		return GitHubV3RESTAPIClientTeamsCreateDiscussionInOrgResponse{}, err
	}
	return result, nil
}

// TeamsCreateDiscussionLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams
// API. We recommend migrating your existing code to use the new Create a discussion
// [https://docs.github.com/rest/reference/teams#create-a-discussion] endpoint.
// Creates a new discussion post on a team's page. OAuth access tokens require the write:discussion scope [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// This endpoint triggers notifications [https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications].
// Creating content too quickly using this endpoint may
// result in secondary rate limiting. See "Secondary rate limits [https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits]"
// and "Dealing with secondary rate limits
// [https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits]" for details.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsCreateDiscussionLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsCreateDiscussionLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsCreateDiscussionLegacy(ctx context.Context, body Paths1Ixczi0TeamsTeamIDDiscussionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsCreateDiscussionLegacyOptions) (GitHubV3RESTAPIClientTeamsCreateDiscussionLegacyResponse, error) {
	req, err := client.teamsCreateDiscussionLegacyCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCreateDiscussionLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsCreateDiscussionLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return GitHubV3RESTAPIClientTeamsCreateDiscussionLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsCreateDiscussionLegacyHandleResponse(resp)
}

// teamsCreateDiscussionLegacyCreateRequest creates the TeamsCreateDiscussionLegacy request.
func (client *GitHubV3RESTAPIClient) teamsCreateDiscussionLegacyCreateRequest(ctx context.Context, body Paths1Ixczi0TeamsTeamIDDiscussionsPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsCreateDiscussionLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/discussions"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// teamsCreateDiscussionLegacyHandleResponse handles the TeamsCreateDiscussionLegacy response.
func (client *GitHubV3RESTAPIClient) teamsCreateDiscussionLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsCreateDiscussionLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsCreateDiscussionLegacyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamDiscussion); err != nil {
		return GitHubV3RESTAPIClientTeamsCreateDiscussionLegacyResponse{}, err
	}
	return result, nil
}

// TeamsDeleteDiscussionCommentInOrg - Deletes a comment on a team discussion. OAuth access tokens require the write:discussion
// scope [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// Note: You can also specify a team by orgid and teamid using the route DELETE /organizations/{orgid}/team/{teamid}/discussions/{discussionnumber}/comments/{commentnumber}.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsDeleteDiscussionCommentInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsDeleteDiscussionCommentInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsDeleteDiscussionCommentInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsDeleteDiscussionCommentInOrgOptions) (GitHubV3RESTAPIClientTeamsDeleteDiscussionCommentInOrgResponse, error) {
	req, err := client.teamsDeleteDiscussionCommentInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsDeleteDiscussionCommentInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsDeleteDiscussionCommentInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientTeamsDeleteDiscussionCommentInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientTeamsDeleteDiscussionCommentInOrgResponse{}, nil
}

// teamsDeleteDiscussionCommentInOrgCreateRequest creates the TeamsDeleteDiscussionCommentInOrg request.
func (client *GitHubV3RESTAPIClient) teamsDeleteDiscussionCommentInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsDeleteDiscussionCommentInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{comment_number}", url.PathEscape(strconv.FormatInt(int64(client.commentNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// TeamsDeleteDiscussionCommentLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the
// Teams API. We recommend migrating your existing code to use the new Delete a discussion comment
// [https://docs.github.com/rest/reference/teams#delete-a-discussion-comment] endpoint.
// Deletes a comment on a team discussion. OAuth access tokens require the write:discussion scope [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsDeleteDiscussionCommentLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsDeleteDiscussionCommentLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsDeleteDiscussionCommentLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsDeleteDiscussionCommentLegacyOptions) (GitHubV3RESTAPIClientTeamsDeleteDiscussionCommentLegacyResponse, error) {
	req, err := client.teamsDeleteDiscussionCommentLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsDeleteDiscussionCommentLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsDeleteDiscussionCommentLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientTeamsDeleteDiscussionCommentLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientTeamsDeleteDiscussionCommentLegacyResponse{}, nil
}

// teamsDeleteDiscussionCommentLegacyCreateRequest creates the TeamsDeleteDiscussionCommentLegacy request.
func (client *GitHubV3RESTAPIClient) teamsDeleteDiscussionCommentLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsDeleteDiscussionCommentLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{comment_number}", url.PathEscape(strconv.FormatInt(int64(client.commentNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// TeamsDeleteDiscussionInOrg - Delete a discussion from a team's page. OAuth access tokens require the write:discussion scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// Note: You can also specify a team by orgid and teamid using the route DELETE /organizations/{orgid}/team/{teamid}/discussions/{discussion_number}.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsDeleteDiscussionInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsDeleteDiscussionInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsDeleteDiscussionInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsDeleteDiscussionInOrgOptions) (GitHubV3RESTAPIClientTeamsDeleteDiscussionInOrgResponse, error) {
	req, err := client.teamsDeleteDiscussionInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsDeleteDiscussionInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsDeleteDiscussionInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientTeamsDeleteDiscussionInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientTeamsDeleteDiscussionInOrgResponse{}, nil
}

// teamsDeleteDiscussionInOrgCreateRequest creates the TeamsDeleteDiscussionInOrg request.
func (client *GitHubV3RESTAPIClient) teamsDeleteDiscussionInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsDeleteDiscussionInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// TeamsDeleteDiscussionLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams
// API. We recommend migrating your existing code to use the new Delete a discussion
// [https://docs.github.com/rest/reference/teams#delete-a-discussion] endpoint.
// Delete a discussion from a team's page. OAuth access tokens require the write:discussion scope [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsDeleteDiscussionLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsDeleteDiscussionLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsDeleteDiscussionLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsDeleteDiscussionLegacyOptions) (GitHubV3RESTAPIClientTeamsDeleteDiscussionLegacyResponse, error) {
	req, err := client.teamsDeleteDiscussionLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsDeleteDiscussionLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsDeleteDiscussionLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientTeamsDeleteDiscussionLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientTeamsDeleteDiscussionLegacyResponse{}, nil
}

// teamsDeleteDiscussionLegacyCreateRequest creates the TeamsDeleteDiscussionLegacy request.
func (client *GitHubV3RESTAPIClient) teamsDeleteDiscussionLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsDeleteDiscussionLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/discussions/{discussion_number}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// TeamsDeleteInOrg - To delete a team, the authenticated user must be an organization owner or team maintainer.
// If you are an organization owner, deleting a parent team will delete all of its child teams as well.
// Note: You can also specify a team by orgid and teamid using the route DELETE /organizations/{orgid}/team/{teamid}.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsDeleteInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsDeleteInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsDeleteInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsDeleteInOrgOptions) (GitHubV3RESTAPIClientTeamsDeleteInOrgResponse, error) {
	req, err := client.teamsDeleteInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsDeleteInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsDeleteInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientTeamsDeleteInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientTeamsDeleteInOrgResponse{}, nil
}

// teamsDeleteInOrgCreateRequest creates the TeamsDeleteInOrg request.
func (client *GitHubV3RESTAPIClient) teamsDeleteInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsDeleteInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// TeamsDeleteLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams API. We recommend
// migrating your existing code to use the new Delete a team
// [https://docs.github.com/rest/reference/teams#delete-a-team] endpoint.
// To delete a team, the authenticated user must be an organization owner or team maintainer.
// If you are an organization owner, deleting a parent team will delete all of its child teams as well.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsDeleteLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsDeleteLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsDeleteLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsDeleteLegacyOptions) (GitHubV3RESTAPIClientTeamsDeleteLegacyResponse, error) {
	req, err := client.teamsDeleteLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsDeleteLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsDeleteLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientTeamsDeleteLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsDeleteLegacyHandleResponse(resp)
}

// teamsDeleteLegacyCreateRequest creates the TeamsDeleteLegacy request.
func (client *GitHubV3RESTAPIClient) teamsDeleteLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsDeleteLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsDeleteLegacyHandleResponse handles the TeamsDeleteLegacy response.
func (client *GitHubV3RESTAPIClient) teamsDeleteLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsDeleteLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsDeleteLegacyResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsDeleteLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsDeleteLegacyResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientTeamsDeleteLegacyResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsGetByName - Gets a team using the team's slug. GitHub generates the slug from the team name.
// Note: You can also specify a team by orgid and teamid using the route GET /organizations/{orgid}/team/{teamid}.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsGetByNameOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsGetByName
//     method.
func (client *GitHubV3RESTAPIClient) TeamsGetByName(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetByNameOptions) (GitHubV3RESTAPIClientTeamsGetByNameResponse, error) {
	req, err := client.teamsGetByNameCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetByNameResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetByNameResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientTeamsGetByNameResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsGetByNameHandleResponse(resp)
}

// teamsGetByNameCreateRequest creates the TeamsGetByName request.
func (client *GitHubV3RESTAPIClient) teamsGetByNameCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetByNameOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsGetByNameHandleResponse handles the TeamsGetByName response.
func (client *GitHubV3RESTAPIClient) teamsGetByNameHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsGetByNameResponse, error) {
	result := GitHubV3RESTAPIClientTeamsGetByNameResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val TeamFull
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsGetByNameResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsGetByNameResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientTeamsGetByNameResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsGetDiscussionCommentInOrg - Get a specific comment on a team discussion. OAuth access tokens require the read:discussion
// scope [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// Note: You can also specify a team by orgid and teamid using the route GET /organizations/{orgid}/team/{teamid}/discussions/{discussionnumber}/comments/{commentnumber}.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsGetDiscussionCommentInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsGetDiscussionCommentInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsGetDiscussionCommentInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetDiscussionCommentInOrgOptions) (GitHubV3RESTAPIClientTeamsGetDiscussionCommentInOrgResponse, error) {
	req, err := client.teamsGetDiscussionCommentInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetDiscussionCommentInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetDiscussionCommentInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsGetDiscussionCommentInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsGetDiscussionCommentInOrgHandleResponse(resp)
}

// teamsGetDiscussionCommentInOrgCreateRequest creates the TeamsGetDiscussionCommentInOrg request.
func (client *GitHubV3RESTAPIClient) teamsGetDiscussionCommentInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetDiscussionCommentInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{comment_number}", url.PathEscape(strconv.FormatInt(int64(client.commentNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsGetDiscussionCommentInOrgHandleResponse handles the TeamsGetDiscussionCommentInOrg response.
func (client *GitHubV3RESTAPIClient) teamsGetDiscussionCommentInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsGetDiscussionCommentInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsGetDiscussionCommentInOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamDiscussionComment); err != nil {
		return GitHubV3RESTAPIClientTeamsGetDiscussionCommentInOrgResponse{}, err
	}
	return result, nil
}

// TeamsGetDiscussionCommentLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams
// API. We recommend migrating your existing code to use the new Get a discussion comment
// [https://docs.github.com/rest/reference/teams#get-a-discussion-comment] endpoint.
// Get a specific comment on a team discussion. OAuth access tokens require the read:discussion scope [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsGetDiscussionCommentLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsGetDiscussionCommentLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsGetDiscussionCommentLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetDiscussionCommentLegacyOptions) (GitHubV3RESTAPIClientTeamsGetDiscussionCommentLegacyResponse, error) {
	req, err := client.teamsGetDiscussionCommentLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetDiscussionCommentLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetDiscussionCommentLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsGetDiscussionCommentLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsGetDiscussionCommentLegacyHandleResponse(resp)
}

// teamsGetDiscussionCommentLegacyCreateRequest creates the TeamsGetDiscussionCommentLegacy request.
func (client *GitHubV3RESTAPIClient) teamsGetDiscussionCommentLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetDiscussionCommentLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{comment_number}", url.PathEscape(strconv.FormatInt(int64(client.commentNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsGetDiscussionCommentLegacyHandleResponse handles the TeamsGetDiscussionCommentLegacy response.
func (client *GitHubV3RESTAPIClient) teamsGetDiscussionCommentLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsGetDiscussionCommentLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsGetDiscussionCommentLegacyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamDiscussionComment); err != nil {
		return GitHubV3RESTAPIClientTeamsGetDiscussionCommentLegacyResponse{}, err
	}
	return result, nil
}

// TeamsGetDiscussionInOrg - Get a specific discussion on a team's page. OAuth access tokens require the read:discussion scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// Note: You can also specify a team by orgid and teamid using the route GET /organizations/{orgid}/team/{teamid}/discussions/{discussion_number}.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsGetDiscussionInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsGetDiscussionInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsGetDiscussionInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetDiscussionInOrgOptions) (GitHubV3RESTAPIClientTeamsGetDiscussionInOrgResponse, error) {
	req, err := client.teamsGetDiscussionInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetDiscussionInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetDiscussionInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsGetDiscussionInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsGetDiscussionInOrgHandleResponse(resp)
}

// teamsGetDiscussionInOrgCreateRequest creates the TeamsGetDiscussionInOrg request.
func (client *GitHubV3RESTAPIClient) teamsGetDiscussionInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetDiscussionInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsGetDiscussionInOrgHandleResponse handles the TeamsGetDiscussionInOrg response.
func (client *GitHubV3RESTAPIClient) teamsGetDiscussionInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsGetDiscussionInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsGetDiscussionInOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamDiscussion); err != nil {
		return GitHubV3RESTAPIClientTeamsGetDiscussionInOrgResponse{}, err
	}
	return result, nil
}

// TeamsGetDiscussionLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new Get a discussion
// [https://docs.github.com/rest/reference/teams#get-a-discussion] endpoint.
// Get a specific discussion on a team's page. OAuth access tokens require the read:discussion scope [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsGetDiscussionLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsGetDiscussionLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsGetDiscussionLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetDiscussionLegacyOptions) (GitHubV3RESTAPIClientTeamsGetDiscussionLegacyResponse, error) {
	req, err := client.teamsGetDiscussionLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetDiscussionLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetDiscussionLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsGetDiscussionLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsGetDiscussionLegacyHandleResponse(resp)
}

// teamsGetDiscussionLegacyCreateRequest creates the TeamsGetDiscussionLegacy request.
func (client *GitHubV3RESTAPIClient) teamsGetDiscussionLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetDiscussionLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/discussions/{discussion_number}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsGetDiscussionLegacyHandleResponse handles the TeamsGetDiscussionLegacy response.
func (client *GitHubV3RESTAPIClient) teamsGetDiscussionLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsGetDiscussionLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsGetDiscussionLegacyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamDiscussion); err != nil {
		return GitHubV3RESTAPIClientTeamsGetDiscussionLegacyResponse{}, err
	}
	return result, nil
}

// TeamsGetLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams API. We recommend
// migrating your existing code to use the Get a team by name
// [https://docs.github.com/rest/reference/teams#get-a-team-by-name] endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsGetLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsGetLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsGetLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetLegacyOptions) (GitHubV3RESTAPIClientTeamsGetLegacyResponse, error) {
	req, err := client.teamsGetLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientTeamsGetLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsGetLegacyHandleResponse(resp)
}

// teamsGetLegacyCreateRequest creates the TeamsGetLegacy request.
func (client *GitHubV3RESTAPIClient) teamsGetLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsGetLegacyHandleResponse handles the TeamsGetLegacy response.
func (client *GitHubV3RESTAPIClient) teamsGetLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsGetLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsGetLegacyResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val TeamFull
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsGetLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsGetLegacyResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientTeamsGetLegacyResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsGetMemberLegacy - The "Get team member" endpoint (described below) is deprecated.
// We recommend using the Get team membership for a user [https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user]
// endpoint instead. It allows you to get both active and pending
// memberships.
// To list members in a team, the team must be visible to the authenticated user.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsGetMemberLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsGetMemberLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsGetMemberLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetMemberLegacyOptions) (GitHubV3RESTAPIClientTeamsGetMemberLegacyResponse, error) {
	req, err := client.teamsGetMemberLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetMemberLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetMemberLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientTeamsGetMemberLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientTeamsGetMemberLegacyResponse{}, nil
}

// teamsGetMemberLegacyCreateRequest creates the TeamsGetMemberLegacy request.
func (client *GitHubV3RESTAPIClient) teamsGetMemberLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetMemberLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/members/{username}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// TeamsGetMembershipForUserInOrg - Team members will include the members of child teams.
// To get a user's membership with a team, the team must be visible to the authenticated user.
// Note: You can also specify a team by orgid and teamid using the route GET /organizations/{orgid}/team/{teamid}/memberships/{username}.
// Note:The response contains the state of the membership and the member's role.
// The role for organization owners is set to maintainer. For more information about maintainer roles, see see Create a team
// [https://docs.github.com/rest/reference/teams#create-a-team].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsGetMembershipForUserInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsGetMembershipForUserInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsGetMembershipForUserInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetMembershipForUserInOrgOptions) (GitHubV3RESTAPIClientTeamsGetMembershipForUserInOrgResponse, error) {
	req, err := client.teamsGetMembershipForUserInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetMembershipForUserInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetMembershipForUserInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientTeamsGetMembershipForUserInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsGetMembershipForUserInOrgHandleResponse(resp)
}

// teamsGetMembershipForUserInOrgCreateRequest creates the TeamsGetMembershipForUserInOrg request.
func (client *GitHubV3RESTAPIClient) teamsGetMembershipForUserInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetMembershipForUserInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/memberships/{username}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsGetMembershipForUserInOrgHandleResponse handles the TeamsGetMembershipForUserInOrg response.
func (client *GitHubV3RESTAPIClient) teamsGetMembershipForUserInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsGetMembershipForUserInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsGetMembershipForUserInOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamMembership); err != nil {
		return GitHubV3RESTAPIClientTeamsGetMembershipForUserInOrgResponse{}, err
	}
	return result, nil
}

// TeamsGetMembershipForUserLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams
// API. We recommend migrating your existing code to use the new Get team membership for a user
// [https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user] endpoint.
// Team members will include the members of child teams.
// To get a user's membership with a team, the team must be visible to the authenticated user.
// Note:The response contains the state of the membership and the member's role.
// The role for organization owners is set to maintainer. For more information about maintainer roles, see Create a team [https://docs.github.com/rest/reference/teams#create-a-team].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsGetMembershipForUserLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsGetMembershipForUserLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsGetMembershipForUserLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetMembershipForUserLegacyOptions) (GitHubV3RESTAPIClientTeamsGetMembershipForUserLegacyResponse, error) {
	req, err := client.teamsGetMembershipForUserLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetMembershipForUserLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsGetMembershipForUserLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientTeamsGetMembershipForUserLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsGetMembershipForUserLegacyHandleResponse(resp)
}

// teamsGetMembershipForUserLegacyCreateRequest creates the TeamsGetMembershipForUserLegacy request.
func (client *GitHubV3RESTAPIClient) teamsGetMembershipForUserLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsGetMembershipForUserLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/memberships/{username}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsGetMembershipForUserLegacyHandleResponse handles the TeamsGetMembershipForUserLegacy response.
func (client *GitHubV3RESTAPIClient) teamsGetMembershipForUserLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsGetMembershipForUserLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsGetMembershipForUserLegacyResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val TeamMembership
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsGetMembershipForUserLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsGetMembershipForUserLegacyResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientTeamsGetMembershipForUserLegacyResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsList - Lists all teams in an organization that are visible to the authenticated user.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsListOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsList
//     method.
func (client *GitHubV3RESTAPIClient) TeamsList(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListOptions) (GitHubV3RESTAPIClientTeamsListResponse, error) {
	req, err := client.teamsListCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden) {
		return GitHubV3RESTAPIClientTeamsListResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsListHandleResponse(resp)
}

// teamsListCreateRequest creates the TeamsList request.
func (client *GitHubV3RESTAPIClient) teamsListCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsListHandleResponse handles the TeamsList response.
func (client *GitHubV3RESTAPIClient) teamsListHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsListResponse, error) {
	result := GitHubV3RESTAPIClientTeamsListResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Team
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsListResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsListResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientTeamsListResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsListChildInOrg - Lists the child teams of the team specified by {team_slug}.
// Note: You can also specify a team by orgid and teamid using the route GET /organizations/{orgid}/team/{teamid}/teams.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsListChildInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsListChildInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsListChildInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListChildInOrgOptions) (GitHubV3RESTAPIClientTeamsListChildInOrgResponse, error) {
	req, err := client.teamsListChildInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListChildInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListChildInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsListChildInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsListChildInOrgHandleResponse(resp)
}

// teamsListChildInOrgCreateRequest creates the TeamsListChildInOrg request.
func (client *GitHubV3RESTAPIClient) teamsListChildInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListChildInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/teams"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsListChildInOrgHandleResponse handles the TeamsListChildInOrg response.
func (client *GitHubV3RESTAPIClient) teamsListChildInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsListChildInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsListChildInOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamArray); err != nil {
		return GitHubV3RESTAPIClientTeamsListChildInOrgResponse{}, err
	}
	return result, nil
}

// TeamsListChildLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams API. We
// recommend migrating your existing code to use the new List child teams
// [https://docs.github.com/rest/reference/teams#list-child-teams] endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsListChildLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsListChildLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsListChildLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListChildLegacyOptions) (GitHubV3RESTAPIClientTeamsListChildLegacyResponse, error) {
	req, err := client.teamsListChildLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListChildLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListChildLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientTeamsListChildLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsListChildLegacyHandleResponse(resp)
}

// teamsListChildLegacyCreateRequest creates the TeamsListChildLegacy request.
func (client *GitHubV3RESTAPIClient) teamsListChildLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListChildLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/teams"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsListChildLegacyHandleResponse handles the TeamsListChildLegacy response.
func (client *GitHubV3RESTAPIClient) teamsListChildLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsListChildLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsListChildLegacyResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Team
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsListChildLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsListChildLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsListChildLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsListChildLegacyResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientTeamsListChildLegacyResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsListDiscussionCommentsInOrg - List all comments on a team discussion. OAuth access tokens require the read:discussion
// scope [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// Note: You can also specify a team by orgid and teamid using the route GET /organizations/{orgid}/team/{teamid}/discussions/{discussion_number}/comments.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsListDiscussionCommentsInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsListDiscussionCommentsInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsListDiscussionCommentsInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListDiscussionCommentsInOrgOptions) (GitHubV3RESTAPIClientTeamsListDiscussionCommentsInOrgResponse, error) {
	req, err := client.teamsListDiscussionCommentsInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListDiscussionCommentsInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListDiscussionCommentsInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsListDiscussionCommentsInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsListDiscussionCommentsInOrgHandleResponse(resp)
}

// teamsListDiscussionCommentsInOrgCreateRequest creates the TeamsListDiscussionCommentsInOrg request.
func (client *GitHubV3RESTAPIClient) teamsListDiscussionCommentsInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListDiscussionCommentsInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsListDiscussionCommentsInOrgHandleResponse handles the TeamsListDiscussionCommentsInOrg response.
func (client *GitHubV3RESTAPIClient) teamsListDiscussionCommentsInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsListDiscussionCommentsInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsListDiscussionCommentsInOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamDiscussionCommentArray); err != nil {
		return GitHubV3RESTAPIClientTeamsListDiscussionCommentsInOrgResponse{}, err
	}
	return result, nil
}

// TeamsListDiscussionCommentsLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the
// Teams API. We recommend migrating your existing code to use the new List discussion comments
// [https://docs.github.com/rest/reference/teams#list-discussion-comments] endpoint.
// List all comments on a team discussion. OAuth access tokens require the read:discussion scope [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsListDiscussionCommentsLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsListDiscussionCommentsLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsListDiscussionCommentsLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListDiscussionCommentsLegacyOptions) (GitHubV3RESTAPIClientTeamsListDiscussionCommentsLegacyResponse, error) {
	req, err := client.teamsListDiscussionCommentsLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListDiscussionCommentsLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListDiscussionCommentsLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsListDiscussionCommentsLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsListDiscussionCommentsLegacyHandleResponse(resp)
}

// teamsListDiscussionCommentsLegacyCreateRequest creates the TeamsListDiscussionCommentsLegacy request.
func (client *GitHubV3RESTAPIClient) teamsListDiscussionCommentsLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListDiscussionCommentsLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/discussions/{discussion_number}/comments"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsListDiscussionCommentsLegacyHandleResponse handles the TeamsListDiscussionCommentsLegacy response.
func (client *GitHubV3RESTAPIClient) teamsListDiscussionCommentsLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsListDiscussionCommentsLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsListDiscussionCommentsLegacyResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamDiscussionCommentArray); err != nil {
		return GitHubV3RESTAPIClientTeamsListDiscussionCommentsLegacyResponse{}, err
	}
	return result, nil
}

// TeamsListDiscussionsInOrg - List all discussions on a team's page. OAuth access tokens require the read:discussion scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// Note: You can also specify a team by orgid and teamid using the route GET /organizations/{orgid}/team/{teamid}/discussions.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsListDiscussionsInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsListDiscussionsInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsListDiscussionsInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListDiscussionsInOrgOptions) (GitHubV3RESTAPIClientTeamsListDiscussionsInOrgResponse, error) {
	req, err := client.teamsListDiscussionsInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListDiscussionsInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListDiscussionsInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsListDiscussionsInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsListDiscussionsInOrgHandleResponse(resp)
}

// teamsListDiscussionsInOrgCreateRequest creates the TeamsListDiscussionsInOrg request.
func (client *GitHubV3RESTAPIClient) teamsListDiscussionsInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListDiscussionsInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/discussions"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	if options != nil && options.Pinned != nil {
		reqQP.Set("pinned", *options.Pinned)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsListDiscussionsInOrgHandleResponse handles the TeamsListDiscussionsInOrg response.
func (client *GitHubV3RESTAPIClient) teamsListDiscussionsInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsListDiscussionsInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsListDiscussionsInOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamDiscussionArray); err != nil {
		return GitHubV3RESTAPIClientTeamsListDiscussionsInOrgResponse{}, err
	}
	return result, nil
}

// TeamsListDiscussionsLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new List discussions
// [https://docs.github.com/rest/reference/teams#list-discussions] endpoint.
// List all discussions on a team's page. OAuth access tokens require the read:discussion scope [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsListDiscussionsLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsListDiscussionsLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsListDiscussionsLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListDiscussionsLegacyOptions) (GitHubV3RESTAPIClientTeamsListDiscussionsLegacyResponse, error) {
	req, err := client.teamsListDiscussionsLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListDiscussionsLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListDiscussionsLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsListDiscussionsLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsListDiscussionsLegacyHandleResponse(resp)
}

// teamsListDiscussionsLegacyCreateRequest creates the TeamsListDiscussionsLegacy request.
func (client *GitHubV3RESTAPIClient) teamsListDiscussionsLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListDiscussionsLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/discussions"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.direction != nil {
		reqQP.Set("direction", string(*client.direction))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsListDiscussionsLegacyHandleResponse handles the TeamsListDiscussionsLegacy response.
func (client *GitHubV3RESTAPIClient) teamsListDiscussionsLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsListDiscussionsLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsListDiscussionsLegacyResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamDiscussionArray); err != nil {
		return GitHubV3RESTAPIClientTeamsListDiscussionsLegacyResponse{}, err
	}
	return result, nil
}

// TeamsListForAuthenticatedUser - List all of the teams across all of the organizations to which the authenticated user belongs.
// This method requires user, repo, or read:org scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/] when authenticating via OAuth [https://docs.github.com/apps/building-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsListForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsListForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) TeamsListForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListForAuthenticatedUserOptions) (GitHubV3RESTAPIClientTeamsListForAuthenticatedUserResponse, error) {
	req, err := client.teamsListForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientTeamsListForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsListForAuthenticatedUserHandleResponse(resp)
}

// teamsListForAuthenticatedUserCreateRequest creates the TeamsListForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) teamsListForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/teams"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsListForAuthenticatedUserHandleResponse handles the TeamsListForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) teamsListForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsListForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientTeamsListForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*TeamFull
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsListForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientTeamsListForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsListMembersInOrg - Team members will include the members of child teams.
// To list members in a team, the team must be visible to the authenticated user.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsListMembersInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsListMembersInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsListMembersInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListMembersInOrgOptions) (GitHubV3RESTAPIClientTeamsListMembersInOrgResponse, error) {
	req, err := client.teamsListMembersInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListMembersInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListMembersInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsListMembersInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsListMembersInOrgHandleResponse(resp)
}

// teamsListMembersInOrgCreateRequest creates the TeamsListMembersInOrg request.
func (client *GitHubV3RESTAPIClient) teamsListMembersInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListMembersInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/members"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Role != nil {
		reqQP.Set("role", string(*options.Role))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsListMembersInOrgHandleResponse handles the TeamsListMembersInOrg response.
func (client *GitHubV3RESTAPIClient) teamsListMembersInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsListMembersInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsListMembersInOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.SimpleUserArray); err != nil {
		return GitHubV3RESTAPIClientTeamsListMembersInOrgResponse{}, err
	}
	return result, nil
}

// TeamsListMembersLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new List team members
// [https://docs.github.com/rest/reference/teams#list-team-members] endpoint.
// Team members will include the members of child teams.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsListMembersLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsListMembersLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsListMembersLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListMembersLegacyOptions) (GitHubV3RESTAPIClientTeamsListMembersLegacyResponse, error) {
	req, err := client.teamsListMembersLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListMembersLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListMembersLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientTeamsListMembersLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsListMembersLegacyHandleResponse(resp)
}

// teamsListMembersLegacyCreateRequest creates the TeamsListMembersLegacy request.
func (client *GitHubV3RESTAPIClient) teamsListMembersLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListMembersLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/members"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Role != nil {
		reqQP.Set("role", string(*options.Role))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsListMembersLegacyHandleResponse handles the TeamsListMembersLegacy response.
func (client *GitHubV3RESTAPIClient) teamsListMembersLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsListMembersLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsListMembersLegacyResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*SimpleUser
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsListMembersLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsListMembersLegacyResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientTeamsListMembersLegacyResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsListPendingInvitationsInOrg - The return hash contains a role field which refers to the Organization Invitation role
// and will be one of the following values: directmember, admin, billingmanager, hiring_manager, or reinstate. If
// the invitee is not a GitHub member, the login field in the return hash will be null.
// Note: You can also specify a team by orgid and teamid using the route GET /organizations/{orgid}/team/{teamid}/invitations.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsListPendingInvitationsInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsListPendingInvitationsInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsListPendingInvitationsInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListPendingInvitationsInOrgOptions) (GitHubV3RESTAPIClientTeamsListPendingInvitationsInOrgResponse, error) {
	req, err := client.teamsListPendingInvitationsInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListPendingInvitationsInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListPendingInvitationsInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsListPendingInvitationsInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsListPendingInvitationsInOrgHandleResponse(resp)
}

// teamsListPendingInvitationsInOrgCreateRequest creates the TeamsListPendingInvitationsInOrg request.
func (client *GitHubV3RESTAPIClient) teamsListPendingInvitationsInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListPendingInvitationsInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/invitations"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsListPendingInvitationsInOrgHandleResponse handles the TeamsListPendingInvitationsInOrg response.
func (client *GitHubV3RESTAPIClient) teamsListPendingInvitationsInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsListPendingInvitationsInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsListPendingInvitationsInOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.OrganizationInvitationArray); err != nil {
		return GitHubV3RESTAPIClientTeamsListPendingInvitationsInOrgResponse{}, err
	}
	return result, nil
}

// TeamsListPendingInvitationsLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the
// Teams API. We recommend migrating your existing code to use the new List pending team invitations
// [https://docs.github.com/rest/reference/teams#list-pending-team-invitations] endpoint.
// The return hash contains a role field which refers to the Organization Invitation role and will be one of the following
// values: directmember, admin, billingmanager, hiring_manager, or reinstate. If
// the invitee is not a GitHub member, the login field in the return hash will be null.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsListPendingInvitationsLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsListPendingInvitationsLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsListPendingInvitationsLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListPendingInvitationsLegacyOptions) (GitHubV3RESTAPIClientTeamsListPendingInvitationsLegacyResponse, error) {
	req, err := client.teamsListPendingInvitationsLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListPendingInvitationsLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListPendingInvitationsLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsListPendingInvitationsLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsListPendingInvitationsLegacyHandleResponse(resp)
}

// teamsListPendingInvitationsLegacyCreateRequest creates the TeamsListPendingInvitationsLegacy request.
func (client *GitHubV3RESTAPIClient) teamsListPendingInvitationsLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListPendingInvitationsLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/invitations"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsListPendingInvitationsLegacyHandleResponse handles the TeamsListPendingInvitationsLegacy response.
func (client *GitHubV3RESTAPIClient) teamsListPendingInvitationsLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsListPendingInvitationsLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsListPendingInvitationsLegacyResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.OrganizationInvitationArray); err != nil {
		return GitHubV3RESTAPIClientTeamsListPendingInvitationsLegacyResponse{}, err
	}
	return result, nil
}

// TeamsListProjectsInOrg - Lists the organization projects for a team.
// Note: You can also specify a team by orgid and teamid using the route GET /organizations/{orgid}/team/{teamid}/projects.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsListProjectsInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsListProjectsInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsListProjectsInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListProjectsInOrgOptions) (GitHubV3RESTAPIClientTeamsListProjectsInOrgResponse, error) {
	req, err := client.teamsListProjectsInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListProjectsInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListProjectsInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsListProjectsInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsListProjectsInOrgHandleResponse(resp)
}

// teamsListProjectsInOrgCreateRequest creates the TeamsListProjectsInOrg request.
func (client *GitHubV3RESTAPIClient) teamsListProjectsInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListProjectsInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/projects"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsListProjectsInOrgHandleResponse handles the TeamsListProjectsInOrg response.
func (client *GitHubV3RESTAPIClient) teamsListProjectsInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsListProjectsInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsListProjectsInOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamProjectArray); err != nil {
		return GitHubV3RESTAPIClientTeamsListProjectsInOrgResponse{}, err
	}
	return result, nil
}

// TeamsListProjectsLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new List team projects
// [https://docs.github.com/rest/reference/teams#list-team-projects] endpoint.
// Lists the organization projects for a team.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsListProjectsLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsListProjectsLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsListProjectsLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListProjectsLegacyOptions) (GitHubV3RESTAPIClientTeamsListProjectsLegacyResponse, error) {
	req, err := client.teamsListProjectsLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListProjectsLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListProjectsLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientTeamsListProjectsLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsListProjectsLegacyHandleResponse(resp)
}

// teamsListProjectsLegacyCreateRequest creates the TeamsListProjectsLegacy request.
func (client *GitHubV3RESTAPIClient) teamsListProjectsLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListProjectsLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/projects"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsListProjectsLegacyHandleResponse handles the TeamsListProjectsLegacy response.
func (client *GitHubV3RESTAPIClient) teamsListProjectsLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsListProjectsLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsListProjectsLegacyResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*TeamProject
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsListProjectsLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsListProjectsLegacyResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientTeamsListProjectsLegacyResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsListReposInOrg - Lists a team's repositories visible to the authenticated user.
// Note: You can also specify a team by orgid and teamid using the route GET /organizations/{orgid}/team/{teamid}/repos.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsListReposInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsListReposInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsListReposInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListReposInOrgOptions) (GitHubV3RESTAPIClientTeamsListReposInOrgResponse, error) {
	req, err := client.teamsListReposInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListReposInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListReposInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsListReposInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsListReposInOrgHandleResponse(resp)
}

// teamsListReposInOrgCreateRequest creates the TeamsListReposInOrg request.
func (client *GitHubV3RESTAPIClient) teamsListReposInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListReposInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/repos"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsListReposInOrgHandleResponse handles the TeamsListReposInOrg response.
func (client *GitHubV3RESTAPIClient) teamsListReposInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsListReposInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsListReposInOrgResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.MinimalRepositoryArray); err != nil {
		return GitHubV3RESTAPIClientTeamsListReposInOrgResponse{}, err
	}
	return result, nil
}

// TeamsListReposLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams API. We
// recommend migrating your existing code to use the new List team repositories
// [https://docs.github.com/rest/reference/teams#list-team-repositories] endpoint.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsListReposLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsListReposLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsListReposLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListReposLegacyOptions) (GitHubV3RESTAPIClientTeamsListReposLegacyResponse, error) {
	req, err := client.teamsListReposLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListReposLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsListReposLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientTeamsListReposLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsListReposLegacyHandleResponse(resp)
}

// teamsListReposLegacyCreateRequest creates the TeamsListReposLegacy request.
func (client *GitHubV3RESTAPIClient) teamsListReposLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsListReposLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/repos"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsListReposLegacyHandleResponse handles the TeamsListReposLegacy response.
func (client *GitHubV3RESTAPIClient) teamsListReposLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsListReposLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsListReposLegacyResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*MinimalRepository
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsListReposLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsListReposLegacyResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientTeamsListReposLegacyResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsRemoveMemberLegacy - The "Remove team member" endpoint (described below) is deprecated.
// We recommend using the Remove team membership for a user [https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user]
// endpoint instead. It allows you to remove both active and
// pending memberships.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see GitHub's products
// [https://docs.github.com/github/getting-started-with-github/githubs-products] in the GitHub Help documentation.
// To remove a team member, the authenticated user must have 'admin' permissions to the team or be an owner of the org that
// the team is associated with. Removing a team member does not delete the user,
// it just removes them from the team.
// Note: When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see
// an error if you attempt to use the API for making changes to the team's
// membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your
// identity provider, which automatically adds and removes team members in an
// organization. For more information, see "Synchronizing teams between your identity provider and GitHub [https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/]
// ."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsRemoveMemberLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsRemoveMemberLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsRemoveMemberLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsRemoveMemberLegacyOptions) (GitHubV3RESTAPIClientTeamsRemoveMemberLegacyResponse, error) {
	req, err := client.teamsRemoveMemberLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsRemoveMemberLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsRemoveMemberLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientTeamsRemoveMemberLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientTeamsRemoveMemberLegacyResponse{}, nil
}

// teamsRemoveMemberLegacyCreateRequest creates the TeamsRemoveMemberLegacy request.
func (client *GitHubV3RESTAPIClient) teamsRemoveMemberLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsRemoveMemberLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/members/{username}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// TeamsRemoveMembershipForUserInOrg - To remove a membership between a user and a team, the authenticated user must have
// 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team
// membership does not delete the user, it just removes their membership from the team.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see GitHub's products
// [https://docs.github.com/github/getting-started-with-github/githubs-products] in the GitHub Help documentation.
// Note: When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see
// an error if you attempt to use the API for making changes to the team's
// membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your
// identity provider, which automatically adds and removes team members in an
// organization. For more information, see "Synchronizing teams between your identity provider and GitHub [https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/]
// ."
// Note: You can also specify a team by orgid and teamid using the route DELETE /organizations/{orgid}/team/{teamid}/memberships/{username}.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsRemoveMembershipForUserInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsRemoveMembershipForUserInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsRemoveMembershipForUserInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsRemoveMembershipForUserInOrgOptions) (GitHubV3RESTAPIClientTeamsRemoveMembershipForUserInOrgResponse, error) {
	req, err := client.teamsRemoveMembershipForUserInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsRemoveMembershipForUserInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsRemoveMembershipForUserInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusForbidden) {
		return GitHubV3RESTAPIClientTeamsRemoveMembershipForUserInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientTeamsRemoveMembershipForUserInOrgResponse{}, nil
}

// teamsRemoveMembershipForUserInOrgCreateRequest creates the TeamsRemoveMembershipForUserInOrg request.
func (client *GitHubV3RESTAPIClient) teamsRemoveMembershipForUserInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsRemoveMembershipForUserInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/memberships/{username}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// TeamsRemoveMembershipForUserLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the
// Teams API. We recommend migrating your existing code to use the new Remove team membership for a user
// [https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user] endpoint.
// Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see GitHub's products
// [https://docs.github.com/github/getting-started-with-github/githubs-products] in the GitHub Help documentation.
// To remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be
// an owner of the organization that the team is associated with. Removing team
// membership does not delete the user, it just removes their membership from the team.
// Note: When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see
// an error if you attempt to use the API for making changes to the team's
// membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your
// identity provider, which automatically adds and removes team members in an
// organization. For more information, see "Synchronizing teams between your identity provider and GitHub [https://docs.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/]
// ."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsRemoveMembershipForUserLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsRemoveMembershipForUserLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsRemoveMembershipForUserLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsRemoveMembershipForUserLegacyOptions) (GitHubV3RESTAPIClientTeamsRemoveMembershipForUserLegacyResponse, error) {
	req, err := client.teamsRemoveMembershipForUserLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsRemoveMembershipForUserLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsRemoveMembershipForUserLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusForbidden) {
		return GitHubV3RESTAPIClientTeamsRemoveMembershipForUserLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientTeamsRemoveMembershipForUserLegacyResponse{}, nil
}

// teamsRemoveMembershipForUserLegacyCreateRequest creates the TeamsRemoveMembershipForUserLegacy request.
func (client *GitHubV3RESTAPIClient) teamsRemoveMembershipForUserLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsRemoveMembershipForUserLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/memberships/{username}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// TeamsRemoveProjectInOrg - Removes an organization project from a team. An organization owner or a team maintainer can remove
// any project from the team. To remove a project from a team as an organization member, the
// authenticated user must have read access to both the team and project, or admin access to the team or project. This endpoint
// removes the project from the team, but does not delete the project.
// Note: You can also specify a team by orgid and teamid using the route DELETE /organizations/{orgid}/team/{teamid}/projects/{project_id}.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsRemoveProjectInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsRemoveProjectInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsRemoveProjectInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsRemoveProjectInOrgOptions) (GitHubV3RESTAPIClientTeamsRemoveProjectInOrgResponse, error) {
	req, err := client.teamsRemoveProjectInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsRemoveProjectInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsRemoveProjectInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientTeamsRemoveProjectInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientTeamsRemoveProjectInOrgResponse{}, nil
}

// teamsRemoveProjectInOrgCreateRequest creates the TeamsRemoveProjectInOrg request.
func (client *GitHubV3RESTAPIClient) teamsRemoveProjectInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsRemoveProjectInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/projects/{project_id}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{project_id}", url.PathEscape(strconv.FormatInt(int64(client.projectID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// TeamsRemoveProjectLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams API.
// We recommend migrating your existing code to use the new Remove a project from a team
// [https://docs.github.com/rest/reference/teams#remove-a-project-from-a-team] endpoint.
// Removes an organization project from a team. An organization owner or a team maintainer can remove any project from the
// team. To remove a project from a team as an organization member, the
// authenticated user must have read access to both the team and project, or admin access to the team or project. Note: This
// endpoint removes the project from the team, but does not delete it.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsRemoveProjectLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsRemoveProjectLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsRemoveProjectLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsRemoveProjectLegacyOptions) (GitHubV3RESTAPIClientTeamsRemoveProjectLegacyResponse, error) {
	req, err := client.teamsRemoveProjectLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsRemoveProjectLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsRemoveProjectLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientTeamsRemoveProjectLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsRemoveProjectLegacyHandleResponse(resp)
}

// teamsRemoveProjectLegacyCreateRequest creates the TeamsRemoveProjectLegacy request.
func (client *GitHubV3RESTAPIClient) teamsRemoveProjectLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsRemoveProjectLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/projects/{project_id}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{project_id}", url.PathEscape(strconv.FormatInt(int64(client.projectID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// teamsRemoveProjectLegacyHandleResponse handles the TeamsRemoveProjectLegacy response.
func (client *GitHubV3RESTAPIClient) teamsRemoveProjectLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsRemoveProjectLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsRemoveProjectLegacyResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsRemoveProjectLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsRemoveProjectLegacyResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientTeamsRemoveProjectLegacyResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsRemoveRepoInOrg - If the authenticated user is an organization owner or a team maintainer, they can remove any repositories
// from the team. To remove a repository from a team as an organization member, the authenticated
// user must have admin access to the repository and must be able to see the team. This does not delete the repository, it
// just removes it from the team.
// Note: You can also specify a team by orgid and teamid using the route DELETE /organizations/{orgid}/team/{teamid}/repos/{owner}/{repo}.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsRemoveRepoInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsRemoveRepoInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsRemoveRepoInOrg(ctx context.Context, options *GitHubV3RESTAPIClientTeamsRemoveRepoInOrgOptions) (GitHubV3RESTAPIClientTeamsRemoveRepoInOrgResponse, error) {
	req, err := client.teamsRemoveRepoInOrgCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsRemoveRepoInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsRemoveRepoInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientTeamsRemoveRepoInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientTeamsRemoveRepoInOrgResponse{}, nil
}

// teamsRemoveRepoInOrgCreateRequest creates the TeamsRemoveRepoInOrg request.
func (client *GitHubV3RESTAPIClient) teamsRemoveRepoInOrgCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsRemoveRepoInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// TeamsRemoveRepoLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams API. We
// recommend migrating your existing code to use the new Remove a repository from a team
// [https://docs.github.com/rest/reference/teams#remove-a-repository-from-a-team] endpoint.
// If the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team.
// To remove a repository from a team as an organization member, the authenticated
// user must have admin access to the repository and must be able to see the team. NOTE: This does not delete the repository,
// it just removes it from the team.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsRemoveRepoLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsRemoveRepoLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsRemoveRepoLegacy(ctx context.Context, options *GitHubV3RESTAPIClientTeamsRemoveRepoLegacyOptions) (GitHubV3RESTAPIClientTeamsRemoveRepoLegacyResponse, error) {
	req, err := client.teamsRemoveRepoLegacyCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsRemoveRepoLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsRemoveRepoLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return GitHubV3RESTAPIClientTeamsRemoveRepoLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientTeamsRemoveRepoLegacyResponse{}, nil
}

// teamsRemoveRepoLegacyCreateRequest creates the TeamsRemoveRepoLegacy request.
func (client *GitHubV3RESTAPIClient) teamsRemoveRepoLegacyCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientTeamsRemoveRepoLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/repos/{owner}/{repo}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	if client.owner == "" {
		return nil, errors.New("parameter client.owner cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{owner}", url.PathEscape(client.owner))
	if client.repo == "" {
		return nil, errors.New("parameter client.repo cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{repo}", url.PathEscape(client.repo))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// TeamsUpdateDiscussionCommentInOrg - Edits the body text of a discussion comment. OAuth access tokens require the write:discussion
// scope [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// Note: You can also specify a team by orgid and teamid using the route PATCH /organizations/{orgid}/team/{teamid}/discussions/{discussionnumber}/comments/{commentnumber}.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsUpdateDiscussionCommentInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsUpdateDiscussionCommentInOrg(ctx context.Context, body PathsHw6XesOrgsOrgTeamsTeamSlugDiscussionsDiscussionNumberCommentsCommentNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentInOrgOptions) (GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentInOrgResponse, error) {
	req, err := client.teamsUpdateDiscussionCommentInOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsUpdateDiscussionCommentInOrgHandleResponse(resp)
}

// teamsUpdateDiscussionCommentInOrgCreateRequest creates the TeamsUpdateDiscussionCommentInOrg request.
func (client *GitHubV3RESTAPIClient) teamsUpdateDiscussionCommentInOrgCreateRequest(ctx context.Context, body PathsHw6XesOrgsOrgTeamsTeamSlugDiscussionsDiscussionNumberCommentsCommentNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{comment_number}", url.PathEscape(strconv.FormatInt(int64(client.commentNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// teamsUpdateDiscussionCommentInOrgHandleResponse handles the TeamsUpdateDiscussionCommentInOrg response.
func (client *GitHubV3RESTAPIClient) teamsUpdateDiscussionCommentInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentInOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamDiscussionComment); err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentInOrgResponse{}, err
	}
	return result, nil
}

// TeamsUpdateDiscussionCommentLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the
// Teams API. We recommend migrating your existing code to use the new Update a discussion comment
// [https://docs.github.com/rest/reference/teams#update-a-discussion-comment] endpoint.
// Edits the body text of a discussion comment. OAuth access tokens require the write:discussion scope [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsUpdateDiscussionCommentLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsUpdateDiscussionCommentLegacy(ctx context.Context, body PathsNzm73JTeamsTeamIDDiscussionsDiscussionNumberCommentsCommentNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentLegacyOptions) (GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentLegacyResponse, error) {
	req, err := client.teamsUpdateDiscussionCommentLegacyCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsUpdateDiscussionCommentLegacyHandleResponse(resp)
}

// teamsUpdateDiscussionCommentLegacyCreateRequest creates the TeamsUpdateDiscussionCommentLegacy request.
func (client *GitHubV3RESTAPIClient) teamsUpdateDiscussionCommentLegacyCreateRequest(ctx context.Context, body PathsNzm73JTeamsTeamIDDiscussionsDiscussionNumberCommentsCommentNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{comment_number}", url.PathEscape(strconv.FormatInt(int64(client.commentNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// teamsUpdateDiscussionCommentLegacyHandleResponse handles the TeamsUpdateDiscussionCommentLegacy response.
func (client *GitHubV3RESTAPIClient) teamsUpdateDiscussionCommentLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentLegacyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamDiscussionComment); err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateDiscussionCommentLegacyResponse{}, err
	}
	return result, nil
}

// TeamsUpdateDiscussionInOrg - Edits the title and body text of a discussion post. Only the parameters you provide are updated.
// OAuth access tokens require the write:discussion scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// Note: You can also specify a team by orgid and teamid using the route PATCH /organizations/{orgid}/team/{teamid}/discussions/{discussion_number}.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsUpdateDiscussionInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsUpdateDiscussionInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsUpdateDiscussionInOrg(ctx context.Context, body Paths1U1Qx6ZOrgsOrgTeamsTeamSlugDiscussionsDiscussionNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsUpdateDiscussionInOrgOptions) (GitHubV3RESTAPIClientTeamsUpdateDiscussionInOrgResponse, error) {
	req, err := client.teamsUpdateDiscussionInOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateDiscussionInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateDiscussionInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsUpdateDiscussionInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsUpdateDiscussionInOrgHandleResponse(resp)
}

// teamsUpdateDiscussionInOrgCreateRequest creates the TeamsUpdateDiscussionInOrg request.
func (client *GitHubV3RESTAPIClient) teamsUpdateDiscussionInOrgCreateRequest(ctx context.Context, body Paths1U1Qx6ZOrgsOrgTeamsTeamSlugDiscussionsDiscussionNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsUpdateDiscussionInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// teamsUpdateDiscussionInOrgHandleResponse handles the TeamsUpdateDiscussionInOrg response.
func (client *GitHubV3RESTAPIClient) teamsUpdateDiscussionInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsUpdateDiscussionInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsUpdateDiscussionInOrgResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamDiscussion); err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateDiscussionInOrgResponse{}, err
	}
	return result, nil
}

// TeamsUpdateDiscussionLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams
// API. We recommend migrating your existing code to use the new Update a discussion
// [https://docs.github.com/rest/reference/teams#update-a-discussion] endpoint.
// Edits the title and body text of a discussion post. Only the parameters you provide are updated. OAuth access tokens require
// the write:discussion scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsUpdateDiscussionLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsUpdateDiscussionLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsUpdateDiscussionLegacy(ctx context.Context, body Paths3RoqecTeamsTeamIDDiscussionsDiscussionNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsUpdateDiscussionLegacyOptions) (GitHubV3RESTAPIClientTeamsUpdateDiscussionLegacyResponse, error) {
	req, err := client.teamsUpdateDiscussionLegacyCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateDiscussionLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateDiscussionLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientTeamsUpdateDiscussionLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsUpdateDiscussionLegacyHandleResponse(resp)
}

// teamsUpdateDiscussionLegacyCreateRequest creates the TeamsUpdateDiscussionLegacy request.
func (client *GitHubV3RESTAPIClient) teamsUpdateDiscussionLegacyCreateRequest(ctx context.Context, body Paths3RoqecTeamsTeamIDDiscussionsDiscussionNumberPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsUpdateDiscussionLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}/discussions/{discussion_number}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	urlPath = strings.ReplaceAll(urlPath, "{discussion_number}", url.PathEscape(strconv.FormatInt(int64(client.discussionNumber), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// teamsUpdateDiscussionLegacyHandleResponse handles the TeamsUpdateDiscussionLegacy response.
func (client *GitHubV3RESTAPIClient) teamsUpdateDiscussionLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsUpdateDiscussionLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsUpdateDiscussionLegacyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TeamDiscussion); err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateDiscussionLegacyResponse{}, err
	}
	return result, nil
}

// TeamsUpdateInOrg - To edit a team, the authenticated user must either be an organization owner or a team maintainer.
// Note: You can also specify a team by orgid and teamid using the route PATCH /organizations/{orgid}/team/{teamid}.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsUpdateInOrgOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsUpdateInOrg
//     method.
func (client *GitHubV3RESTAPIClient) TeamsUpdateInOrg(ctx context.Context, body Paths1JjuabgOrgsOrgTeamsTeamSlugPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsUpdateInOrgOptions) (GitHubV3RESTAPIClientTeamsUpdateInOrgResponse, error) {
	req, err := client.teamsUpdateInOrgCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateInOrgResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateInOrgResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientTeamsUpdateInOrgResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsUpdateInOrgHandleResponse(resp)
}

// teamsUpdateInOrgCreateRequest creates the TeamsUpdateInOrg request.
func (client *GitHubV3RESTAPIClient) teamsUpdateInOrgCreateRequest(ctx context.Context, body Paths1JjuabgOrgsOrgTeamsTeamSlugPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsUpdateInOrgOptions) (*policy.Request, error) {
	urlPath := "/orgs/{org}/teams/{team_slug}"
	if client.org == "" {
		return nil, errors.New("parameter client.org cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{org}", url.PathEscape(client.org))
	if client.teamSlug == "" {
		return nil, errors.New("parameter client.teamSlug cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{team_slug}", url.PathEscape(client.teamSlug))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// teamsUpdateInOrgHandleResponse handles the TeamsUpdateInOrg response.
func (client *GitHubV3RESTAPIClient) teamsUpdateInOrgHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsUpdateInOrgResponse, error) {
	result := GitHubV3RESTAPIClientTeamsUpdateInOrgResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val TeamFull
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateInOrgResponse{}, err
	}
	result.Value = val
	case http.StatusCreated:
	var val TeamFull
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateInOrgResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateInOrgResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateInOrgResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateInOrgResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientTeamsUpdateInOrgResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// TeamsUpdateLegacy - Deprecation Notice: This endpoint route is deprecated and will be removed from the Teams API. We recommend
// migrating your existing code to use the new Update a team
// [https://docs.github.com/rest/reference/teams#update-a-team] endpoint.
// To edit a team, the authenticated user must either be an organization owner or a team maintainer.
// Note: With nested teams, the privacy for parent teams cannot be secret.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientTeamsUpdateLegacyOptions contains the optional parameters for the GitHubV3RESTAPIClient.TeamsUpdateLegacy
//     method.
func (client *GitHubV3RESTAPIClient) TeamsUpdateLegacy(ctx context.Context, body Paths890MjvTeamsTeamIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsUpdateLegacyOptions) (GitHubV3RESTAPIClientTeamsUpdateLegacyResponse, error) {
	req, err := client.teamsUpdateLegacyCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateLegacyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateLegacyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientTeamsUpdateLegacyResponse{}, runtime.NewResponseError(resp)
	}
	return client.teamsUpdateLegacyHandleResponse(resp)
}

// teamsUpdateLegacyCreateRequest creates the TeamsUpdateLegacy request.
func (client *GitHubV3RESTAPIClient) teamsUpdateLegacyCreateRequest(ctx context.Context, body Paths890MjvTeamsTeamIDPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientTeamsUpdateLegacyOptions) (*policy.Request, error) {
	urlPath := "/teams/{team_id}"
	urlPath = strings.ReplaceAll(urlPath, "{team_id}", url.PathEscape(strconv.FormatInt(int64(client.teamID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// teamsUpdateLegacyHandleResponse handles the TeamsUpdateLegacy response.
func (client *GitHubV3RESTAPIClient) teamsUpdateLegacyHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientTeamsUpdateLegacyResponse, error) {
	result := GitHubV3RESTAPIClientTeamsUpdateLegacyResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val TeamFull
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusCreated:
	var val TeamFull
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateLegacyResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientTeamsUpdateLegacyResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientTeamsUpdateLegacyResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersAddEmailForAuthenticatedUser - This endpoint is accessible with the user scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersAddEmailForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersAddEmailForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersAddEmailForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersAddEmailForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersAddEmailForAuthenticatedUserResponse, error) {
	req, err := client.usersAddEmailForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersAddEmailForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersAddEmailForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientUsersAddEmailForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersAddEmailForAuthenticatedUserHandleResponse(resp)
}

// usersAddEmailForAuthenticatedUserCreateRequest creates the UsersAddEmailForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersAddEmailForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersAddEmailForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/emails"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// usersAddEmailForAuthenticatedUserHandleResponse handles the UsersAddEmailForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersAddEmailForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersAddEmailForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersAddEmailForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val []*Email
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersAddEmailForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersAddEmailForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersAddEmailForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersAddEmailForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersAddEmailForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersAddEmailForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersBlock - Block a user
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersBlockOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersBlock
//     method.
func (client *GitHubV3RESTAPIClient) UsersBlock(ctx context.Context, options *GitHubV3RESTAPIClientUsersBlockOptions) (GitHubV3RESTAPIClientUsersBlockResponse, error) {
	req, err := client.usersBlockCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersBlockResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersBlockResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientUsersBlockResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersBlockHandleResponse(resp)
}

// usersBlockCreateRequest creates the UsersBlock request.
func (client *GitHubV3RESTAPIClient) usersBlockCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersBlockOptions) (*policy.Request, error) {
	urlPath := "/user/blocks/{username}"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersBlockHandleResponse handles the UsersBlock response.
func (client *GitHubV3RESTAPIClient) usersBlockHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersBlockResponse, error) {
	result := GitHubV3RESTAPIClientUsersBlockResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersBlockResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersBlockResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersBlockResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersBlockResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersBlockResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersCheckBlocked - Check if a user is blocked by the authenticated user
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersCheckBlockedOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersCheckBlocked
//     method.
func (client *GitHubV3RESTAPIClient) UsersCheckBlocked(ctx context.Context, options *GitHubV3RESTAPIClientUsersCheckBlockedOptions) (GitHubV3RESTAPIClientUsersCheckBlockedResponse, error) {
	req, err := client.usersCheckBlockedCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersCheckBlockedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersCheckBlockedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersCheckBlockedResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersCheckBlockedHandleResponse(resp)
}

// usersCheckBlockedCreateRequest creates the UsersCheckBlocked request.
func (client *GitHubV3RESTAPIClient) usersCheckBlockedCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersCheckBlockedOptions) (*policy.Request, error) {
	urlPath := "/user/blocks/{username}"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersCheckBlockedHandleResponse handles the UsersCheckBlocked response.
func (client *GitHubV3RESTAPIClient) usersCheckBlockedHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersCheckBlockedResponse, error) {
	result := GitHubV3RESTAPIClientUsersCheckBlockedResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientUsersCheckBlockedResponse{}, err
	}
	return result, nil
}

// UsersCheckFollowingForUser - Check if a user follows another user
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersCheckFollowingForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersCheckFollowingForUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersCheckFollowingForUser(ctx context.Context, targetUser string, options *GitHubV3RESTAPIClientUsersCheckFollowingForUserOptions) (GitHubV3RESTAPIClientUsersCheckFollowingForUserResponse, error) {
	req, err := client.usersCheckFollowingForUserCreateRequest(ctx, targetUser, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersCheckFollowingForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersCheckFollowingForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersCheckFollowingForUserResponse{}, runtime.NewResponseError(resp)
	}
	return GitHubV3RESTAPIClientUsersCheckFollowingForUserResponse{}, nil
}

// usersCheckFollowingForUserCreateRequest creates the UsersCheckFollowingForUser request.
func (client *GitHubV3RESTAPIClient) usersCheckFollowingForUserCreateRequest(ctx context.Context, targetUser string, options *GitHubV3RESTAPIClientUsersCheckFollowingForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/following/{target_user}"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	if targetUser == "" {
		return nil, errors.New("parameter targetUser cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{target_user}", url.PathEscape(targetUser))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// UsersCheckPersonIsFollowedByAuthenticated - Check if a person is followed by the authenticated user
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersCheckPersonIsFollowedByAuthenticatedOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.UsersCheckPersonIsFollowedByAuthenticated method.
func (client *GitHubV3RESTAPIClient) UsersCheckPersonIsFollowedByAuthenticated(ctx context.Context, options *GitHubV3RESTAPIClientUsersCheckPersonIsFollowedByAuthenticatedOptions) (GitHubV3RESTAPIClientUsersCheckPersonIsFollowedByAuthenticatedResponse, error) {
	req, err := client.usersCheckPersonIsFollowedByAuthenticatedCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersCheckPersonIsFollowedByAuthenticatedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersCheckPersonIsFollowedByAuthenticatedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersCheckPersonIsFollowedByAuthenticatedResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersCheckPersonIsFollowedByAuthenticatedHandleResponse(resp)
}

// usersCheckPersonIsFollowedByAuthenticatedCreateRequest creates the UsersCheckPersonIsFollowedByAuthenticated request.
func (client *GitHubV3RESTAPIClient) usersCheckPersonIsFollowedByAuthenticatedCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersCheckPersonIsFollowedByAuthenticatedOptions) (*policy.Request, error) {
	urlPath := "/user/following/{username}"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersCheckPersonIsFollowedByAuthenticatedHandleResponse handles the UsersCheckPersonIsFollowedByAuthenticated response.
func (client *GitHubV3RESTAPIClient) usersCheckPersonIsFollowedByAuthenticatedHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersCheckPersonIsFollowedByAuthenticatedResponse, error) {
	result := GitHubV3RESTAPIClientUsersCheckPersonIsFollowedByAuthenticatedResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientUsersCheckPersonIsFollowedByAuthenticatedResponse{}, err
	}
	return result, nil
}

// UsersCreateGpgKeyForAuthenticatedUser - Adds a GPG key to the authenticated user's GitHub account. Requires that you are
// authenticated via Basic Auth, or OAuth with at least write:gpg_key scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersCreateGpgKeyForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersCreateGpgKeyForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersCreateGpgKeyForAuthenticatedUser(ctx context.Context, body Paths1MocmdsUserGpgKeysPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientUsersCreateGpgKeyForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersCreateGpgKeyForAuthenticatedUserResponse, error) {
	req, err := client.usersCreateGpgKeyForAuthenticatedUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersCreateGpgKeyForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersCreateGpgKeyForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientUsersCreateGpgKeyForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersCreateGpgKeyForAuthenticatedUserHandleResponse(resp)
}

// usersCreateGpgKeyForAuthenticatedUserCreateRequest creates the UsersCreateGpgKeyForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersCreateGpgKeyForAuthenticatedUserCreateRequest(ctx context.Context, body Paths1MocmdsUserGpgKeysPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientUsersCreateGpgKeyForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/gpg_keys"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// usersCreateGpgKeyForAuthenticatedUserHandleResponse handles the UsersCreateGpgKeyForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersCreateGpgKeyForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersCreateGpgKeyForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersCreateGpgKeyForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val GpgKey
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersCreateGpgKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersCreateGpgKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersCreateGpgKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersCreateGpgKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersCreateGpgKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersCreateGpgKeyForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersCreatePublicSSHKeyForAuthenticatedUser - Adds a public SSH key to the authenticated user's GitHub account. Requires
// that you are authenticated via Basic Auth, or OAuth with at least write:public_key scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersCreatePublicSSHKeyForAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.UsersCreatePublicSSHKeyForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) UsersCreatePublicSSHKeyForAuthenticatedUser(ctx context.Context, body PathsKo6Vl6UserKeysPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientUsersCreatePublicSSHKeyForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersCreatePublicSSHKeyForAuthenticatedUserResponse, error) {
	req, err := client.usersCreatePublicSSHKeyForAuthenticatedUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersCreatePublicSSHKeyForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersCreatePublicSSHKeyForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientUsersCreatePublicSSHKeyForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersCreatePublicSSHKeyForAuthenticatedUserHandleResponse(resp)
}

// usersCreatePublicSSHKeyForAuthenticatedUserCreateRequest creates the UsersCreatePublicSSHKeyForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersCreatePublicSSHKeyForAuthenticatedUserCreateRequest(ctx context.Context, body PathsKo6Vl6UserKeysPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientUsersCreatePublicSSHKeyForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/keys"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// usersCreatePublicSSHKeyForAuthenticatedUserHandleResponse handles the UsersCreatePublicSSHKeyForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersCreatePublicSSHKeyForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersCreatePublicSSHKeyForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersCreatePublicSSHKeyForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val Key
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersCreatePublicSSHKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersCreatePublicSSHKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersCreatePublicSSHKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersCreatePublicSSHKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersCreatePublicSSHKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersCreatePublicSSHKeyForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersCreateSSHSigningKeyForAuthenticatedUser - Creates an SSH signing key for the authenticated user's GitHub account.
// You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least write:sshsigningkey
// scope.
// For more information, see "Understanding scopes for OAuth apps [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersCreateSSHSigningKeyForAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.UsersCreateSSHSigningKeyForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) UsersCreateSSHSigningKeyForAuthenticatedUser(ctx context.Context, body Paths121Yhp2UserSSHSigningKeysPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientUsersCreateSSHSigningKeyForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersCreateSSHSigningKeyForAuthenticatedUserResponse, error) {
	req, err := client.usersCreateSSHSigningKeyForAuthenticatedUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersCreateSSHSigningKeyForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersCreateSSHSigningKeyForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientUsersCreateSSHSigningKeyForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersCreateSSHSigningKeyForAuthenticatedUserHandleResponse(resp)
}

// usersCreateSSHSigningKeyForAuthenticatedUserCreateRequest creates the UsersCreateSSHSigningKeyForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersCreateSSHSigningKeyForAuthenticatedUserCreateRequest(ctx context.Context, body Paths121Yhp2UserSSHSigningKeysPostRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientUsersCreateSSHSigningKeyForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/ssh_signing_keys"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// usersCreateSSHSigningKeyForAuthenticatedUserHandleResponse handles the UsersCreateSSHSigningKeyForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersCreateSSHSigningKeyForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersCreateSSHSigningKeyForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersCreateSSHSigningKeyForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val SSHSigningKey
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersCreateSSHSigningKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersCreateSSHSigningKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersCreateSSHSigningKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersCreateSSHSigningKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersCreateSSHSigningKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersCreateSSHSigningKeyForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersDeleteEmailForAuthenticatedUser - This endpoint is accessible with the user scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersDeleteEmailForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersDeleteEmailForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersDeleteEmailForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersDeleteEmailForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersDeleteEmailForAuthenticatedUserResponse, error) {
	req, err := client.usersDeleteEmailForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersDeleteEmailForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersDeleteEmailForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientUsersDeleteEmailForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersDeleteEmailForAuthenticatedUserHandleResponse(resp)
}

// usersDeleteEmailForAuthenticatedUserCreateRequest creates the UsersDeleteEmailForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersDeleteEmailForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersDeleteEmailForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/emails"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// usersDeleteEmailForAuthenticatedUserHandleResponse handles the UsersDeleteEmailForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersDeleteEmailForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersDeleteEmailForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersDeleteEmailForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersDeleteEmailForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersDeleteEmailForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersDeleteEmailForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersDeleteEmailForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersDeleteEmailForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersDeleteGpgKeyForAuthenticatedUser - Removes a GPG key from the authenticated user's GitHub account. Requires that you
// are authenticated via Basic Auth or via OAuth with at least admin:gpg_key scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersDeleteGpgKeyForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersDeleteGpgKeyForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersDeleteGpgKeyForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersDeleteGpgKeyForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersDeleteGpgKeyForAuthenticatedUserResponse, error) {
	req, err := client.usersDeleteGpgKeyForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersDeleteGpgKeyForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersDeleteGpgKeyForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientUsersDeleteGpgKeyForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersDeleteGpgKeyForAuthenticatedUserHandleResponse(resp)
}

// usersDeleteGpgKeyForAuthenticatedUserCreateRequest creates the UsersDeleteGpgKeyForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersDeleteGpgKeyForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersDeleteGpgKeyForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/gpg_keys/{gpg_key_id}"
	urlPath = strings.ReplaceAll(urlPath, "{gpg_key_id}", url.PathEscape(strconv.FormatInt(int64(client.gpgKeyID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersDeleteGpgKeyForAuthenticatedUserHandleResponse handles the UsersDeleteGpgKeyForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersDeleteGpgKeyForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersDeleteGpgKeyForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersDeleteGpgKeyForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersDeleteGpgKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersDeleteGpgKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersDeleteGpgKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersDeleteGpgKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersDeleteGpgKeyForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersDeletePublicSSHKeyForAuthenticatedUser - Removes a public SSH key from the authenticated user's GitHub account. Requires
// that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersDeletePublicSSHKeyForAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.UsersDeletePublicSSHKeyForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) UsersDeletePublicSSHKeyForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersDeletePublicSSHKeyForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersDeletePublicSSHKeyForAuthenticatedUserResponse, error) {
	req, err := client.usersDeletePublicSSHKeyForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersDeletePublicSSHKeyForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersDeletePublicSSHKeyForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersDeletePublicSSHKeyForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersDeletePublicSSHKeyForAuthenticatedUserHandleResponse(resp)
}

// usersDeletePublicSSHKeyForAuthenticatedUserCreateRequest creates the UsersDeletePublicSSHKeyForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersDeletePublicSSHKeyForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersDeletePublicSSHKeyForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/keys/{key_id}"
	urlPath = strings.ReplaceAll(urlPath, "{key_id}", url.PathEscape(strconv.FormatInt(int64(client.keyID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersDeletePublicSSHKeyForAuthenticatedUserHandleResponse handles the UsersDeletePublicSSHKeyForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersDeletePublicSSHKeyForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersDeletePublicSSHKeyForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersDeletePublicSSHKeyForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientUsersDeletePublicSSHKeyForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// UsersDeleteSSHSigningKeyForAuthenticatedUser - Deletes an SSH signing key from the authenticated user's GitHub account.
// You must authenticate with Basic Authentication, or you must authenticate with OAuth with at least admin:sshsigningkey
// scope.
// For more information, see "Understanding scopes for OAuth apps [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersDeleteSSHSigningKeyForAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.UsersDeleteSSHSigningKeyForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) UsersDeleteSSHSigningKeyForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersDeleteSSHSigningKeyForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersDeleteSSHSigningKeyForAuthenticatedUserResponse, error) {
	req, err := client.usersDeleteSSHSigningKeyForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersDeleteSSHSigningKeyForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersDeleteSSHSigningKeyForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersDeleteSSHSigningKeyForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersDeleteSSHSigningKeyForAuthenticatedUserHandleResponse(resp)
}

// usersDeleteSSHSigningKeyForAuthenticatedUserCreateRequest creates the UsersDeleteSSHSigningKeyForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersDeleteSSHSigningKeyForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersDeleteSSHSigningKeyForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/ssh_signing_keys/{ssh_signing_key_id}"
	urlPath = strings.ReplaceAll(urlPath, "{ssh_signing_key_id}", url.PathEscape(strconv.FormatInt(int64(client.sshSigningKeyID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersDeleteSSHSigningKeyForAuthenticatedUserHandleResponse handles the UsersDeleteSSHSigningKeyForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersDeleteSSHSigningKeyForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersDeleteSSHSigningKeyForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersDeleteSSHSigningKeyForAuthenticatedUserResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientUsersDeleteSSHSigningKeyForAuthenticatedUserResponse{}, err
	}
	return result, nil
}

// UsersFollow - Note that you'll need to set Content-Length to zero when calling out to this endpoint. For more information,
// see "HTTP verbs
// [https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs]."
// Following a user requires the user to be logged in and authenticated with basic auth or OAuth with the user:follow scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersFollowOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersFollow
//     method.
func (client *GitHubV3RESTAPIClient) UsersFollow(ctx context.Context, options *GitHubV3RESTAPIClientUsersFollowOptions) (GitHubV3RESTAPIClientUsersFollowResponse, error) {
	req, err := client.usersFollowCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersFollowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersFollowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersFollowResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersFollowHandleResponse(resp)
}

// usersFollowCreateRequest creates the UsersFollow request.
func (client *GitHubV3RESTAPIClient) usersFollowCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersFollowOptions) (*policy.Request, error) {
	urlPath := "/user/following/{username}"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersFollowHandleResponse handles the UsersFollow response.
func (client *GitHubV3RESTAPIClient) usersFollowHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersFollowResponse, error) {
	result := GitHubV3RESTAPIClientUsersFollowResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientUsersFollowResponse{}, err
	}
	return result, nil
}

// UsersGetAuthenticated - If the authenticated user is authenticated through basic authentication or OAuth with the user
// scope, then the response lists public and private profile information.
// If the authenticated user is authenticated through OAuth without the user scope, then the response lists only public profile
// information.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersGetAuthenticatedOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersGetAuthenticated
//     method.
func (client *GitHubV3RESTAPIClient) UsersGetAuthenticated(ctx context.Context, options *GitHubV3RESTAPIClientUsersGetAuthenticatedOptions) (GitHubV3RESTAPIClientUsersGetAuthenticatedResponse, error) {
	req, err := client.usersGetAuthenticatedCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersGetAuthenticatedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersGetAuthenticatedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientUsersGetAuthenticatedResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersGetAuthenticatedHandleResponse(resp)
}

// usersGetAuthenticatedCreateRequest creates the UsersGetAuthenticated request.
func (client *GitHubV3RESTAPIClient) usersGetAuthenticatedCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersGetAuthenticatedOptions) (*policy.Request, error) {
	urlPath := "/user"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersGetAuthenticatedHandleResponse handles the UsersGetAuthenticated response.
func (client *GitHubV3RESTAPIClient) usersGetAuthenticatedHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersGetAuthenticatedResponse, error) {
	result := GitHubV3RESTAPIClientUsersGetAuthenticatedResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PathsYmu23VUserGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetAuthenticatedResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetAuthenticatedResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetAuthenticatedResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersGetAuthenticatedResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersGetByUsername - Provides publicly available information about someone with a GitHub account.
// GitHub Apps with the Plan user permission can use this endpoint to retrieve information about a user's GitHub plan. The
// GitHub App must be authenticated as a user. See "Identifying and authorizing
// users for GitHub Apps [https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/]"
// for details about authentication. For an example response, see 'Response
// with GitHub plan information' below"
// The email key in the following response is the publicly visible email address from your GitHub profile page [https://github.com/settings/profile].
// When setting up your profile, you can select a
// primary email address to be public which provides an email entry for this endpoint. If you do not set a public email
// address for email, then it will have a value of null. You only see publicly
// visible email addresses when authenticated with GitHub. For more information, see Authentication [https://docs.github.com/rest/overview/resources-in-the-rest-api#authentication].
// The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For
// more information, see "Emails API
// [https://docs.github.com/rest/reference/users#emails]".
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersGetByUsernameOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersGetByUsername
//     method.
func (client *GitHubV3RESTAPIClient) UsersGetByUsername(ctx context.Context, options *GitHubV3RESTAPIClientUsersGetByUsernameOptions) (GitHubV3RESTAPIClientUsersGetByUsernameResponse, error) {
	req, err := client.usersGetByUsernameCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersGetByUsernameResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersGetByUsernameResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersGetByUsernameResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersGetByUsernameHandleResponse(resp)
}

// usersGetByUsernameCreateRequest creates the UsersGetByUsername request.
func (client *GitHubV3RESTAPIClient) usersGetByUsernameCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersGetByUsernameOptions) (*policy.Request, error) {
	urlPath := "/users/{username}"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersGetByUsernameHandleResponse handles the UsersGetByUsername response.
func (client *GitHubV3RESTAPIClient) usersGetByUsernameHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersGetByUsernameResponse, error) {
	result := GitHubV3RESTAPIClientUsersGetByUsernameResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Paths1Iz9SlvUsersUsernameGetResponses200ContentApplicationJSONSchema
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetByUsernameResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetByUsernameResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersGetByUsernameResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersGetContextForUser - Provides hovercard information when authenticated through basic auth or OAuth with the repo scope.
// You can find out more about someone in relation to their pull requests, issues, repositories, and
// organizations.
// The subjecttype and subjectid parameters provide context for the person's hovercard, which returns more information than
// without the parameters. For example, if you wanted to find out more about
// octocat who owns the Spoon-Knife repository via cURL, it would look like this:
// curl -u username:token https://api.github.com/users/octocat/hovercard?subjecttype=repository&subjectid=1300192
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersGetContextForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersGetContextForUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersGetContextForUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersGetContextForUserOptions) (GitHubV3RESTAPIClientUsersGetContextForUserResponse, error) {
	req, err := client.usersGetContextForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersGetContextForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersGetContextForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientUsersGetContextForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersGetContextForUserHandleResponse(resp)
}

// usersGetContextForUserCreateRequest creates the UsersGetContextForUser request.
func (client *GitHubV3RESTAPIClient) usersGetContextForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersGetContextForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/hovercard"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SubjectType != nil {
		reqQP.Set("subject_type", string(*options.SubjectType))
	}
	if options != nil && options.SubjectID != nil {
		reqQP.Set("subject_id", *options.SubjectID)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersGetContextForUserHandleResponse handles the UsersGetContextForUser response.
func (client *GitHubV3RESTAPIClient) usersGetContextForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersGetContextForUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersGetContextForUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Hovercard
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetContextForUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetContextForUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetContextForUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersGetContextForUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersGetGpgKeyForAuthenticatedUser - View extended details for a single GPG key. Requires that you are authenticated via
// Basic Auth or via OAuth with at least read:gpg_key scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersGetGpgKeyForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersGetGpgKeyForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersGetGpgKeyForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersGetGpgKeyForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersGetGpgKeyForAuthenticatedUserResponse, error) {
	req, err := client.usersGetGpgKeyForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersGetGpgKeyForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersGetGpgKeyForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersGetGpgKeyForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersGetGpgKeyForAuthenticatedUserHandleResponse(resp)
}

// usersGetGpgKeyForAuthenticatedUserCreateRequest creates the UsersGetGpgKeyForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersGetGpgKeyForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersGetGpgKeyForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/gpg_keys/{gpg_key_id}"
	urlPath = strings.ReplaceAll(urlPath, "{gpg_key_id}", url.PathEscape(strconv.FormatInt(int64(client.gpgKeyID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersGetGpgKeyForAuthenticatedUserHandleResponse handles the UsersGetGpgKeyForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersGetGpgKeyForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersGetGpgKeyForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersGetGpgKeyForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val GpgKey
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetGpgKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetGpgKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetGpgKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetGpgKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersGetGpgKeyForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersGetPublicSSHKeyForAuthenticatedUser - View extended details for a single public SSH key. Requires that you are authenticated
// via Basic Auth or via OAuth with at least read:public_key scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersGetPublicSSHKeyForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.UsersGetPublicSSHKeyForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) UsersGetPublicSSHKeyForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersGetPublicSSHKeyForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersGetPublicSSHKeyForAuthenticatedUserResponse, error) {
	req, err := client.usersGetPublicSSHKeyForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersGetPublicSSHKeyForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersGetPublicSSHKeyForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersGetPublicSSHKeyForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersGetPublicSSHKeyForAuthenticatedUserHandleResponse(resp)
}

// usersGetPublicSSHKeyForAuthenticatedUserCreateRequest creates the UsersGetPublicSSHKeyForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersGetPublicSSHKeyForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersGetPublicSSHKeyForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/keys/{key_id}"
	urlPath = strings.ReplaceAll(urlPath, "{key_id}", url.PathEscape(strconv.FormatInt(int64(client.keyID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersGetPublicSSHKeyForAuthenticatedUserHandleResponse handles the UsersGetPublicSSHKeyForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersGetPublicSSHKeyForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersGetPublicSSHKeyForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersGetPublicSSHKeyForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val Key
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetPublicSSHKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetPublicSSHKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetPublicSSHKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetPublicSSHKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersGetPublicSSHKeyForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersGetSSHSigningKeyForAuthenticatedUser - Gets extended details for an SSH signing key. You must authenticate with Basic
// Authentication, or you must authenticate with OAuth with at least read:sshsigningkey scope. For more information, see "
// Understanding scopes for OAuth apps [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersGetSSHSigningKeyForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.UsersGetSSHSigningKeyForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) UsersGetSSHSigningKeyForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersGetSSHSigningKeyForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersGetSSHSigningKeyForAuthenticatedUserResponse, error) {
	req, err := client.usersGetSSHSigningKeyForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersGetSSHSigningKeyForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersGetSSHSigningKeyForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersGetSSHSigningKeyForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersGetSSHSigningKeyForAuthenticatedUserHandleResponse(resp)
}

// usersGetSSHSigningKeyForAuthenticatedUserCreateRequest creates the UsersGetSSHSigningKeyForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersGetSSHSigningKeyForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersGetSSHSigningKeyForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/ssh_signing_keys/{ssh_signing_key_id}"
	urlPath = strings.ReplaceAll(urlPath, "{ssh_signing_key_id}", url.PathEscape(strconv.FormatInt(int64(client.sshSigningKeyID), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersGetSSHSigningKeyForAuthenticatedUserHandleResponse handles the UsersGetSSHSigningKeyForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersGetSSHSigningKeyForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersGetSSHSigningKeyForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersGetSSHSigningKeyForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val SSHSigningKey
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetSSHSigningKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetSSHSigningKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetSSHSigningKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersGetSSHSigningKeyForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersGetSSHSigningKeyForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersList - Lists all users, in the order that they signed up on GitHub. This list includes personal user accounts and
// organization accounts.
// Note: Pagination is powered exclusively by the since parameter. Use the Link header [https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header]
// to get the URL for the next page of
// users.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersListOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersList
//     method.
func (client *GitHubV3RESTAPIClient) UsersList(ctx context.Context, options *GitHubV3RESTAPIClientUsersListOptions) (GitHubV3RESTAPIClientUsersListResponse, error) {
	req, err := client.usersListCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified) {
		return GitHubV3RESTAPIClientUsersListResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersListHandleResponse(resp)
}

// usersListCreateRequest creates the UsersList request.
func (client *GitHubV3RESTAPIClient) usersListCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersListOptions) (*policy.Request, error) {
	urlPath := "/users"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.since != nil {
		reqQP.Set("since", client.since.Format(time.RFC3339Nano))
	}
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersListHandleResponse handles the UsersList response.
func (client *GitHubV3RESTAPIClient) usersListHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersListResponse, error) {
	result := GitHubV3RESTAPIClientUsersListResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.SimpleUserArray); err != nil {
		return GitHubV3RESTAPIClientUsersListResponse{}, err
	}
	return result, nil
}

// UsersListBlockedByAuthenticatedUser - List the users you've blocked on your personal account.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersListBlockedByAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersListBlockedByAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersListBlockedByAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersListBlockedByAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersListBlockedByAuthenticatedUserResponse, error) {
	req, err := client.usersListBlockedByAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListBlockedByAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListBlockedByAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersListBlockedByAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersListBlockedByAuthenticatedUserHandleResponse(resp)
}

// usersListBlockedByAuthenticatedUserCreateRequest creates the UsersListBlockedByAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersListBlockedByAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersListBlockedByAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/blocks"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersListBlockedByAuthenticatedUserHandleResponse handles the UsersListBlockedByAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersListBlockedByAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersListBlockedByAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersListBlockedByAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*SimpleUser
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListBlockedByAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListBlockedByAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListBlockedByAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListBlockedByAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersListBlockedByAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersListEmailsForAuthenticatedUser - Lists all of your email addresses, and specifies which one is visible to the public.
// This endpoint is accessible with the user:email scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersListEmailsForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersListEmailsForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersListEmailsForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersListEmailsForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersListEmailsForAuthenticatedUserResponse, error) {
	req, err := client.usersListEmailsForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListEmailsForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListEmailsForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersListEmailsForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersListEmailsForAuthenticatedUserHandleResponse(resp)
}

// usersListEmailsForAuthenticatedUserCreateRequest creates the UsersListEmailsForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersListEmailsForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersListEmailsForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/emails"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersListEmailsForAuthenticatedUserHandleResponse handles the UsersListEmailsForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersListEmailsForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersListEmailsForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersListEmailsForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Email
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListEmailsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListEmailsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListEmailsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListEmailsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersListEmailsForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersListFollowedByAuthenticatedUser - Lists the people who the authenticated user follows.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersListFollowedByAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersListFollowedByAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersListFollowedByAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersListFollowedByAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersListFollowedByAuthenticatedUserResponse, error) {
	req, err := client.usersListFollowedByAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListFollowedByAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListFollowedByAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientUsersListFollowedByAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersListFollowedByAuthenticatedUserHandleResponse(resp)
}

// usersListFollowedByAuthenticatedUserCreateRequest creates the UsersListFollowedByAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersListFollowedByAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersListFollowedByAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/following"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersListFollowedByAuthenticatedUserHandleResponse handles the UsersListFollowedByAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersListFollowedByAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersListFollowedByAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersListFollowedByAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*SimpleUser
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListFollowedByAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListFollowedByAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListFollowedByAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersListFollowedByAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersListFollowersForAuthenticatedUser - Lists the people following the authenticated user.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersListFollowersForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersListFollowersForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersListFollowersForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersListFollowersForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersListFollowersForAuthenticatedUserResponse, error) {
	req, err := client.usersListFollowersForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListFollowersForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListFollowersForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden) {
		return GitHubV3RESTAPIClientUsersListFollowersForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersListFollowersForAuthenticatedUserHandleResponse(resp)
}

// usersListFollowersForAuthenticatedUserCreateRequest creates the UsersListFollowersForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersListFollowersForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersListFollowersForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/followers"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersListFollowersForAuthenticatedUserHandleResponse handles the UsersListFollowersForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersListFollowersForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersListFollowersForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersListFollowersForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*SimpleUser
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListFollowersForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListFollowersForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListFollowersForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersListFollowersForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersListFollowersForUser - Lists the people following the specified user.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersListFollowersForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersListFollowersForUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersListFollowersForUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersListFollowersForUserOptions) (GitHubV3RESTAPIClientUsersListFollowersForUserResponse, error) {
	req, err := client.usersListFollowersForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListFollowersForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListFollowersForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientUsersListFollowersForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersListFollowersForUserHandleResponse(resp)
}

// usersListFollowersForUserCreateRequest creates the UsersListFollowersForUser request.
func (client *GitHubV3RESTAPIClient) usersListFollowersForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersListFollowersForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/followers"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersListFollowersForUserHandleResponse handles the UsersListFollowersForUser response.
func (client *GitHubV3RESTAPIClient) usersListFollowersForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersListFollowersForUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersListFollowersForUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.SimpleUserArray); err != nil {
		return GitHubV3RESTAPIClientUsersListFollowersForUserResponse{}, err
	}
	return result, nil
}

// UsersListFollowingForUser - Lists the people who the specified user follows.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersListFollowingForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersListFollowingForUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersListFollowingForUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersListFollowingForUserOptions) (GitHubV3RESTAPIClientUsersListFollowingForUserResponse, error) {
	req, err := client.usersListFollowingForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListFollowingForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListFollowingForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientUsersListFollowingForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersListFollowingForUserHandleResponse(resp)
}

// usersListFollowingForUserCreateRequest creates the UsersListFollowingForUser request.
func (client *GitHubV3RESTAPIClient) usersListFollowingForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersListFollowingForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/following"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersListFollowingForUserHandleResponse handles the UsersListFollowingForUser response.
func (client *GitHubV3RESTAPIClient) usersListFollowingForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersListFollowingForUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersListFollowingForUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.SimpleUserArray); err != nil {
		return GitHubV3RESTAPIClientUsersListFollowingForUserResponse{}, err
	}
	return result, nil
}

// UsersListGpgKeysForAuthenticatedUser - Lists the current user's GPG keys. Requires that you are authenticated via Basic
// Auth or via OAuth with at least read:gpg_key scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersListGpgKeysForAuthenticatedUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersListGpgKeysForAuthenticatedUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersListGpgKeysForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersListGpgKeysForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersListGpgKeysForAuthenticatedUserResponse, error) {
	req, err := client.usersListGpgKeysForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListGpgKeysForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListGpgKeysForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersListGpgKeysForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersListGpgKeysForAuthenticatedUserHandleResponse(resp)
}

// usersListGpgKeysForAuthenticatedUserCreateRequest creates the UsersListGpgKeysForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersListGpgKeysForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersListGpgKeysForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/gpg_keys"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersListGpgKeysForAuthenticatedUserHandleResponse handles the UsersListGpgKeysForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersListGpgKeysForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersListGpgKeysForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersListGpgKeysForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*GpgKey
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListGpgKeysForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListGpgKeysForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListGpgKeysForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListGpgKeysForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersListGpgKeysForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersListGpgKeysForUser - Lists the GPG keys for a user. This information is accessible by anyone.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersListGpgKeysForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersListGpgKeysForUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersListGpgKeysForUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersListGpgKeysForUserOptions) (GitHubV3RESTAPIClientUsersListGpgKeysForUserResponse, error) {
	req, err := client.usersListGpgKeysForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListGpgKeysForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListGpgKeysForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientUsersListGpgKeysForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersListGpgKeysForUserHandleResponse(resp)
}

// usersListGpgKeysForUserCreateRequest creates the UsersListGpgKeysForUser request.
func (client *GitHubV3RESTAPIClient) usersListGpgKeysForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersListGpgKeysForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/gpg_keys"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersListGpgKeysForUserHandleResponse handles the UsersListGpgKeysForUser response.
func (client *GitHubV3RESTAPIClient) usersListGpgKeysForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersListGpgKeysForUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersListGpgKeysForUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.GpgKeyArray); err != nil {
		return GitHubV3RESTAPIClientUsersListGpgKeysForUserResponse{}, err
	}
	return result, nil
}

// UsersListPublicEmailsForAuthenticatedUser - Lists your publicly visible email address, which you can set with the Set primary
// email visibility for the authenticated user
// [https://docs.github.com/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user] endpoint. This endpoint
// is accessible with the user:email scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersListPublicEmailsForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.UsersListPublicEmailsForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) UsersListPublicEmailsForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersListPublicEmailsForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersListPublicEmailsForAuthenticatedUserResponse, error) {
	req, err := client.usersListPublicEmailsForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListPublicEmailsForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListPublicEmailsForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersListPublicEmailsForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersListPublicEmailsForAuthenticatedUserHandleResponse(resp)
}

// usersListPublicEmailsForAuthenticatedUserCreateRequest creates the UsersListPublicEmailsForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersListPublicEmailsForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersListPublicEmailsForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/public_emails"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersListPublicEmailsForAuthenticatedUserHandleResponse handles the UsersListPublicEmailsForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersListPublicEmailsForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersListPublicEmailsForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersListPublicEmailsForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Email
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListPublicEmailsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListPublicEmailsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListPublicEmailsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListPublicEmailsForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersListPublicEmailsForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersListPublicKeysForUser - Lists the verified public SSH keys for a user. This is accessible by anyone.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersListPublicKeysForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersListPublicKeysForUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersListPublicKeysForUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersListPublicKeysForUserOptions) (GitHubV3RESTAPIClientUsersListPublicKeysForUserResponse, error) {
	req, err := client.usersListPublicKeysForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListPublicKeysForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListPublicKeysForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientUsersListPublicKeysForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersListPublicKeysForUserHandleResponse(resp)
}

// usersListPublicKeysForUserCreateRequest creates the UsersListPublicKeysForUser request.
func (client *GitHubV3RESTAPIClient) usersListPublicKeysForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersListPublicKeysForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/keys"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersListPublicKeysForUserHandleResponse handles the UsersListPublicKeysForUser response.
func (client *GitHubV3RESTAPIClient) usersListPublicKeysForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersListPublicKeysForUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersListPublicKeysForUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeySimpleArray); err != nil {
		return GitHubV3RESTAPIClientUsersListPublicKeysForUserResponse{}, err
	}
	return result, nil
}

// UsersListPublicSSHKeysForAuthenticatedUser - Lists the public SSH keys for the authenticated user's GitHub account. Requires
// that you are authenticated via Basic Auth or via OAuth with at least read:public_key scope
// [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersListPublicSSHKeysForAuthenticatedUserOptions contains the optional parameters for the
//     GitHubV3RESTAPIClient.UsersListPublicSSHKeysForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) UsersListPublicSSHKeysForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersListPublicSSHKeysForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersListPublicSSHKeysForAuthenticatedUserResponse, error) {
	req, err := client.usersListPublicSSHKeysForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListPublicSSHKeysForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListPublicSSHKeysForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersListPublicSSHKeysForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersListPublicSSHKeysForAuthenticatedUserHandleResponse(resp)
}

// usersListPublicSSHKeysForAuthenticatedUserCreateRequest creates the UsersListPublicSSHKeysForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersListPublicSSHKeysForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersListPublicSSHKeysForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/keys"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersListPublicSSHKeysForAuthenticatedUserHandleResponse handles the UsersListPublicSSHKeysForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersListPublicSSHKeysForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersListPublicSSHKeysForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersListPublicSSHKeysForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Key
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListPublicSSHKeysForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListPublicSSHKeysForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListPublicSSHKeysForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListPublicSSHKeysForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersListPublicSSHKeysForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersListSSHSigningKeysForAuthenticatedUser - Lists the SSH signing keys for the authenticated user's GitHub account. You
// must authenticate with Basic Authentication, or you must authenticate with OAuth with at least read:sshsigningkey scope.
// For
// more information, see "Understanding scopes for OAuth apps [https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/]."
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersListSSHSigningKeysForAuthenticatedUserOptions contains the optional parameters for
//     the GitHubV3RESTAPIClient.UsersListSSHSigningKeysForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) UsersListSSHSigningKeysForAuthenticatedUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersListSSHSigningKeysForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersListSSHSigningKeysForAuthenticatedUserResponse, error) {
	req, err := client.usersListSSHSigningKeysForAuthenticatedUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListSSHSigningKeysForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListSSHSigningKeysForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersListSSHSigningKeysForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersListSSHSigningKeysForAuthenticatedUserHandleResponse(resp)
}

// usersListSSHSigningKeysForAuthenticatedUserCreateRequest creates the UsersListSSHSigningKeysForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersListSSHSigningKeysForAuthenticatedUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersListSSHSigningKeysForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/ssh_signing_keys"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersListSSHSigningKeysForAuthenticatedUserHandleResponse handles the UsersListSSHSigningKeysForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersListSSHSigningKeysForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersListSSHSigningKeysForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersListSSHSigningKeysForAuthenticatedUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*SSHSigningKey
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListSSHSigningKeysForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListSSHSigningKeysForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListSSHSigningKeysForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersListSSHSigningKeysForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersListSSHSigningKeysForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersListSSHSigningKeysForUser - Lists the SSH signing keys for a user. This operation is accessible by anyone.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersListSSHSigningKeysForUserOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersListSSHSigningKeysForUser
//     method.
func (client *GitHubV3RESTAPIClient) UsersListSSHSigningKeysForUser(ctx context.Context, options *GitHubV3RESTAPIClientUsersListSSHSigningKeysForUserOptions) (GitHubV3RESTAPIClientUsersListSSHSigningKeysForUserResponse, error) {
	req, err := client.usersListSSHSigningKeysForUserCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListSSHSigningKeysForUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersListSSHSigningKeysForUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return GitHubV3RESTAPIClientUsersListSSHSigningKeysForUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersListSSHSigningKeysForUserHandleResponse(resp)
}

// usersListSSHSigningKeysForUserCreateRequest creates the UsersListSSHSigningKeysForUser request.
func (client *GitHubV3RESTAPIClient) usersListSSHSigningKeysForUserCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersListSSHSigningKeysForUserOptions) (*policy.Request, error) {
	urlPath := "/users/{username}/ssh_signing_keys"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.perPage != nil {
		reqQP.Set("per_page", strconv.FormatInt(int64(*client.perPage), 10))
	}
	if client.page != nil {
		reqQP.Set("page", strconv.FormatInt(int64(*client.page), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersListSSHSigningKeysForUserHandleResponse handles the UsersListSSHSigningKeysForUser response.
func (client *GitHubV3RESTAPIClient) usersListSSHSigningKeysForUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersListSSHSigningKeysForUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersListSSHSigningKeysForUserResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.SSHSigningKeyArray); err != nil {
		return GitHubV3RESTAPIClientUsersListSSHSigningKeysForUserResponse{}, err
	}
	return result, nil
}

// UsersSetPrimaryEmailVisibilityForAuthenticatedUser - Sets the visibility for your primary email addresses.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersSetPrimaryEmailVisibilityForAuthenticatedUserOptions contains the optional parameters
//     for the GitHubV3RESTAPIClient.UsersSetPrimaryEmailVisibilityForAuthenticatedUser method.
func (client *GitHubV3RESTAPIClient) UsersSetPrimaryEmailVisibilityForAuthenticatedUser(ctx context.Context, body PathsSq4K7LUserEmailVisibilityPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientUsersSetPrimaryEmailVisibilityForAuthenticatedUserOptions) (GitHubV3RESTAPIClientUsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse, error) {
	req, err := client.usersSetPrimaryEmailVisibilityForAuthenticatedUserCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientUsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersSetPrimaryEmailVisibilityForAuthenticatedUserHandleResponse(resp)
}

// usersSetPrimaryEmailVisibilityForAuthenticatedUserCreateRequest creates the UsersSetPrimaryEmailVisibilityForAuthenticatedUser request.
func (client *GitHubV3RESTAPIClient) usersSetPrimaryEmailVisibilityForAuthenticatedUserCreateRequest(ctx context.Context, body PathsSq4K7LUserEmailVisibilityPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientUsersSetPrimaryEmailVisibilityForAuthenticatedUserOptions) (*policy.Request, error) {
	urlPath := "/user/email/visibility"
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// usersSetPrimaryEmailVisibilityForAuthenticatedUserHandleResponse handles the UsersSetPrimaryEmailVisibilityForAuthenticatedUser response.
func (client *GitHubV3RESTAPIClient) usersSetPrimaryEmailVisibilityForAuthenticatedUserHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse, error) {
	result := GitHubV3RESTAPIClientUsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val []*Email
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UsersUnblock - Unblock a user
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersUnblockOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersUnblock
//     method.
func (client *GitHubV3RESTAPIClient) UsersUnblock(ctx context.Context, options *GitHubV3RESTAPIClientUsersUnblockOptions) (GitHubV3RESTAPIClientUsersUnblockResponse, error) {
	req, err := client.usersUnblockCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersUnblockResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersUnblockResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersUnblockResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersUnblockHandleResponse(resp)
}

// usersUnblockCreateRequest creates the UsersUnblock request.
func (client *GitHubV3RESTAPIClient) usersUnblockCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersUnblockOptions) (*policy.Request, error) {
	urlPath := "/user/blocks/{username}"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersUnblockHandleResponse handles the UsersUnblock response.
func (client *GitHubV3RESTAPIClient) usersUnblockHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersUnblockResponse, error) {
	result := GitHubV3RESTAPIClientUsersUnblockResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientUsersUnblockResponse{}, err
	}
	return result, nil
}

// UsersUnfollow - Unfollowing a user requires the user to be logged in and authenticated with basic auth or OAuth with the
// user:follow scope.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersUnfollowOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersUnfollow
//     method.
func (client *GitHubV3RESTAPIClient) UsersUnfollow(ctx context.Context, options *GitHubV3RESTAPIClientUsersUnfollowOptions) (GitHubV3RESTAPIClientUsersUnfollowResponse, error) {
	req, err := client.usersUnfollowCreateRequest(ctx, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersUnfollowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersUnfollowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return GitHubV3RESTAPIClientUsersUnfollowResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersUnfollowHandleResponse(resp)
}

// usersUnfollowCreateRequest creates the UsersUnfollow request.
func (client *GitHubV3RESTAPIClient) usersUnfollowCreateRequest(ctx context.Context, options *GitHubV3RESTAPIClientUsersUnfollowOptions) (*policy.Request, error) {
	urlPath := "/user/following/{username}"
	if client.username == "" {
		return nil, errors.New("parameter client.username cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{username}", url.PathEscape(client.username))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// usersUnfollowHandleResponse handles the UsersUnfollow response.
func (client *GitHubV3RESTAPIClient) usersUnfollowHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersUnfollowResponse, error) {
	result := GitHubV3RESTAPIClientUsersUnfollowResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BasicError); err != nil {
		return GitHubV3RESTAPIClientUsersUnfollowResponse{}, err
	}
	return result, nil
}

// UsersUpdateAuthenticated - Note: If your email is set to private and you send an email parameter as part of this request
// to update your profile, your privacy settings are still enforced: the email address will not be displayed
// on your public profile or via the API.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.1.4
//   - options - GitHubV3RESTAPIClientUsersUpdateAuthenticatedOptions contains the optional parameters for the GitHubV3RESTAPIClient.UsersUpdateAuthenticated
//     method.
func (client *GitHubV3RESTAPIClient) UsersUpdateAuthenticated(ctx context.Context, body Paths1Hu5S40UserPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientUsersUpdateAuthenticatedOptions) (GitHubV3RESTAPIClientUsersUpdateAuthenticatedResponse, error) {
	req, err := client.usersUpdateAuthenticatedCreateRequest(ctx, body, options)
	if err != nil {
		return GitHubV3RESTAPIClientUsersUpdateAuthenticatedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return GitHubV3RESTAPIClientUsersUpdateAuthenticatedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNotModified, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusUnprocessableEntity) {
		return GitHubV3RESTAPIClientUsersUpdateAuthenticatedResponse{}, runtime.NewResponseError(resp)
	}
	return client.usersUpdateAuthenticatedHandleResponse(resp)
}

// usersUpdateAuthenticatedCreateRequest creates the UsersUpdateAuthenticated request.
func (client *GitHubV3RESTAPIClient) usersUpdateAuthenticatedCreateRequest(ctx context.Context, body Paths1Hu5S40UserPatchRequestbodyContentApplicationJSONSchema, options *GitHubV3RESTAPIClientUsersUpdateAuthenticatedOptions) (*policy.Request, error) {
	urlPath := "/user"
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, body)
}

// usersUpdateAuthenticatedHandleResponse handles the UsersUpdateAuthenticated response.
func (client *GitHubV3RESTAPIClient) usersUpdateAuthenticatedHandleResponse(resp *http.Response) (GitHubV3RESTAPIClientUsersUpdateAuthenticatedResponse, error) {
	result := GitHubV3RESTAPIClientUsersUpdateAuthenticatedResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val PrivateUser
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersUpdateAuthenticatedResponse{}, err
	}
	result.Value = val
	case http.StatusNotModified:
	case http.StatusUnauthorized:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersUpdateAuthenticatedResponse{}, err
	}
	result.Value = val
	case http.StatusForbidden:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersUpdateAuthenticatedResponse{}, err
	}
	result.Value = val
	case http.StatusNotFound:
	var val BasicError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersUpdateAuthenticatedResponse{}, err
	}
	result.Value = val
	case http.StatusUnprocessableEntity:
	var val ValidationError
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return GitHubV3RESTAPIClientUsersUpdateAuthenticatedResponse{}, err
	}
	result.Value = val
	default:
		return GitHubV3RESTAPIClientUsersUpdateAuthenticatedResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

